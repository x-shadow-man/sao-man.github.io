<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - istio Gateway 设置路由</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-Gateway-%E8%AE%BE%E7%BD%AE%E8%B7%AF%E7%94%B1/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-Gateway-%E8%AE%BE%E7%BD%AE%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<p>1 流量管理</p><p>2 创建命名空间</p><p>3 资源文件准备</p><p>  3.1 创建网关文件</p><p>  3.2 创建虚拟服务文件</p><p>  3.3 创建 k8s service 文件</p><p>  3.4 创建 k8s deployment 文件：</p><p>  3.5 修改 istio-ingressgateway deployment</p><p>4 尝试网关路由功能</p><p>  4.1 确定 INGRESS_HOST</p><p>  4.2 编辑浏览器所在主机 hosts 文件</p><p>  4.3 访问 tomcat</p><p>5 小节</p><hr><h2 id="1-流量管理（traffic-management）"><a href="#1-流量管理（traffic-management）" class="headerlink" title="1 流量管理（traffic management）"></a>1 流量管理（traffic management）</h2><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911165314268.png" srcset="/img/loading.gif" lazyload alt="image-20210911165314268"></p><p>​    istio 四大特性是流量管理（traffic management）、安全（security）、策略（policies）和遥测（observability）。</p><p>​    本节重点介绍 istio 流量管理。流量管理的本质是对网络流量的路由和控制。生活中经常有这样的例子，比如下雨塌方，交警会疏导新的交通路线，这便是路由；比如景区周末实行单双号限行，这便是流量控制。</p><p>​    在介绍流量管理之前，首先介绍一下网络流向，介绍一个 http 请求在安装了 istio 的 k8s 中都经过哪些点，有了这个介绍之后，再谈流量管理将是水到渠成的事情。</p><p>​    下图便是网络流向图：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911165357073.png" srcset="/img/loading.gif" lazyload alt="image-20210911165357073"></p><p>​    当用户使用浏览器发起一个请求( <a href="http://jiuxi.com/xxx">http://jiuxi.com/xxx</a> )进入 k8s 中的 istio-ingressgateway，因为在  istio-ingressgateway 上设置了 istio 的 gateway，而且此 gateway 又绑定了 virtual  service，在 virtual service 设置了 2 条路由规则，分别指向 tomcat 和 nginx 这 2 个 k8s  service，而每个 service 又关联到各自的 pod，于是此请求最终可根据 url 触达到 pod 内的容器。</p><p>​    了解了请求流向的整个流程，下面介绍如何操作。前提是你已经安装好了 k8s 和 istio。关于如何安装和配置 istio，可以查看本人的系列文章第一章。</p><hr><h2 id="2-创建命名空间"><a href="#2-创建命名空间" class="headerlink" title="2 创建命名空间"></a>2 创建命名空间</h2><blockquote><p>kubectl create ns jiuxi</p></blockquote><p>​    istio 默认安装在 jiuxi 这个命名空间下，并且设置在 jiuxi 命名空间自动注入 sidecar。相关操作请参考本人系列文章的第一章。</p><hr><h2 id="3-资源文件准备"><a href="#3-资源文件准备" class="headerlink" title="3 资源文件准备"></a>3 资源文件准备</h2><p>​    从上图可知，共需要 4 个资源文件（yaml）：</p><blockquote><p>1 jiuxi-gateway.yaml</p><p>2 jiuxi-virtual-svc.yaml</p><p>3 jiuxi-svc.yaml( tomcat 和 nginx 的 service 写在一个文件）</p><p>4 jiuxi-deploy.yaml（tomcat 和 nginx 的 deployment 写在一个文件）</p></blockquote><h3 id="3-1-创建网关文件"><a href="#3-1-创建网关文件" class="headerlink" title="3.1 创建网关文件"></a>3.1 创建网关文件</h3><p>​    网关文件 jiuxi-gateway.yaml 文件内容如下：</p><blockquote><p>apiVersion: networking.istio.io/v1alpha3</p><p>kind: Gateway</p><p>metadata:</p><p>  name: jiuxi-gateway</p><p>  namespace: jiuxi</p><p>spec:</p><p>  selector:</p><p>​    istio: ingressgateway</p><p>servers:</p><p>- hosts:</p><p>  - jiuxi.com</p><p>  port:</p><p>​    number: 80</p><p>​    name: http</p><p>​    protocol: HTTP</p></blockquote><p>​    创建资源：</p><blockquote><p>kubectl apply -f jiuxi-gateway.yaml</p></blockquote><h3 id="3-2-创建虚拟服务文件"><a href="#3-2-创建虚拟服务文件" class="headerlink" title="3.2 创建虚拟服务文件"></a>3.2 创建虚拟服务文件</h3><p>​    虚拟服务文件 jiuxi-virtual-svc.yaml 文件内容如下：</p><blockquote><p>apiVersion: networking.istio.io/v1alpha3</p><p>kind: VirtualService</p><p>metadata:</p><p>  name: jiuxi-virtual-svc</p><p>  namespace: jiuxi</p><p>spec:</p><p>  gateways:</p><p>  - jiuxi-gateway</p><p>  hosts:</p><p>  - jiuxi.com</p><p>  http:</p><p>  - route:</p><p>​    - destination:</p><p>​       host: tomcat-svc</p><p>​       port:</p><p>​         number: 8080</p><p>​    weight: 50</p><p>​    - destination:</p><p>​       host: nginx-svc</p><p>​       port:</p><p>​         number: 80</p><p>​    weight: 50</p></blockquote><p>​    创建资源：</p><blockquote><p>kubectl apply -f jiuxi-virtual-svc.yaml</p></blockquote><h3 id="3-3-创建-k8s-service-文件"><a href="#3-3-创建-k8s-service-文件" class="headerlink" title="3.3 创建 k8s service 文件"></a>3.3 创建 k8s service 文件</h3><p>​    服务文件 jiuxi-svc.yaml 文件内容如下：</p><blockquote><p>apiVersion: v1</p><p>kind: Service</p><p>metadata:</p><p>  name: nginx-svc</p><p>  namespace: jiuxi</p><p>spec:</p><p>  ports:</p><p>  - name: port</p><p>​    port: 80</p><p>​    protocol: TCP</p><p>​    targetPort: 80</p><p>   selector:</p><p>​    app: nginx-pod</p><p>-–</p><p>apiVersion: v1</p><p>kind: Service</p><p>metadata:</p><p>  name: tomcat-svc</p><p>  namespace: jiuxi</p><p>spec:</p><p>  ports:</p><p>  - name: port</p><p>​    port: 8080</p><p>​    protocol: TCP</p><p>​    targetPort: 8080</p><p>  selector:</p><p>  app: tomcat-pod</p></blockquote><p>​    创建资源：</p><blockquote><p>kubectl apply -f jiuxi-svc.yaml</p></blockquote><h3 id="3-4-创建-k8s-deployment-文件"><a href="#3-4-创建-k8s-deployment-文件" class="headerlink" title="3.4 创建 k8s deployment 文件"></a>3.4 创建 k8s deployment 文件</h3><p>​    jiuxi-deploy 文件内容如下：</p><blockquote><p>apiVersion: apps/v1 </p><p>kind: Deployment </p><p>metadata: </p><p>  labels: </p><p>  app: nginx-deploy </p><p>  name: nginx-deploy </p><p>  namespace: jiuxi </p><p>spec: </p><p>  replicas: 1 </p><p>  selector: </p><p>​    matchLabels: </p><p>​      app: nginx-pod  </p><p>  template: </p><p>​    metadata: </p><p>​      labels: </p><p>​        app: nginx-pod  </p><p>​    spec: </p><p>​      containers:     </p><p>​      - image: nginx:1.14-alpine </p><p>​        imagePullPolicy: Always </p><p>​        name: nginx </p><p>​        ports: </p><p>​        - containerPort: 80 </p><p>​          name: port </p><p>​          protocol: TCP</p><p> —</p><p> apiVersion: apps/v1 </p><p>kind: Deployment</p><p>metadata: </p><p>  labels: </p><p>​    app: tomcat-deploy </p><p>  name: tomcat-deploy </p><p>  namespace: jiuxi </p><p>spec: </p><p>  replicas: 1 </p><p>  selector: </p><p>​    matchLabels: </p><p>​      app: tomcat-pod  </p><p>  template: </p><p>​    metadata: </p><p>​      labels: </p><p>​        app: tomcat-pod  </p><p>​    spec:</p><p>​      containers:</p><p>​      - image: docker.io/kubeguide/tomcat-app:v1</p><p>​        imagePullPolicy: Always</p><p>​        name: tomcat</p><p>​        ports:</p><p>​          - containerPort: 8080</p><p>​          name: port</p><p>​          protocol: TCP</p></blockquote><p>​    创建资源：</p><blockquote><p>kubectl apply -f jiuxi-deploy.yaml</p></blockquote><h3 id="3-5-修改-istio-ingressgateway-deployment"><a href="#3-5-修改-istio-ingressgateway-deployment" class="headerlink" title="3.5 修改 istio-ingressgateway deployment"></a>3.5 修改 istio-ingressgateway deployment</h3><p>​    这一步非常重要，因为默认情况下 istio-ingressgateway 对应的容器并没有暴露在服务网格之外，所以我们需要将其暴露出来。编辑 istio-system  命名空间下的 istio-ingressgateway deployment:</p><blockquote><p>kubectl edit deployment -n istio-system istio-ingressgateway</p></blockquote><p>​    修改内容如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911165456105.png" srcset="/img/loading.gif" lazyload alt="image-20210911165456105"></p><hr><h2 id="4-尝试网关路由功能"><a href="#4-尝试网关路由功能" class="headerlink" title="4 尝试网关路由功能"></a>4 尝试网关路由功能</h2><h3 id="4-1-确定-INGRESS-HOST"><a href="#4-1-确定-INGRESS-HOST" class="headerlink" title="4.1 确定 INGRESS_HOST"></a>4.1 确定 INGRESS_HOST</h3><blockquote><p>kubectl get pod -n istio-system -o wide</p></blockquote><p>​    执行结果如下图所示，本人的 INGRESS_HOST 就是 10.110.101.205。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911165522752.png" srcset="/img/loading.gif" lazyload alt="image-20210911165522752"></p><h3 id="4-2-编辑浏览器所在主机-hosts-文件"><a href="#4-2-编辑浏览器所在主机-hosts-文件" class="headerlink" title="4.2 编辑浏览器所在主机 hosts 文件"></a>4.2 编辑浏览器所在主机 hosts 文件</h3><blockquote><p>vim /etc/hosts    # linux</p><p>c:/windows/system32/drivers/etc/hosts    # windows</p></blockquote><p>​    添加 DNS 记录：</p><blockquote><p>10.110.101.205    jiuxi.com        # 根据个人实际情况改写</p></blockquote><h3 id="4-3-访问-tomcat"><a href="#4-3-访问-tomcat" class="headerlink" title="4.3 访问 tomcat"></a>4.3 访问 tomcat</h3><p>​    浏览器输入 <a href="http://jiuxi.com,帮尝试多刷新几次,你就会看到流量分别路由到/">http://jiuxi.com，帮尝试多刷新几次，你就会看到流量分别路由到</a> tomcat 和 nginx 服务去了，并且流量上基本达到了均分，各 50%。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911165604673.png" srcset="/img/loading.gif" lazyload alt="image-20210911165604673"></p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911165626103.png" srcset="/img/loading.gif" lazyload alt="image-20210911165626103"></p><hr><h2 id="5-小节"><a href="#5-小节" class="headerlink" title="5 小节"></a>5 小节</h2><p>​    自此我们使用了 istio 的 gateway 和 virtual service 实现了流量管理的功能。下面我们还会继续庖丁解牛 istio 其他强大的特性。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆服务网格 - istio Bookinfo 应用</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC-istio-Bookinfo-%E5%BA%94%E7%94%A8/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC-istio-Bookinfo-%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 bookinfo 架构介绍</p><p>3 bookinfo 配置与部署</p><p>  3.1 配置 istio 自动注入</p><p>  3.2 部署 bookinfo 应用</p><p>  3.3 验证 bookinfo 部署情况</p><p>4 设置 bookinfo 网关</p><p>  4.1 定义 bookinfo 入口网关</p><p>  4.2 确认网关已创建</p><p>5 访问 bookinfo 应用</p><p>  5.1 获取 INGRESS_HOST</p><p>  5.2 获取 INGRESS_PORT</p><p>  5.3 通过浏览器访问 bookinfo 应用</p><p>6 卸载 bookinfo 应用</p><p>  6.1 验证卸载</p><p>7 总结</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    如果你对博客有任何疑问或者想更深入学习 istio，请加微信群，我们一起进步：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164235979.png" srcset="/img/loading.gif" lazyload alt="image-20210911164235979"></p><hr><h2 id="2-bookinfo-架构介绍"><a href="#2-bookinfo-架构介绍" class="headerlink" title="2 bookinfo 架构介绍"></a>2 bookinfo 架构介绍</h2><p>​    bookinfo 是 istio 的学习样例，通过 bookinfo 你可以对 istio 提供的路由、遥测等功能有更加深入的理解。</p><p>​    下图是 bookinfo 在没有嵌入 istio 前的物理架构图：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164302523.png" srcset="/img/loading.gif" lazyload alt="image-20210911164302523"></p><p>​    bookinfo 是一个在线书店应用，该应用由 4 个微服务组成，分别为 Product page、Reviews、Details 和 Ratings。为了表现 istio 的无侵入性，这 4 个微服务分别由 python、java、ruby 和 node 开发。下面分别说明如下：</p><blockquote><p>Product page：聚合服务，内容由 Reviews 和 Details 内容聚合而成</p><p>Details：图书详情服务</p><p>Reviews：图书评价服务（多版本）。它也是一个聚合服务，聚合了 Ratings</p><p>Ratings：图书预订排名服务</p></blockquote><p>​    下图是 bookinfo 嵌入 istio 后的物理架构图：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164323375.png" srcset="/img/loading.gif" lazyload alt="image-20210911164323375"></p><p>​    该架构图演示了嵌入 istio 后 bookinfo 的每个微服务都会新增一个 Envoy，这个 Envoy 就是所谓的  sidecar，它会接管跟它配对的微服务的所有网络进、出口流量。其实  Envoy（sidecar）的作用就像你的手机，它正在逐渐把你变成哑巴、聋子和植物人，它承接了你所有的信息入口和出口，某些别有用心的人和组织通过对手机进行监控、遥测、路由等控制，起到控制你的思维、舆论导向、审美爱好等目的。</p><hr><h2 id="3-bookinfo-配置与部署"><a href="#3-bookinfo-配置与部署" class="headerlink" title="3 bookinfo 配置与部署"></a>3 bookinfo 配置与部署</h2><h3 id="3-1-配置-istio-自动注入"><a href="#3-1-配置-istio-自动注入" class="headerlink" title="3.1 配置 istio 自动注入"></a>3.1 配置 istio 自动注入</h3><p>​    因为 bookinfo 会启动多个 pod，每次手动注入 sidecar 会特别繁琐，因此我们使用批注入的方式。如果你对 sidecar 注入不了解，请参考本人的<a href="https://blog.51cto.com/14625168/2474271"> 上篇</a>博客。</p><blockquote><p>kubectl create ns jiuxi    # 创建 jiuxi 命名空间</p><p>kubectl label ns jiuxi istio-injection=enabled</p><p>kubectl get ns jiuxi –show-labels</p></blockquote><p>​    命令操作成功后截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164338022.png" srcset="/img/loading.gif" lazyload alt="image-20210911164338022"></p><h3 id="3-2-部署-bookinfo-应用"><a href="#3-2-部署-bookinfo-应用" class="headerlink" title="3.2 部署 bookinfo 应用"></a>3.2 部署 bookinfo 应用</h3><p>​    在命名空间 jiuxi 中部署了 bookinfo 应用：</p><blockquote><p>kubectl apply -f bookinfo/platform/kube/bookinfo.yaml -n jiuxi</p></blockquote><p>​    部署过程截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164350324.png" srcset="/img/loading.gif" lazyload alt="image-20210911164350324"></p><p>​    执行如下命令查看 bookinfo 的 service 列表：</p><blockquote><p>kubectl get svc -n jiuxi</p></blockquote><p>​    服务列表截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164402895.png" srcset="/img/loading.gif" lazyload alt="image-20210911164402895"></p><p>​    执行如下命令查看 bookinfo 的 pod 列表：</p><blockquote><p>kubectl get pod -n jiuxi</p></blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164416004.png" srcset="/img/loading.gif" lazyload alt="image-20210911164416004"></p><h3 id="3-3-验证-bookinfo-部署情况"><a href="#3-3-验证-bookinfo-部署情况" class="headerlink" title="3.3 验证 bookinfo 部署情况"></a>3.3 验证 bookinfo 部署情况</h3><p>​    在服务列表中寻找 productpage 服务，然后使用 curl 命令验证服务是否发布成功。</p><blockquote><p>kubectl get svc -n jiuxi</p><p>curl <a href="http://svc_cluster_ip:9080/">http://SVC_CLUSTER_IP:9080</a> | grep -o “<title>.*</title>“</p></blockquote><p>​    执行成功的结果如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164429965.png" srcset="/img/loading.gif" lazyload alt="image-20210911164429965"></p><p>​    自此，整个 bookinfo 应用就已经成功部署了。</p><hr><h2 id="4-设置-bookinfo-网关"><a href="#4-设置-bookinfo-网关" class="headerlink" title="4 设置 bookinfo 网关"></a>4 设置 bookinfo 网关</h2><p>​    上面的步骤已经可以让你访问到 bookinfo 应用了。但是我知道有些同学依旧觉得寒碜，因为很多人还是通过浏览器来看世界的。</p><p>​    网关就相当于你房子的大门，每当你饥肠辘辘回到家，你可以通过全开、半开、开一条缝等动作控制隔壁大妈家饭菜的饭菜香味。后续课程会专门介绍网关更深层次的原理和运用。这里你先有个粗浅的理解就可以了。</p><h3 id="4-1-定义-bookinfo-入口网关"><a href="#4-1-定义-bookinfo-入口网关" class="headerlink" title="4.1 定义 bookinfo 入口网关"></a>4.1 定义 bookinfo 入口网关</h3><blockquote><p>kubectl apply -f istio-1.4.5/samples/bookinfo/networking/bookinfo-gateway.yaml -n jiuxi</p></blockquote><h3 id="4-2-确认网关已创建"><a href="#4-2-确认网关已创建" class="headerlink" title="4.2 确认网关已创建"></a>4.2 确认网关已创建</h3><blockquote><p>kubectl get gateways.networking.istio.io -n jiuxi</p></blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164445960.png" srcset="/img/loading.gif" lazyload alt="image-20210911164445960"></p><hr><h2 id="5-访问-bookinfo-应用"><a href="#5-访问-bookinfo-应用" class="headerlink" title="5 访问 bookinfo 应用"></a>5 访问 bookinfo 应用</h2><h3 id="5-1-获取-INGRESS-HOST"><a href="#5-1-获取-INGRESS-HOST" class="headerlink" title="5.1 获取 INGRESS_HOST"></a>5.1 获取 INGRESS_HOST</h3><blockquote><p>kubectl get po -l istio=ingressgateway -n istio-system -o jsonpath=’{.items[0].status.hostIP}’</p></blockquote><h3 id="5-2-获取-INGRESS-PORT"><a href="#5-2-获取-INGRESS-PORT" class="headerlink" title="5.2 获取 INGRESS_PORT"></a>5.2 获取 INGRESS_PORT</h3><blockquote><p>kubectl -n istio-system get service istio-ingressgateway -o jsonpath=’{.spec.ports[?(@.name==”http2”)].nodePort}’</p></blockquote><h3 id="5-3-通过浏览器访问-bookinfo-应用"><a href="#5-3-通过浏览器访问-bookinfo-应用" class="headerlink" title="5.3 通过浏览器访问 bookinfo 应用"></a>5.3 通过浏览器访问 bookinfo 应用</h3><p>​    根据 5.1 和 5.2 获取到 host 和 port 信息，如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164506614.png" srcset="/img/loading.gif" lazyload alt="image-20210911164506614"></p><p>​    根据此 host 和 port，打开浏览器进行访问：</p><p>​    多刷新几次页面，你会发现 bookinfo 应用使用到的多个 reviews 版本，如下所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164538736.png" srcset="/img/loading.gif" lazyload alt="image-20210911164538736"></p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164551497.png" srcset="/img/loading.gif" lazyload alt="image-20210911164551497"></p><p>​    正好可以对应到 pod 信息：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164605008.png" srcset="/img/loading.gif" lazyload alt="image-20210911164605009"></p><hr><h2 id="6-卸载-bookinfo-应用"><a href="#6-卸载-bookinfo-应用" class="headerlink" title="6 卸载 bookinfo 应用"></a>6 卸载 bookinfo 应用</h2><p>​    你已经创建了 bookinfo，有了创建的快感。也许你有点怅然若失，因为你觉得你的技术人生不够圆满，你想亲身完爆你创建的一切，那么还等什么，执行下面的语句吧：</p><blockquote><p>./istio-1.4.5/samples/bookinfo/platform/kube/cleanup.sh</p></blockquote><p>​    命令执行成功后，会显示如下截图：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164619983.png" srcset="/img/loading.gif" lazyload alt="image-20210911164619983"></p><h3 id="6-1-验证卸载"><a href="#6-1-验证卸载" class="headerlink" title="6.1 验证卸载"></a>6.1 验证卸载</h3><p>​    执行如下命令验证你是否成功卸载：</p><blockquote><p>kubectl get virtualservices.networking.istio.io -n jiuxi</p><p>kubectl get destinationrules.networking.istio.io -n jiuxi</p><p>kubectl get gateways.networking.istio.io -n jiuxi</p><p>kubectl get pod -n jiuxi</p></blockquote><p>​    但是假如你觉得破坏的感觉很爽，就像嚼了炫迈一下停不下来，你可以执行如下作死命令：</p><blockquote><p>rm -rf /   # 你要是真敢这么做，我就崇拜你</p></blockquote><hr><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h2><p>​    自此，九析已经带你轻松完爆了 Bookinfo 应用。相信在操作的过程中，你还有很多不理解的地方，但是没关系，后续九析会为你庖丁解牛的。你需要做的，就是跟着九析操作一遍，熟悉一下整个流程，后续某天你一定会在某个瞬间大声尖叫：“我得到了”。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆服务网格 - istio 初探</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC-istio-%E5%88%9D%E6%8E%A2/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC-istio-%E5%88%9D%E6%8E%A2/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 istio 初探</p><p>  2.1 手动注入 sidecar</p><p>  2.2 自动注入 sidecar</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    如果你对博客有任何疑问，请加微信沟通：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584496625204864.png" srcset="/img/loading.gif" lazyload alt="第二章 九析带你轻松完爆服务网格 - istio 初探_服务网格"></p><p>​    你可以从下面截图中获取免费的、更生动的视频资料，在 b 站搜索“九析”：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584496646484217.png" srcset="/img/loading.gif" lazyload alt="第二章 九析带你轻松完爆服务网格 - istio 初探_服务网格_02"></p><hr><h2 id="2-istio-初探"><a href="#2-istio-初探" class="headerlink" title="2 istio 初探"></a>2 istio 初探</h2><p>​    上节九析带你轻松完爆了 istio 的安装。但是我相信安装成功的小伙伴依然云里雾里，因为看着一大坨 pod 在那里 running  着，似乎并没有产生任何作用。这节，九析就带你“莫畏浮云遮望眼，守得云开见月明”。为了预期效果，我们不妨先建立一个  deployment，内容如下：</p><blockquote><p>apiVersion: apps/v1</p><p>kind: Deployment</p><p>metadata:</p><p>  name: nginx</p><p>  labels:</p><p>​    app: nginx</p><p>spec:</p><p>  replicas: 1</p><p>  selector:</p><p>​    matchLabels:</p><p>​      app: nginx</p><p>  template:</p><p>​    metadata:</p><p>​      labels:</p><p>​        app: nginx</p><p>​    spec:</p><p>​      containers:</p><p>​      - name: nginx</p><p>​        image: nginx:1.14-alpine</p><p>​        ports:</p><p>​        - containerPort: 80</p></blockquote><p>​    创建 deployment，当然为了让你能更深刻地记住哥，把哥印在灵魂深处，你需要首先创建一个命名空间：</p><blockquote><p>kubectl create ns jiuxi</p><p>kubectl apply -f nginx-deployment.yaml -n jiuxi</p></blockquote><p>​    命令执行成功后，查询 nginx pod 状态：</p><blockquote><p>kubectl get pods -n jiuxi</p></blockquote><p>​    截图如下：需要注意 ready 这一列，内容为 1/1，表示的含义是 pod 内有一个容器，且该容器运行成功并处于就绪状态。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911163851179.png" srcset="/img/loading.gif" lazyload alt="image-20210911163851179"></p><p>​    下面到了激动人心的时刻了，因为 istio 即将闪亮登场。</p><h3 id="2-1-手动注入-sidecar"><a href="#2-1-手动注入-sidecar" class="headerlink" title="2.1 手动注入 sidecar"></a>2.1 手动注入 sidecar</h3><p>​    执行如下语句：</p><blockquote><p>kube-inject -f nginx-deployment.yaml | kubectl apply  -n jiuxi -f -</p></blockquote><p>​    命令执行结果如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911163908323.png" srcset="/img/loading.gif" lazyload alt="image-20210911163908323"></p><p>​    此时你会发现一个奇怪的现象，nginx-deployment.yaml 并没修改，但是 ready 状态却变成了 2/2。根据上面的解释可知，现在 pod 内有两个容器，且这两个容器都运行成功并处于就绪状态。为什么多了一个容器呢？</p><p>​    查看 pod 的详细信息：</p><blockquote><p>kubectl get pod -n jiuxi nginx-xxxx -o yaml # xxxx 根据自己实际情况填写</p></blockquote><p>​    如果你有类似 rancher 这样的 web 控制台，可以看得更仔细些，如下图所示。如果你还没有安装和配置 rancher，你可以参考哥的轻松完爆 rancher 系列进行安装，放心，容易到爆，容易到你尖叫。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911163928463.png" srcset="/img/loading.gif" lazyload alt="image-20210911163928463"></p><p>​    从上图可知。此时 nginx pod 内部一共有 3 个容器，一个初始化容器 istio-init 已经运行成功并结束了，一个就是 nginx  本尊，另外一个就是本文的主角 istio-proxy 了，它就是 sidecar，作用跟鸡你太美的经纪人的作用差不多，负责跟外部打交道用的。</p><p>​    此时此刻，你已经为 pod 手工织入了 istio。但是这样似乎有点不够爽。因为每建立一个 pod 都撸这么一管，感觉有点累，有没有批量或者更自然的方式呢？</p><h3 id="2-2-命名空间注入-sidecar"><a href="#2-2-命名空间注入-sidecar" class="headerlink" title="2.2 命名空间注入 sidecar"></a>2.2 命名空间注入 sidecar</h3><p>​    现在我们删除掉刚才创建的 nginx：</p><blockquote><p>kubectl delete deployments.apps nginx -n jiuxi</p></blockquote><p>​    执行如下命令在命名空间内实现自动注入 sidecar：</p><blockquote><p>kubectl label namespaces jiuxi istio-injection=enabled</p><p>kubectl get ns jiuxi –show-labels # 查看 label 是否成功创建</p></blockquote><p>​    再次根据 nginx-deployment.yaml 文件创建 nginx deployment：</p><blockquote><p>kubectl apply -f nginx-deployment.yaml -n jiuxi</p></blockquote><p>​    创建成功后查看 pod 信息，发现已经自动织入了 sidecar。</p><p>​    自此，本节九析带你轻松完爆了 istio 的手动和自动织入功能。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆服务网格 - istio 安装</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC-istio-%E5%AE%89%E8%A3%85/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC-istio-%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 微服务的历史</p><p>3 istio</p><p>4 istio 使用</p><p>  4.1 下载 istio</p><p>  4.2 安装 istio</p><p>  4.3 配置 istioctl 工具路径</p><p>  4.4 实现 istioctl 自动补全功能</p><p>  4.5 安装学习版 istio</p><p>  4.6 卸载 istio</p><p>5 总结</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    如果你对博客有任何疑问，请加微信沟通：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584453790467569.jpg" srcset="/img/loading.gif" lazyload alt="第一章 九析带你轻松完爆服务网格 - istio 安装_k8s istio"></p><p>​    你可以从下面截图中获取免费的、更生动的视频资料，在 b 站搜索“九析”：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584453854320948.png" srcset="/img/loading.gif" lazyload alt="第一章 九析带你轻松完爆服务网格 - istio 安装_service mesh_02"></p><hr><h2 id="2-微服务的历史"><a href="#2-微服务的历史" class="headerlink" title="2 微服务的历史"></a>2 微服务的历史</h2><p>​    微服务从马丁提出到今天为止，大体上经过了四代。</p><p>​    第一代（1.0  时代）：服务发现阶段。单体服务发展到微服务后，原先的通信方式从进程内函数调用发展到了不同服务器上的不同服务之间的进程调用，这样的架构变化，首先要解决的关键问题就是服务的注册与发现。代表技术便是 dubbo 和 grpc、brpc 框架之争。</p><p>​    第二代（2.0 时代）：当服务发现问题解决了之后，紧接着带来的挑战便是服务治理。何为服务治理，就是除了服务之间通讯之外，还需要更深层次考虑到服务之间调用的失败重试、容错、降级、监控、安全、灰度、流控能问题。</p><p>​    第三代（3.0 时代）：微服务 2.0  时代带来了解决方案的百花齐放，各方你方唱罢，我方登场，相同问题的不同解决方案纷纷亮相，一时间风云际会，好不热闹。比如网关解决方案就有  zuul、gateway；全链路监控就有 pinpoint、zipkin、jaeger  等。各种服务治理的解决方案层出不穷带来了很多的积极作用，但负面影响也随之而来，那便是标准的不统一、维护方式各异。服务治理变成了各种中间件的相互嫁接，服务治理的好坏全靠工程师的技术水平高低。基于此，服务治理的标准化、一致化需求越来越强烈，于是服务网格便应运而生。服务网格的思想便是将服务治理标准化，并统一下沉到基础设施层。就像 50、60  年代的美国，当时帮派林立，不同地盘治理的好坏主要依靠各个帮派屌不屌，但是到了后来政府能力逐渐强大和稳定，很多地下秩序不再依靠黑帮，而统一让政府规则化一样的道理。</p><p>​    第四代（4.0 时代）：无服务时代，即 serveless 时代，说的时髦点就是去中心化时代。这个目前还并不成熟，本文先略去不谈。</p><hr><h2 id="3-istio"><a href="#3-istio" class="headerlink" title="3 istio"></a>3 istio</h2><p>​    istio 就是微服务 3.0 时代的产物，是 service mesh 的代表性产品。由谷歌和 IBM 联手打造。借助谷歌的拳头产品  k8s，顷刻完爆众神。istio 跟 k8s 之间到底什么关系？你可以这么来理解，k8s 相当于王健林，istio  相当于王思聪。怎么说呢？k8s 负责打地基，打造基础设施，istio  负责在地基之上整合各种服务模式。大家都知道有个女的去万达影院看电影抱怨爆米花少，结果王思聪承诺给她终生免费提供爆米花的事吧。这就相当于请求失败并重试成功的典型服务治理案例。</p><p>​    istio 包括如下特性：</p><blockquote><p>1 http, gRPC, WebSocket 和 TCP 通信的自动负载均衡</p><p>2 通过丰富的路有规则、重试、故障转移和故障注入对流量行为进行细粒度控制</p><p>3 可插拔的策略层和配置 API，支持访问控制，速率限制和配额</p><p>4 集群内所有流量的自动度量，日志和跟踪，包括集群的入口和出口</p><p>5 通过强大的基于身份和身份验证和授权，在集群中实现安全的服务间通信</p></blockquote><p>​    简单总结便是：istio 负责网络数据包的流量管理（traffic management）、服务的安全保护（secure）、策略（policy，比如黑白名单制定）和可观察（observability，比如监控）。</p><hr><h2 id="4-istio-使用"><a href="#4-istio-使用" class="headerlink" title="4 istio 使用"></a>4 istio 使用</h2><p>​    逼逼完了理论后（其实我最不喜欢就是扯理论），开始进入完爆 istio 环节。</p><h3 id="4-1-下载-istio"><a href="#4-1-下载-istio" class="headerlink" title="4.1 下载 istio"></a>4.1 下载 istio</h3><p>​    在玩 istio 之前，必须要有前置条件，那就是你要先把 k8s 完爆了，你需要首先搭建 k8s 环境。怎么搭建 k8s，你可以参考本人的《<a href="https://blog.51cto.com/14625168/2453827"> 一分钟搭建 k8s 教程</a>》，不用谢。</p><p>​    使用如下语句下载 istio，下载速度会有点慢。至于有多慢？谁试谁知道。而且时不时会断，所以你要时刻关注，如果失败了，需要重新执行。这种感觉就好像你在小便，后面总是有人推你，让你整个过程非常不顺畅，非常不爽。</p><blockquote><p>curl -L <a href="https://istio.io/downloadIstio">https://istio.io/downloadIstio</a> | sh -</p></blockquote><p>​    在下载过程中，如果你遭遇如下错误：</p><blockquote><p>Unable to get latest Istio version. Set ISTIO_VERSION env var and re-run. For example: export ISTIO_VERSION=1.0.4</p></blockquote><p>​    你需要设置一下你要下载的 istio 版本，语句如下：</p><blockquote><p>export ISTIO_VERSION=1.4.5</p></blockquote><p>​    下载成功后的截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911163236926.png" srcset="/img/loading.gif" lazyload alt="image-20210911163236926"></p><h3 id="4-2-安装-istio"><a href="#4-2-安装-istio" class="headerlink" title="4.2 安装 istio"></a>4.2 安装 istio</h3><p>​    安装 istio 前，首先解压缩：</p><blockquote><p>tar -zxvf istio-1.4.5-linux.tar.gz</p></blockquote><p>​    解压缩后的目录结构截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911163255978.png" srcset="/img/loading.gif" lazyload alt="image-20210911163255978"></p><p>​    关键目录说明如下：</p><blockquote><p>install/kubernetes    # istio 资源文件</p><p>samples            # istio 样例</p><p>bin/istioctl        # istio 客户端工具，用来手动注入 envoy</p></blockquote><h3 id="4-3-配置-istioctl-工具路径"><a href="#4-3-配置-istioctl-工具路径" class="headerlink" title="4.3 配置 istioctl 工具路径"></a>4.3 配置 istioctl 工具路径</h3><p>​    istioctl 是 istio 的客户端工具，其作用是手动注入 envoy 作为容器的 sidecar（边车）。什么是 sidecar？你就把它当成鸡你太美的经纪人，懂了没？就是负责跟外界打交道的。配置方式如下：</p><blockquote><p>cd istio-1.4.5</p><p>export PATH=$PATH:$PWD/bin</p></blockquote><p>​    配置完，在 bash 中就可以通过 Tab 键自动补全 istioctl 命令了。但是这样够吗？完美吗？当然不。我们还有更高的要求。</p><p>​    因为 istioctl 有很多配置项，仅仅使用 tab 键只能自动补全 istioctl，但是无法自动补全 istioctl manifest 类似这样的子命令。因此我们需要设置增强自动补全功能。</p><h3 id="4-4-实现-istioctl-自动补全功能"><a href="#4-4-实现-istioctl-自动补全功能" class="headerlink" title="4.4 实现 istioctl 自动补全功能"></a>4.4 实现 istioctl 自动补全功能</h3><p>​    将 istio 安装包内 tools 目录下的 istioctl.bash 文件拷贝到用户根目录下：</p><blockquote><p>cp istio/istio-1.4.5/tools/istioctl.bash ~</p></blockquote><p>​    编辑 ~/.bash_profile 文件，在文件末尾添加如下内容：</p><blockquote><p>source ~/istioctl.bash</p></blockquote><p>​    添加完毕后，加载配置使配置生效：</p><blockquote><p>source ~/.bash_profile</p></blockquote><p>​    然后输入 istioctl 然后按两次 tab 键，发现增强自动补全功能已经生效：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911163319451.png" srcset="/img/loading.gif" lazyload alt="image-20210911163319451"></p><h3 id="4-5-安装学习版-istio"><a href="#4-5-安装学习版-istio" class="headerlink" title="4.5 安装学习版 istio"></a>4.5 安装学习版 istio</h3><p>​    为了降低学习成本，我们选择安装学习版本的 istio。如果你想直接在生产环境安装 istio，可以参考我后续的章节。</p><p>​    执行如下语句安装 istio 学习版：</p><blockquote><p>istioctl manifest apply –set profile=demo</p></blockquote><p>​    安装后的截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911163332691.png" srcset="/img/loading.gif" lazyload alt="image-20210911163332691"></p><p>​    不要一看到 Installation complete 就高兴到尖叫！因为安装完毕不报错并不意味着你就成功了，就像你看到一个美丽、性感、火辣、清纯、高贵、华丽集一身的女人向你走过来时就以为人家觉得你长得帅想泡你一样的道理。</p><p>​    使用如下命令查看一下 istio 的服务状态：</p><blockquote><p>kubectl get svc -n istio-system</p></blockquote><p>​    执行结果如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911163351397.png" srcset="/img/loading.gif" lazyload alt="image-20210911163351397"></p><p>​    服务使用 LoadBalancer 类型一般是在第三方云厂商支持下才有用。如果你是在自己搭建的 k8s 集群环境下一般使用 NodePort 类型。执行如下语句完爆：</p><blockquote><p>kubectl patch svc -n istio-system istio-ingressgateway -p ‘{“spec”: {“type”: “NodePort”}}’</p></blockquote><p>​    执行完毕后，再次查看 svc，发现原来的 LoadBalancer 类型已经被修改为 NodePort 类型，此外 external-ip 也从 pending 状态变成了 <none>(即：不需要)状态。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911163422494.png" srcset="/img/loading.gif" lazyload alt="image-20210911163422494"></p><p>​    查看 istio 的 pod 运行状态：</p><blockquote><p>kubectl get pod -n istio-system</p></blockquote><p>​    运行状态截图如下，所有 pod 状态都是 running 状态：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911163442809.png" srcset="/img/loading.gif" lazyload alt="image-20210911163442809"></p><p>​    自此，整个 istio 环境就被你轻松完爆了。现在你可以停下来，上厕所，喝水和尖叫了。</p><h3 id="4-6-卸载-istio"><a href="#4-6-卸载-istio" class="headerlink" title="4.6 卸载 istio"></a>4.6 卸载 istio</h3><p>​    但是假如你觉得不够爽，光有建立的快感，没有破坏的快感总是觉得技术人生不够圆满的话，你可以执行如下语句轻松完爆 istio。</p><blockquote><p>istioctl manifest generate –set profile=demo | kubectl delete -f -</p></blockquote><hr><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>​    好了，一切都回到了原点。这种感觉像极了你拥有了一个女人，然后蹂躏了一番后，又抛弃她的感觉。但是望着消失了一切后的黑乎乎的屏幕后，你或许点燃了一颗烟，问问自己，抛弃的感觉是否真的快乐？如果没有，你就把文章拉倒起点，再来一遍吧。也许当你操作完后，你会重新追回你深爱的她。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松升级 linux kernel</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%8D%87%E7%BA%A7-linux-kernel/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%8D%87%E7%BA%A7-linux-kernel/</url>
    
    <content type="html"><![CDATA[<p>1 为什么要升级内核</p><p>2 内核版本查看</p><p>3 自动升级</p><p>4 手动升级</p><p>  4.1 下载安装包</p><p>  4.2 解压缩安装包</p><p>  4.3 编译安装</p><p>  4.4 重启</p><p>5 后记</p><p>  5.1 安装 elrepo yum 源</p><p>  5.2 查看内核包</p><p>  5.3 升级内核</p><p>  5.4 修改内核启动顺序</p><p>  5.5 重启</p><hr><h2 id="1-为什么要升级内核"><a href="#1-为什么要升级内核" class="headerlink" title="1 为什么要升级内核"></a>1 为什么要升级内核</h2><p>&emsp;&emsp;为了满足不断增长的物质和精神需要。科技发展日新月异，技术升级一日千里。新的软件、硬件被研发出来，内核为了兼容各种需求不停发展。</p><p>&emsp;&emsp;首先解释一下内核和发行版的区别。内核是操作系统的魂，用来操作和管理计算机的软硬件。主要提供网络协议栈、内存管理、磁盘管理、文件系统、中断处理、进程管理等功能。</p><p>&emsp;&emsp;但是内核对用户而言是不友好的，因为它太专业。对于用户而言，他们需要享受的是实实在在的服务。比如有些男人就是迷恋日本电影，它管你内核不内核，他就需要播放器，但是播放器这东西不能塞到内核。怎么办呢？于是就有好事者盘载以入，在内核之上配置一些软件、工具包、应用程序等组成一个软件包供人使用。因为每个人的口味不一样，所以对软件的选择也不一样，渐渐地就发展成了不同的软件包，这个软件包我们就称为操作系统的发行版。</p><hr><h2 id="2-内核版本查看"><a href="#2-内核版本查看" class="headerlink" title="2 内核版本查看"></a>2 内核版本查看</h2><blockquote><p>uname -r</p></blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911153702098.png" srcset="/img/loading.gif" lazyload alt="image-20210911153702098"></p><hr><h2 id="3-自动升级"><a href="#3-自动升级" class="headerlink" title="3 自动升级"></a>3 自动升级</h2><blockquote><p>yum install -y kernel</p></blockquote><p>&emsp;&emsp;使用 yum 升级内核是相对而言最安全的升级方式了，因为是经过发行版厂商验证过的版本。一般情况下，它并不是最新的，但却是最稳定的。</p><hr><h2 id="4-手动升级"><a href="#4-手动升级" class="headerlink" title="4 手动升级"></a>4 手动升级</h2><p>&emsp;&emsp;手动升级是一件比较刺激的事情。首先到 linux 内核网站膜拜一下上帝。点击<a href="https://www.kernel.org/"> 网址</a>查看：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/spacer.gif" srcset="/img/loading.gif" lazyload alt="第一章 九析带你轻松升级 linux kernel_运维_02"><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911153728956.png" srcset="/img/loading.gif" lazyload alt="image-20210911153728956"></p><p>&emsp;&emsp;看到没，多质朴，绝对不会亲近你，要多土就多土。我就喜欢这样的土。那个时代就是这样。想当年为了上个网，晚上趁着爹妈都睡着了偷偷摸摸爬起来把猫连上电话线，听到类似摩尔密码的滴滴声响起，心里那个激动啊，就跟当今小骚妹看到李佳琦一样一样的。</p><h3 id="4-1-下载安装包"><a href="#4-1-下载安装包" class="headerlink" title="4.1 下载安装包"></a>4.1 下载安装包</h3><p>&emsp;&emsp;下载网址：<a href="https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/"> https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/</a>。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911153808360.png" srcset="/img/loading.gif" lazyload alt="image-20210911153808360"></p><h3 id="4-2-解压缩安装包"><a href="#4-2-解压缩安装包" class="headerlink" title="4.2 解压缩安装包"></a>4.2 解压缩安装包</h3><blockquote><p>tar -zxvf linux-4.14.tar.gz</p></blockquote><h3 id="4-3-编译安装"><a href="#4-3-编译安装" class="headerlink" title="4.3 编译安装"></a>4.3 编译安装</h3><blockquote><p>yum install -y gcc bc openssl-devel perl </p><p>make mrproper         # 删除编译生成的文件，包括内核配置文件和各种配置文件，一般只有在第一次执行内核编译前才使用这条命令</p><p>make oldconfig         # 使用原有的内核配置。执行过程中需要交互，一路回车即可</p><p>make             # 编译源码。所有执行操作中最耗时的部分。你可以睡个午觉</p><p>make modules_install    # 将编译出的内核模块复制到 /lib/modules</p><p>make install        # make是编译；make install 安装到指定位置(/boot)</p></blockquote><h3 id="4-4-重启"><a href="#4-4-重启" class="headerlink" title="4.4 重启"></a>4.4 重启</h3><p>&emsp;&emsp;重启后在 grub 中选择 4.14 版本。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911153835264.png" srcset="/img/loading.gif" lazyload alt="image-20210911153835264"></p><p>&emsp;&emsp;启动成功后，再次查看内核版本，发现已经轻松完爆：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911153852122.png" srcset="/img/loading.gif" lazyload alt="image-20210911153852122"></p><hr><h2 id="5-后记"><a href="#5-后记" class="headerlink" title="5 后记"></a>5 后记</h2><p>&emsp;&emsp;当然为了偷懒可以采用在线升级的方式。升级步骤如下：</p><h3 id="5-1-安装-elrepo-yum-源"><a href="#5-1-安装-elrepo-yum-源" class="headerlink" title="5.1 安装 elrepo yum 源"></a>5.1 安装 elrepo yum 源</h3><p>&emsp;&emsp;elrepo 是 CentOS 稳定的软件源，通过它，可以很容易将内核升级到指定版本。 elrepo 项目网址请<a href="https://elrepo.org/tiki/tiki-index.php"> 点击</a>：</p><blockquote><p>yum install -y <a href="https://www.elrepo.org/elrepo-release-7.0-4.el7.elrepo.noarch.rpm"> https://www.elrepo.org/elrepo-release-7.0-4.el7.elrepo.noarch.rpm</a></p></blockquote><h3 id="5-2-查看内核包"><a href="#5-2-查看内核包" class="headerlink" title="5.2 查看内核包"></a>5.2 查看内核包</h3><blockquote><p>yum –disablerepo=”*” –enablerepo=”elrepo-kernel” list available</p></blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911153911399.png" srcset="/img/loading.gif" lazyload alt="image-20210911153911399"></p><h3 id="5-3-升级内核"><a href="#5-3-升级内核" class="headerlink" title="5.3 升级内核"></a>5.3 升级内核</h3><p>&emsp;&emsp;在 elrepo 源中有 ml 和 lt 两种内核。ml（mainline）为最新版本的内核，lt 为长期支持的内核。这里选择 ml 内核。</p><blockquote><p>yum –enablerepo=elrepo-kernel -y install kernel-ml</p></blockquote><h3 id="5-4-修改内核启动顺序"><a href="#5-4-修改内核启动顺序" class="headerlink" title="5.4 修改内核启动顺序"></a>5.4 修改内核启动顺序</h3><p>&emsp;&emsp;修改 /etc/default/grub 文件，将 GRUB_DEFAULT 改为 0：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911153928164.png" srcset="/img/loading.gif" lazyload alt="image-20210911153928164"></p><p>&emsp;&emsp;编辑完后，执行如下命令让配置生效：</p><blockquote><p>grub2-mkconfig -o /boot/grub2/grub.cfg</p></blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911153942984.png" srcset="/img/loading.gif" lazyload alt="image-20210911153942984"></p><h3 id="5-5-重启系统"><a href="#5-5-重启系统" class="headerlink" title="5.5 重启系统"></a>5.5 重启系统</h3><blockquote><p>reboot</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>client-go 系列之三《go k8s 访问》</title>
    <link href="/2021/09/06/k8s%E5%BC%80%E5%8F%91%E4%B9%8Bclient-go%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%89%E3%80%8AGO-K8S-%E8%AE%BF%E9%97%AE%E3%80%8B/"/>
    <url>/2021/09/06/k8s%E5%BC%80%E5%8F%91%E4%B9%8Bclient-go%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%89%E3%80%8AGO-K8S-%E8%AE%BF%E9%97%AE%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>&emsp;&emsp;上节介绍了 GO 项目开发的配置，本小节会利用 client-go 库实际编写一个访问 K8S 的样例。</p><h1 id="2-运行环境"><a href="#2-运行环境" class="headerlink" title="2 运行环境"></a>2 运行环境</h1><p>&emsp;&emsp;本系列文章使用的环境配置如下（不要求读者完全匹配，可根据自己实际情况酌情处理）：</p><ul><li>K8s        版本 :  <strong>1.19.0</strong></li><li>Docker  版本：<strong>20.10.8</strong></li><li>CentOS 版本：<strong>7.7.1908</strong></li><li>Go SDK 版本：<strong>go1.16.6 linux/amd64</strong></li></ul><h1 id="3-项目代码"><a href="#3-项目代码" class="headerlink" title="3 项目代码"></a>3 项目代码</h1><p>&emsp;&emsp;进入 GO 项目的根目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">cd</span> <span class="hljs-variable">$GOPATH</span>/src</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;新建 k8s-visitor 项目目录，并在该目录下创建 main.go 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> mkdir k8s-visitor</span><br><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">cd</span> k8s-visitor</span><br><span class="hljs-meta">#</span><span class="bash"> touch main.go</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;编辑 main.go 文件，添加如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;io/ioutil&quot;</span><br><br>    core_v1 <span class="hljs-string">&quot;k8s.io/api/core/v1&quot;</span><br>    meta_v1 <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/client-go/kubernetes&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/client-go/rest&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/client-go/tools/clientcmd&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> (<br>        err          error<br>        kubeconfig   []<span class="hljs-keyword">byte</span><br>        clientconfig *rest.Config<br>        clientset    *kubernetes.Clientset<br>        pods       *core_v1.PodList<br>    )   <br><br>    <span class="hljs-keyword">if</span> kubeconfig, err = ioutil.ReadFile(<span class="hljs-string">&quot;/root/.kube/config&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;   <br><br>    <span class="hljs-keyword">if</span> clientconfig, err = clientcmd.RESTConfigFromKubeConfig(kubeconfig); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;   <br><br>    <span class="hljs-keyword">if</span> clientset, err = kubernetes.NewForConfig(clientconfig); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;   <br><br>    <span class="hljs-keyword">if</span> pods, err = clientset.CoreV1().Pods(<span class="hljs-string">&quot;default&quot;</span>).List(context.TODO(), meta_v1.ListOptions&#123;&#125;); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br><br>    fmt.Println(pods)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-运行项目"><a href="#4-运行项目" class="headerlink" title="4 运行项目"></a>4 运行项目</h1><p>&emsp;&emsp;如果想运行成功上面的代码样例，需执行如下两个步骤：</p><ul><li>创建 go.mod</li><li>运行 main.go</li></ul><h2 id="4-1-创建-go-mod"><a href="#4-1-创建-go-mod" class="headerlink" title="4.1 创建 go.mod"></a>4.1 创建 go.mod</h2><p>&emsp;&emsp;go mod 在 GO v1.11 版本引入，在 v1.12 版本基本稳定，到 v1.13 版本的时候默认是打开的，可以使用如下命令查看：        </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@k8s-master-1 k8s-visitor]# go env | grep -i GO111MODULE<br>GO111MODULE=&quot;on&quot;<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;执行下列命令创建 go.mod 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@k8s-master-1 k8s-visitor]# go mod init<br>go: creating new go.mod: module k8s-visitor<br>go: to add module requirements and sums:<br>go mod tidy<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;如果执行结果如上所示，继续执行下面指令（备注，如果指令执行失败，很大概率是依赖包下不到，可参考本系列第一篇文章配置好下载包代理）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@k8s-master-1 k8s-visitor]# go mod tidy<br>go: finding module for package k8s.io/client-go/tools/clientcmd<br>go: finding module for package k8s.io/client-go/kubernetes<br>go: finding module for package k8s.io/client-go/rest<br>go: finding module for package k8s.io/api/core/v1<br>go: finding module for package k8s.io/apimachinery/pkg/apis/meta/v1<br>go: found k8s.io/api/core/v1 in k8s.io/api v0.22.1<br>go: found k8s.io/apimachinery/pkg/apis/meta/v1 in k8s.io/apimachinery v0.22.1<br>go: found k8s.io/client-go/kubernetes in k8s.io/client-go v0.22.1<br>go: found k8s.io/client-go/rest in k8s.io/client-go v0.22.1<br>go: found k8s.io/client-go/tools/clientcmd in k8s.io/client-go v0.22.1<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;执行完毕后， $GOPATH/src/k8s-visitor 目录结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@k8s-master-1 k8s-visitor]# tree<br>.<br>├── go.mod<br>├── go.sum<br>└── main.go<br><br>0 directories, 3 files<br></code></pre></td></tr></table></figure><h2 id="4-2-运行-main-go"><a href="#4-2-运行-main-go" class="headerlink" title="4.2 运行 main.go"></a>4.2 运行 main.go</h2><p>&emsp;&emsp;运行 main.go：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">[root@k8s-master<span class="hljs-number">-1</span> k8s-visitor]# <span class="hljs-keyword">go</span> run main.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;如果读者输出的结果是 k8s default 命名空间下的 pod 列表信息则表示程序执行成功。下图是笔者的运行结果，仅供参考：</p><p><img src="/img/20210907213207.jpg" srcset="/img/loading.gif" lazyload alt="K8S POD 列表明细"></p><p>&emsp;&emsp;自此，第一个 client-go 程序编写完毕并运行成功。</p><h2 id="4-3-源码解释"><a href="#4-3-源码解释" class="headerlink" title="4.3 源码解释"></a>4.3 源码解释</h2><p>&emsp;&emsp;下面简单介绍程序代码逻辑。</p><h3 id="4-3-1-读取-K8S-配置"><a href="#4-3-1-读取-K8S-配置" class="headerlink" title="4.3.1 读取 K8S 配置"></a>4.3.1 读取 K8S 配置</h3><p>&emsp;&emsp;client-go 需要连接配置才可以访问到 K8S，比如 IP、Port、CA 或 token 等。K8S 默认将连接配置存放在 master 节点的 ~/.kube/config 文件中，比如笔者配置如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell">apiVersion: v1<br>clusters:<br>- cluster:<br>    certificate-authority: /etc/kubernetes/pki/ca.crt<br>    server: https://10.110.101.109:6443<br>  name: default<br>- cluster:<br>    certificate-authority: /etc/kubernetes/pki/ca.crt<br>    server: https://10.110.101.109:6443<br>  name: k8s-cluster<br>contexts:<br>- context:<br>    cluster: default<br>    user: admin<br>  name: default<br>- context:<br>    cluster: k8s-cluster<br>    namespace: jiuxi<br>    user: admin<br>  name: k8s-context<br>current-context: default<br>kind: Config<br>preferences: &#123;&#125;<br>users:<br>- name: admin<br>  user:<br>    client-certificate: /etc/kubernetes/pki/client.crt<br>    client-key: /etc/kubernetes/pki/client.key<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;下列代码读取上面 config 配置文件，保存在 kubeconfig 切片中，如果读者 K8S 默认配置文件地址（/root/.kube/config）与笔者不同，请根据实际情况进行修改。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> kubeconfig, err = ioutil.ReadFile(<span class="hljs-string">&quot;/root/.kube/config&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-built_in">panic</span>(err)<br>&#125;  <br></code></pre></td></tr></table></figure><h2 id="4-3-2-创建客户端配置对象"><a href="#4-3-2-创建客户端配置对象" class="headerlink" title="4.3.2 创建客户端配置对象"></a>4.3.2 创建客户端配置对象</h2><p>&emsp;&emsp;下列代码将上面创建的 kubeconfig 切片转化为客户端配置对象，读者如果觉得费解，可以简单理解为单纯的数据类型转换，即：从切片转化为对象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> clientconfig, err = clientcmd.RESTConfigFromKubeConfig(kubeconfig); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-built_in">panic</span>(err)<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="4-3-3-创建客户端访问对象"><a href="#4-3-3-创建客户端访问对象" class="headerlink" title="4.3.3 创建客户端访问对象"></a>4.3.3 创建客户端访问对象</h2><p>&emsp;&emsp;下列代码根据上面创建的配置对象（clientconfig）生成客户端访问对象（clientset），clientset 是 client-go 针对 K8S 每种内置资源（比如：Pod，Deployment）封装的客户端访问对象，该对象内部封装资源操作的 API（比如 delete、create、apply），读者可直接拿来使用，不用自己创造轮子。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> clientset, err = kubernetes.NewForConfig(clientconfig); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-built_in">panic</span>(err)<br>&#125;   <br></code></pre></td></tr></table></figure><h2 id="4-3-4-访问-K8S-获取-Pod-列表"><a href="#4-3-4-访问-K8S-获取-Pod-列表" class="headerlink" title="4.3.4 访问 K8S 获取 Pod 列表"></a>4.3.4 访问 K8S 获取 Pod 列表</h2><p>&emsp;&emsp;下列代码利用 clientset API 获取 K8S default 命名空间下的 Pod 列表。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> pods, err = clientset.CoreV1().Pods(<span class="hljs-string">&quot;default&quot;</span>).List(context.TODO(), meta_v1.ListOptions&#123;&#125;); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-built_in">panic</span>(err)<br>&#125; <br></code></pre></td></tr></table></figure><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h1><p>&emsp;&emsp;本节给出了一个实际样例介绍如何使用 client-go 连接 K8S，这是项目开发的基础，后续所有项目将基于此开发，请大家认真体会。</p>]]></content>
    
    
    <categories>
      
      <category>client-go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>client-go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>client-go 系列之二《go 项目设置》</title>
    <link href="/2021/08/28/k8s%E5%BC%80%E5%8F%91%E4%B9%8Bclient-go%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E3%80%8AGO-%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE%E3%80%8B/"/>
    <url>/2021/08/28/k8s%E5%BC%80%E5%8F%91%E4%B9%8Bclient-go%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E3%80%8AGO-%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>&emsp;&emsp;上节介绍了 client-go 和 GO SDK 安装，本小节将介绍 GO 项目配置，并给出一个 GO 项目实例。</p><h1 id="2-运行环境"><a href="#2-运行环境" class="headerlink" title="2 运行环境"></a>2 运行环境</h1><p>&emsp;&emsp;本系列文章使用的环境配置如下（不要求读者完全匹配，可根据自己实际情况酌情处理）：</p><ul><li>K8s        版本 :  <strong>1.19.0</strong></li><li>Docker  版本：<strong>20.10.8</strong></li><li>CentOS 版本：<strong>7.7.1908</strong></li><li>Go SDK 版本：<strong>go1.16.6 linux/amd64</strong></li></ul><h1 id="3-项目设置"><a href="#3-项目设置" class="headerlink" title="3 项目设置"></a>3 项目设置</h1><p>&emsp;&emsp;进行 GO 项目开发一般需要两个步骤：</p><ul><li><p>创建项目根目录</p></li><li><p>设置 GOPATH</p></li></ul><h2 id="3-1-创建项目根目录"><a href="#3-1-创建项目根目录" class="headerlink" title="3.1 创建项目根目录"></a>3.1 创建项目根目录</h2><p>&emsp;&emsp;好的目录结构往往是项目成功的开始，执行下列命令创建项目根目录，以后所有 GO 项目开发都统一在此根目录之下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> /root/go 是项目的根目录</span><br>[root@jiuxi ~]# mkdir -p /root/go<br>[root@jiuxi ~]# mkdir -p /root/go/bin /root/go/src /root/go/pkg<br>[root@jiuxi ~]# tree /root/go<br>/root/go<br>├── bin<br>├── pkg<br>└── src<br><br>3 directories, 0 files<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;目录结构说明如下：</p><blockquote><p>bin: go 二进制可执行程序的存放路径，比如通过 go install 生成的代码</p><p>pkg: 项目开发过程中，三方依赖库的存放路径</p><p>src: 项目源码存放路径，一般我们编写的项目代码都放在此处</p></blockquote><h2 id="3-2-设置-GOPATH"><a href="#3-2-设置-GOPATH" class="headerlink" title="3.2 设置 GOPATH"></a>3.2 设置 GOPATH</h2><p>&emsp;&emsp;GO SDK 需要设置 GOROOT 环境变量，用来存储 GO SDK 的安装路径。</p><p>&emsp;&emsp;GO 项目开发需要设置 GOPATH 环境变量，用来存储 GO 项目的根目录。</p><p>&emsp;&emsp;编辑 /etc/profile 文件，在文件末尾添加如下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export GOPATH=/root/go<br>export PATH=$PATH:$GOPATH/bin<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;保存文件，然后在命令行执行如下命令使配置生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@jiuxi go]# source /etc/profile<br>[root@jiuxi go]# echo $GOPATH<br>/root/go<br></code></pre></td></tr></table></figure><p>如果执行结果如上所示，说明 GOPATH 设置成功。</p><h1 id="4-项目样例"><a href="#4-项目样例" class="headerlink" title="4 项目样例"></a>4 项目样例</h1><p>&emsp;&emsp;一切都准备就绪，可以写个小项目练练手了。</p><h2 id="4-1-创建项目"><a href="#4-1-创建项目" class="headerlink" title="4.1 创建项目"></a>4.1 创建项目</h2><p>&emsp;&emsp;执行如下命令创建 client-go-quick-start  项目，注意一定要在 $GOPATH/src 路径下创建。        </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@jiuxi go]# cd $GOPATH/src<br>[root@jiuxi src]# mkdir client-go-quick-start<br>[root@jiuxi src]# tree $GOPATH/src<br>/root/go/src<br>└── client-go-quick-start<br><br>1 directory, 0 files<br></code></pre></td></tr></table></figure><h2 id="4-2-编写代码"><a href="#4-2-编写代码" class="headerlink" title="4.2 编写代码"></a>4.2 编写代码</h2><p>&emsp;&emsp;在 client-go-quick-start 目录下创建 main.go 文件，内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println( <span class="hljs-string">&quot;client-go quick start tutorial&quot;</span> )<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-3-运行代码"><a href="#4-3-运行代码" class="headerlink" title="4.3 运行代码"></a>4.3 运行代码</h2><p>&emsp;&emsp;执行下面命令运行 main.go 程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@jiuxi client-go-quick-start]# go run main.go <br>client-go quick start tutorial<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;如果执行结果如上所示，说明程序运行正常，此时读者可以暂时放松一下，泡杯咖啡犒劳一下自己，因为从下节开始我们将正式开启 client-go 操作 K8S 旅程，请调整一下坐姿，我们发车了。</p>]]></content>
    
    
    <categories>
      
      <category>client-go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>client-go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>client-go 系列之一《go sdk 配置》</title>
    <link href="/2021/08/24/k8s%E5%BC%80%E5%8F%91%E4%B9%8Bclient-go%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E3%80%8AGO-SDK-%E8%AE%BE%E7%BD%AE%E3%80%8B/"/>
    <url>/2021/08/24/k8s%E5%BC%80%E5%8F%91%E4%B9%8Bclient-go%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E3%80%8AGO-SDK-%E8%AE%BE%E7%BD%AE%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>&emsp;&emsp;client-go 是官方提供的 go 语言客户端库，可以跟 K8S API Server 进行交互。如果开发者想对 K8S 进行二次开发，可直接拿来使用，不必重复造轮子。</p><p>&emsp;&emsp;client-go 已集成进 K8S 源码，所以 K8S 组件之间也采用 client-go 进行通信（例如 kubectl 操作 API Server）。client-go 在 K8S 源码中存放的路径是 vendor/k8s.io/client-go，如下图所示：</p><p><img src="/img/20210824190058.jpg" srcset="/img/loading.gif" lazyload alt="client-go 在 K8S 源码中的存放路径"></p><p>&emsp;&emsp;本系列文章会全方面介绍 client-go，包括快速上手、架构设计和源码剖析，在源码剖析章节会重点介绍 Informer 机制（此机制是 K8S 组件之间相互通信的基石）。</p><p>&emsp;&emsp;如果想真正学好 K8S，仅仅会操作是远远不够地，只有真实地触摸到代码底层，并实际了解其内部数据结构和运行机制，才能有“不畏浮云遮望眼，自缘身在最高层”的体悟。</p><h1 id="2-前提"><a href="#2-前提" class="headerlink" title="2 前提"></a>2 前提</h1><p>&emsp;&emsp;本系列文章并不要求读者一定具备 go 语言背景，考虑到大多数人的认知习惯，所以笔者采用了一种先易后难、循序渐进、层层铺垫的编写方式，当然如果碰上喜欢挑战、勤于练胆、不撞南墙就浑身不舒坦的读者，本教程依旧适合，您只需要从后往前读即可。</p><p>&emsp;&emsp;尽管本系列文章对读者的水平做到了最大程度的宽容，但如果想真切感受到程序运行带来的快感，建议还是配置 go sdk、go 项目开发环境和 K8S 运行环境。正所谓“<em>九层之台，起于累土；千里之行，始于足下</em>”，个人认为老子的话还是要听一听的。</p><p><img src="/img/20210824.jpg" srcset="/img/loading.gif" lazyload alt="老子与道"></p><h1 id="3-运行环境"><a href="#3-运行环境" class="headerlink" title="3 运行环境"></a>3 运行环境</h1><p>&emsp;&emsp;本系列所采用的环境信息如下（不要求读者完全匹配，可根据实际情况酌情处理，但建议 go sdk 版本不要过低）：</p><ul><li>K8S        版本 :  <strong>1.19.0</strong></li><li>Docker  版本：<strong>20.10.8</strong></li><li>CentOS 版本：<strong>7.7.1908</strong></li><li>GO SDK 版本：<strong>go1.16.6 linux/amd64</strong></li></ul><h1 id="4-GO-SDK-安装"><a href="#4-GO-SDK-安装" class="headerlink" title="4 GO SDK 安装"></a>4 GO SDK 安装</h1><p>&emsp;&emsp;安装步骤如下，如果读者已经安装过，可直接跳到下一章节继续阅读：</p><ul><li><p>下载和解压缩</p></li><li><p>设置环境变量</p></li><li><p>验证是否安装成功</p></li><li><p>配置包下载代理（可选但推荐）</p></li></ul><h2 id="4-1-下载和解压缩"><a href="#4-1-下载和解压缩" class="headerlink" title="4.1 下载和解压缩"></a>4.1 下载和解压缩</h2><p>&emsp;&emsp;在命令行执行如下指令下载和解压缩 GO SDK：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">cd</span> /opt</span> <br><span class="hljs-meta">#</span><span class="bash"> yum install -y wget</span><br><span class="hljs-meta">#</span><span class="bash"> wget https://golang.google.cn/dl/go1.16.6.linux-amd64.tar.gz</span><br><span class="hljs-meta">#</span><span class="bash"> tar -zxvf go1.16.6.linux-amd64.tar.gz -C /usr/<span class="hljs-built_in">local</span></span><br></code></pre></td></tr></table></figure><h2 id="4-2-设置环境变量"><a href="#4-2-设置环境变量" class="headerlink" title="4.2 设置环境变量"></a>4.2 设置环境变量</h2><p>&emsp;&emsp;编辑 /etc/profile 文件，在文件末尾添加下面内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">export GO111MODULE=on<br>export GOROOT=/usr/local/go<br>export PATH=$PATH:$GOROOT/bin<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;编辑保存后，在命令行执行如下语句使上面的配置生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">source</span> /etc/profile</span><br></code></pre></td></tr></table></figure><h2 id="4-3-验证是否安装成功"><a href="#4-3-验证是否安装成功" class="headerlink" title="4.3 验证是否安装成功"></a>4.3 验证是否安装成功</h2><p>&emsp;&emsp;安装完毕并设置好环境变量后，在命令行执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> go version</span><br>go version go1.16.6 linux/amd64<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;如果能正确显示 GO SDK 的版本（如上所示），则说明 SDK 安装成功。</p><h2 id="4-4-配置下载代理（可选但推荐）"><a href="#4-4-配置下载代理（可选但推荐）" class="headerlink" title="4.4 配置下载代理（可选但推荐）"></a>4.4 配置下载代理（可选但推荐）</h2><p>&emsp;&emsp;首先声明该步骤是可选的，但笔者强烈建议执行此步骤，因为在后面开发中会下载很多依赖包，如果采用默认代理，要么可能下载不到（具体原因，你懂的），要么下载速度巨慢，所以建议在命令行执行下面命令修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># GOPROXY=&quot;https://proxy.golang.org,direct&quot;</span></span><br><span class="hljs-meta">#</span><span class="bash"> go env GOPROXY</span><br><span class="hljs-meta">#</span><span class="bash"> go env -w GOPROXY=<span class="hljs-string">&quot;https://goproxy.io,direct&quot;</span></span><br><span class="hljs-meta">#</span><span class="bash"> go env GOPROXY</span><br>https://goproxy.io,direct<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;如果命令执行结果如上所示，表示修改成功，新代理路径已经改成 <a href="https://goproxy.io./">https://goproxy.io。</a></p><p>&emsp;&emsp;自此，整个 GO SDK 设置结束，读者可以进入到后续 GO 开发了。</p><h1 id="5-参考文献"><a href="#5-参考文献" class="headerlink" title="5 参考文献"></a>5 参考文献</h1><p>1 <a href="https://github.com/kubernetes/client-go">client-go 仓库</a> <a href="https://github.com/kubernetes/client-go">https://github.com/kubernetes/client-go</a></p>]]></content>
    
    
    <categories>
      
      <category>client-go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>client-go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式事务系列之二《事务》</title>
    <link href="/2021/08/14/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E3%80%8A%E4%BA%8B%E5%8A%A1%E3%80%8B/"/>
    <url>/2021/08/14/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E3%80%8A%E4%BA%8B%E5%8A%A1%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;上节介绍了单体架构，单体架构是整个漫长软件架构演进过程中使用人数最多、应用范围最广、也相对最稳定的一种架构。但随着业务多变、逻辑复杂性增加、交付时间越来越短，单体架构逐渐显出疲态，慢慢被分布式微服务架构所代替。</p><p>&emsp;&emsp;早期单体架构解决的核心问题是信息化，信息化处理的对象是数据，数据的质量直接影响到信息化的好坏。数据质量的判断有很多维度，其中最重要维度之一便是数据一致性。</p><h1 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h1><p>&emsp;&emsp;单纯的说教容易让人云里雾里，不妨举一个生活的例子。</p><p>&emsp;&emsp;我成长的年代还比较单纯，父母起名一般不会想太多。我至今记得一对男女同桌，女的叫做张开凤，男的叫做王里岛。下面就是他们的故事：</p><blockquote><p><strong>张开凤银行账户有 1000 块， 王里岛银行账户也有 1000 块</strong></p><p><strong>张开凤和王里岛相约进行爱的鼓掌，完事后，王里岛付给张开凤 200 块</strong></p><p><strong>张开凤现在账户里有 1200 块，而王里岛账户有 800 块</strong></p></blockquote><p>&emsp;&emsp;银行交易系统会执行如下语句：</p><blockquote><p><em><strong>update table account set savings = savings - 200 where name = “王里岛”</strong></em></p><p><em><strong>update table account set savings = savings + 200 where name = “张开凤”</strong></em></p></blockquote><p>&emsp;&emsp;如果交易系统执行第一条语句成功了，但在执行第二条语句的时候却失败了，那么张开凤就被白嫖了（但是王里岛是不会承认的，你仔细品一下）。</p><p>&emsp;&emsp;这真是一个悲伤的故事，悲剧的核心就在于数据不一致，碰到这样的事，作为一个有责任心的工程师是绝对不能坐视不理的。经过思考，我们发现该技术场景的痛点在于，如何保证一个事件序列的执行是原子的，即：要么全部执行成功，要么全部失败。</p><p><img src="/img/2021081402.png" srcset="/img/loading.gif" lazyload alt="02"></p><h1 id="事务定义"><a href="#事务定义" class="headerlink" title="事务定义"></a>事务定义</h1><p>&emsp;&emsp;事务想解决的本质问题就是数据状态的一致，有关事务的非官方定义如下：</p><ul><li><p>事务是操作数据源的程序（比如：一个事务可以是一条 SQL 语句，一组 SQL 语句或高级语言写的程序）</p></li><li><p>事务是一个不可分割的工作单元，单元内的操作要么全部执行成功，要么全部执行失败</p></li><li><p>事务是恢复和并发控制的基本单元</p></li></ul><h1 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h1><p>&emsp;&emsp;事务具有四个特征，这是小白面试时常被考的问题，教科书教导的顺序是 ACID（acid 中文翻译：酸）。笔者是个极其蠢笨的人，总是记不住，于是改良成 ICDA（中文翻译：爱操洞啊），就再没忘记过，这里冒死提供给读者，你们不用谢我。</p><blockquote><ul><li>I : isolation      （隔离性）。指一个事务内的事件序列执行时，不能被另外的事务所干扰</li><li>C: consistency（一致性）。指数据状态转换过程中必须是一致性</li><li>D: durability   （持久性）。指一旦事务提交之后，对数据库的改变就是永久的</li><li>A: atomic        （原子性）。指事务内的事件序列执行时是不可分割的，要么全部执行，要么都不执行</li></ul></blockquote><p>&emsp;&emsp;如果上面的学术解释让你昏昏欲睡，你可以换下面一种记法，结合“爱操洞啊”来理解，还是那句话，不用谢。</p><blockquote><ul><li>I : isolation      （隔离性）。I  就是“我”，世界上只有一个我，独一无二。所以本身具备隔离性、排他性</li><li>C: consistency（一致性）。C 就是“操”，操的对象必须一致，否则容易得病（你懂的）</li><li>D: durability   （持久性）。D 就是“洞”，面对洞一定要持久，这样她才会永远记得你（即使分手）</li><li>A: atomic        （原子性）。A  就是”啊“，高潮后发出的满足声音。要做就一定要高潮，否则就别做</li></ul></blockquote><p><img src="/img/2021081403.png" srcset="/img/loading.gif" lazyload alt="03"></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/9744607?fr=aladdin">事务百科</a> <a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/9744607?fr=aladdin">https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/9744607?fr=aladdin</a></li><li><a href="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fhbimg.b0.upaiyun.com%2F5ee7d275ed5f6adea8af216f4ae194ad0da7aa2d1a520-6askWI_fw658&refer=http%3A%2F%2Fhbimg.b0.upaiyun.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1631530265&t=40527bb540fa342f3c6211e57782423c">杜蕾斯图片</a> <a href="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fhbimg.b0.upaiyun.com%2F5ee7d275ed5f6adea8af216f4ae194ad0da7aa2d1a520-6askWI_fw658&amp;refer=http%3A%2F%2Fhbimg.b0.upaiyun.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1631530265&amp;t=40527bb540fa342f3c6211e57782423c">https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fhbimg.b0.upaiyun.com%2F5ee7d275ed5f6adea8af216f4ae194ad0da7aa2d1a520-6askWI_fw658&amp;refer=http%3A%2F%2Fhbimg.b0.upaiyun.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1631530265&amp;t=40527bb540fa342f3c6211e57782423c</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式事务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式事务系列之一《单体架构》</title>
    <link href="/2021/08/14/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E3%80%8A%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E3%80%8B/"/>
    <url>/2021/08/14/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E3%80%8A%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;分布式事务目标是解决数据一致性问题。在整个波澜壮阔的计算机科技发展史上，分布式事务并非一开始就存在，它只是历史发展的产物，随着软、硬件架构的不断更迭和演进才逐步发展起来的。</p><p>&emsp;&emsp;我还记得那是一个夏天，窗外鸟语花香，空气中满是新鲜和幸福的味道。那时路上还没有那么多车，苏堤远没有现在人流如织。在那个还流淌着小资的年代，软件从业者是小众的文艺小清新，也就在那时，我怀揣着改造世界的憧憬，莽撞地踏进了计算机的世界。</p><p>&emsp;&emsp;那时，世界远没有现在复杂，人心还没有那么险恶。我们没有微信、没有抖音、没有996、更没有内卷。我们悠闲地带耳机听着音乐、喝着咖啡。我们充满希望，用代码编织着内心的向往和美丽的梦。</p><p>&emsp;&emsp;那时，我们没有微服务，没有分布式，更没有分布式事务。我们只写单体……</p><p><img src="/img/2021081401.png" srcset="/img/loading.gif" lazyload alt="致敬那消失不再有的文艺时代"></p><h1 id="单体架构定义"><a href="#单体架构定义" class="headerlink" title="单体架构定义"></a>单体架构定义</h1><p>&emsp;&emsp;在网上找了很多的资料，不知道是不是因为单体架构简单到让人忽略的缘故，竟然很难找到官方定义或词条解释。但或许人类的认知都是从定义事物开始，所以我们不得不把搜寻的目光从官方转回到民间找寻答案，于是便有了下面的蹩脚英文定义：</p><blockquote><p><strong>What is a Monolith i.e. a monolithic architecture ?</strong></p><p><em>A monolithic application</em>, let’s call it a <em>Monolith</em>, is an application delivered via a single deployment unit. Examples could be an application delivered as single WAR or a Node application with a single entrypoint.</p></blockquote><p>&emsp;&emsp;翻译过来就是：</p><blockquote><p><strong>什么是单体应用/架构 ？</strong></p><p><em>单体应用（俗称巨石系统），是整体交付、统一部署的一类应用。比如通过 War 或者 node 部署的具有单一访问入口的应用</em></p></blockquote><p>&emsp;&emsp;分析上面非官方的定义，我们可以得出单体架构的特点：原子性。基于单体架构的应用都是原子而不可再分的，无论是交付还是部署，都必须作为一个统一的整体。</p><h1 id="单体架构分层"><a href="#单体架构分层" class="headerlink" title="单体架构分层"></a>单体架构分层</h1><p>&emsp;&emsp;上面我们定义了单体架构，但是通过定义，很容易会让我们产生认知错误，即：单体架构应用是简单的、缺乏层次的、由数据结构和算法堆积起来的、架构不友好的应用。</p><p>&emsp;&emsp;我承认，单体架构早期阶段确实是用血泪书写的。那时项目缺乏规范，从业者缺少指导，开发者又生猛异常。技术处理，多的是血性，少的是敬畏。在那个没有 bug，只有事故的年代，只要你敢乱来，就没有攻不破的系统。在笔者的亲身经历中就有幸经历过几个“生死”瞬间，为了不招惹是非，特隐去公司名。</p><blockquote><p>事故一：因为不合理的修改导致股票系统出问题，结果开发被能征惯战的东北股民问候了家长</p><p>事故二：因为电信出账单计算错误，贵州某地电信用户直接在营业厅上演平民版导火线</p><p>事故三：国内某电商支付公司早期秒杀业务，因为并发控制没控制好，导致手机被疯抢</p></blockquote><p>&emsp;&emsp;即使不出事故和故障，单体架构系统体量也足可以庞大到惊人，从编译到运行往往持续几十分钟，加一个 print 调试逻辑，一根烟都抽完了，结果却跑不出来。写到这里，笔者不禁停下来莞尔，过往经历犹如走马灯般在回忆中被解放。真怀念那个没有流程图、没有章法、信马由缰、涂鸦般的编码年代，一切都是那么“云原生”。每当黑黢黢的控制台颤悠悠显示出 XXX successful 字样时，那种赌徒般、大难不死的幸福感油然而生。</p><p>&emsp;&emsp;历史总是反复，而科技永远向前。技术最不愿放过的就是“痛点”，伴随着解决一个痛点，又生出一堆新的痛点 :-)。</p><p>&emsp;&emsp;工程师们被随心所欲的开发模式搞得苦不堪言，软件大师也被腐败不堪的技术负债搞得斯文扫地。于是大家围炉而坐，痛定思痛反省解决方案。终于，一切尘埃落定，“分层”腾空出世。从业务或职能（视图、控制、模型）等维度对单体应用进行分层，分层后的系统焕然一新，可维护性大幅提高。</p><p>&emsp;&emsp;分层架构模式如下图所示：</p><p><img src="/img/20210823174649.jpg" srcset="/img/loading.gif" lazyload alt="分层架构"></p><p>&emsp;&emsp;这样的分层架构模式一直延续至今，大名鼎鼎的 MVC 架构模式就脱胎于此，即便已经步入微服务时代，它依旧经典，依旧璀璨。</p><h1 id="单体架构部署"><a href="#单体架构部署" class="headerlink" title="单体架构部署"></a>单体架构部署</h1><p>&emsp;&emsp;单体架构应用因为原子性，不得不在单一进程空间，所有模块以及方法调用都不用考虑远程调用和网络。这样的部署、运行和访问方式简单、高效，出错的几率小，但同时也带来了隔离难、内存泄漏以及升级/扩展困难等不足。</p><p>&emsp;&emsp;下图是经典单体架构应用部署图：</p><p><img src="/img/20210823174716.jpg" srcset="/img/loading.gif" lazyload alt="单体架构"></p><h1 id="单体架构优点"><a href="#单体架构优点" class="headerlink" title="单体架构优点"></a>单体架构优点</h1><p>&emsp;&emsp;单体架构应用有很多优点：</p><ul><li>易于开发和调试：IDE（无论是本地还是云端）都天然支持单体架构应用的开发和调试</li><li>易于部署和运行：只需要在支持的运行时（Runtime）上部署交付组件即可（比如 war 包）</li><li>易于横向扩缩容：只需要通过在负载均衡器（比如 Nginx）后增加单体架构应用的多个副本即可</li></ul><h1 id="单体架构不足"><a href="#单体架构不足" class="headerlink" title="单体架构不足"></a>单体架构不足</h1><p>&emsp;&emsp;单体架构应用也有很多不足：</p><ul><li>复杂性高：所有代码在同一代码空间，即使分层，随着时间推移也会变得越来越庞大和复杂</li><li>全量部署：每次功能迭代或缺陷修复都需要部署整个应用。全量部署耗时长、影响范围广、风险高</li><li>隔离性差：整个单体架构应用依赖于相同运行环境。一旦某个模块出错，可能导致整个系统崩溃</li><li>垂直扩缩容成本高：遵从木桶理论。即使只有一个模块性能出现短板，也要求全量扩容</li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://programmerfriend.com/monolith-vs-microservices/">单体和微服务</a> <a href="https://programmerfriend.com/monolith-vs-microservices/">https://programmerfriend.com/monolith-vs-microservices/</a></li><li><a href="http://icyfenix.cn/architecture/architect-history/monolithic.html">凤凰架构</a> <a href="http://icyfenix.cn/architecture/architect-history/monolithic.html">http://icyfenix.cn/architecture/architect-history/monolithic.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式事务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
