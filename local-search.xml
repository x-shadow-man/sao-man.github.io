<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>client-go 系列之二《GO 项目设置》</title>
    <link href="/2021/08/28/k8s%E5%BC%80%E5%8F%91%E4%B9%8Bclient-go%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E3%80%8AGO-%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE%E3%80%8B/"/>
    <url>/2021/08/28/k8s%E5%BC%80%E5%8F%91%E4%B9%8Bclient-go%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E3%80%8AGO-%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>&emsp;&emsp;上节介绍了 client-go 和 GO SDK 安装，本小节将介绍 GO 项目配置，并给出一个 GO 项目实例。</p><h1 id="2-运行环境"><a href="#2-运行环境" class="headerlink" title="2 运行环境"></a>2 运行环境</h1><p>&emsp;&emsp;本系列文章使用的环境配置如下（不要求读者完全匹配，可根据自己实际情况酌情处理）：</p><ul><li>K8s        版本 :  <strong>1.19.0</strong></li><li>Docker  版本：<strong>20.10.8</strong></li><li>CentOS 版本：<strong>7.7.1908</strong></li><li>Go SDK 版本：<strong>go1.16.6 linux/amd64</strong></li></ul><h1 id="3-项目设置"><a href="#3-项目设置" class="headerlink" title="3 项目设置"></a>3 项目设置</h1><p>&emsp;&emsp;进行 GO 项目开发一般需要两个步骤：</p><ul><li><p>创建项目根目录</p></li><li><p>设置 GOPATH</p></li></ul><h2 id="3-1-创建项目根目录"><a href="#3-1-创建项目根目录" class="headerlink" title="3.1 创建项目根目录"></a>3.1 创建项目根目录</h2><p>&emsp;&emsp;好的目录结构往往是项目成功的开始，执行下列命令创建项目根目录，以后所有 GO 项目开发都统一在此根目录之下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> /root/go 是项目的根目录</span><br>[root@jiuxi ~]# mkdir -p /root/go<br>[root@jiuxi ~]# mkdir -p /root/go/bin /root/go/src /root/go/pkg<br>[root@jiuxi ~]# tree /root/go<br>/root/go<br>├── bin<br>├── pkg<br>└── src<br><br>3 directories, 0 files<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;目录结构说明如下：</p><blockquote><p>bin: go 二进制可执行程序的存放路径，比如通过 go install 生成的代码</p><p>pkg: 项目开发过程中，三方依赖库的存放路径</p><p>src: 项目源码存放路径，一般我们编写的项目代码都放在此处</p></blockquote><h2 id="3-2-设置-GOPATH"><a href="#3-2-设置-GOPATH" class="headerlink" title="3.2 设置 GOPATH"></a>3.2 设置 GOPATH</h2><p>&emsp;&emsp;GO SDK 需要设置 GOROOT 环境变量，用来存储 GO SDK 的安装路径。</p><p>&emsp;&emsp;GO 项目开发需要设置 GOPATH 环境变量，用来存储 GO 项目的根目录。</p><p>&emsp;&emsp;编辑 /etc/profile 文件，在文件末尾添加如下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export GOPATH=/root/go<br>export PATH=$PATH:$GOPATH/bin<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;保存文件，然后在命令行执行如下命令使配置生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@jiuxi go]# source /etc/profile<br>[root@jiuxi go]# echo $GOPATH<br>/root/go<br></code></pre></td></tr></table></figure><p>如果执行结果如上所示，说明 GOPATH 设置成功。</p><h1 id="4-项目样例"><a href="#4-项目样例" class="headerlink" title="4 项目样例"></a>4 项目样例</h1><p>&emsp;&emsp;一切都准备就绪，可以写个小项目练练手了。</p><h2 id="4-1-创建项目"><a href="#4-1-创建项目" class="headerlink" title="4.1 创建项目"></a>4.1 创建项目</h2><p>&emsp;&emsp;执行如下命令创建 client-go-quick-start  项目，注意一定要在 $GOPATH/src 路径下创建。        </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@jiuxi go]# cd $GOPATH/src<br>[root@jiuxi src]# mkdir client-go-quick-start<br>[root@jiuxi src]# tree $GOPATH/src<br>/root/go/src<br>└── client-go-quick-start<br><br>1 directory, 0 files<br></code></pre></td></tr></table></figure><h2 id="4-2-编写代码"><a href="#4-2-编写代码" class="headerlink" title="4.2 编写代码"></a>4.2 编写代码</h2><p>&emsp;&emsp;在 client-go-quick-start 目录下创建 main.go 文件，内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println( <span class="hljs-string">&quot;client-go quick start tutorial&quot;</span> )<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-3-运行代码"><a href="#4-3-运行代码" class="headerlink" title="4.3 运行代码"></a>4.3 运行代码</h2><p>&emsp;&emsp;执行下面命令运行 main.go 程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@jiuxi client-go-quick-start]# go run main.go <br>client-go quick start tutorial<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;如果执行结果如上所示，说明程序运行正常，此时读者可以暂时放松一下，泡杯咖啡犒劳一下自己，因为从下节开始我们将正式开启 client-go 操作 K8S 旅程，请调整一下坐姿，我们发车了。</p>]]></content>
    
    
    <categories>
      
      <category>client-go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>client-go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>client-go 系列之一《go sdk 配置》</title>
    <link href="/2021/08/24/k8s%E5%BC%80%E5%8F%91%E4%B9%8Bclient-go%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E3%80%8AGO-SDK-%E8%AE%BE%E7%BD%AE%E3%80%8B/"/>
    <url>/2021/08/24/k8s%E5%BC%80%E5%8F%91%E4%B9%8Bclient-go%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E3%80%8AGO-SDK-%E8%AE%BE%E7%BD%AE%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>&emsp;&emsp;client-go 是官方提供的 go 语言客户端库，可以跟 K8S API Server 进行交互。如果开发者想对 K8S 进行二次开发，可直接拿来使用，不必重复造轮子。</p><p>&emsp;&emsp;client-go 已集成进 K8S 源码，所以 K8S 组件之间也采用 client-go 进行通信（例如 kubectl 操作 API Server）。client-go 在 K8S 源码中存放的路径是 vendor/k8s.io/client-go，如下图所示：</p><p><img src="/img/20210824190058.jpg" srcset="/img/loading.gif" lazyload alt="client-go 在 K8S 源码中的存放路径"></p><p>&emsp;&emsp;本系列文章会全方面介绍 client-go，包括快速上手、架构设计和源码剖析，在源码剖析章节会重点介绍 Informer 机制（此机制是 K8S 组件之间相互通信的基石）。</p><p>&emsp;&emsp;如果想真正学好 K8S，仅仅会操作是远远不够地，只有真实地触摸到代码底层，并实际了解其内部数据结构和运行机制，才能有“不畏浮云遮望眼，自缘身在最高层”的体悟。</p><h1 id="2-前提"><a href="#2-前提" class="headerlink" title="2 前提"></a>2 前提</h1><p>&emsp;&emsp;本系列文章并不要求读者一定具备 go 语言背景，考虑到大多数人的认知习惯，所以笔者采用了一种先易后难、循序渐进、层层铺垫的编写方式，当然如果碰上喜欢挑战、勤于练胆、不撞南墙就浑身不舒坦的读者，本教程依旧适合，您只需要从后往前读即可。</p><p>&emsp;&emsp;尽管本系列文章对读者的水平做到了最大程度的宽容，但如果想真切感受到程序运行带来的快感，建议还是配置 go sdk、go 项目开发环境和 K8S 运行环境。正所谓“<em>九层之台，起于累土；千里之行，始于足下</em>”，个人认为老子的话还是要听一听的。</p><p><img src="/img/20210824.jpg" srcset="/img/loading.gif" lazyload alt="老子与道"></p><h1 id="3-运行环境"><a href="#3-运行环境" class="headerlink" title="3 运行环境"></a>3 运行环境</h1><p>&emsp;&emsp;本系列所采用的环境信息如下（不要求读者完全匹配，可根据实际情况酌情处理，但建议 go sdk 版本不要过低）：</p><ul><li>K8S        版本 :  <strong>1.19.0</strong></li><li>Docker  版本：<strong>20.10.8</strong></li><li>CentOS 版本：<strong>7.7.1908</strong></li><li>GO SDK 版本：<strong>go1.16.6 linux/amd64</strong></li></ul><h1 id="4-GO-SDK-安装"><a href="#4-GO-SDK-安装" class="headerlink" title="4 GO SDK 安装"></a>4 GO SDK 安装</h1><p>&emsp;&emsp;安装步骤如下，如果读者已经安装过，可直接跳到下一章节继续阅读：</p><ul><li><p>下载和解压缩</p></li><li><p>设置环境变量</p></li><li><p>验证是否安装成功</p></li><li><p>配置包下载代理（可选但推荐）</p></li></ul><h2 id="4-1-下载和解压缩"><a href="#4-1-下载和解压缩" class="headerlink" title="4.1 下载和解压缩"></a>4.1 下载和解压缩</h2><p>&emsp;&emsp;在命令行执行如下指令下载和解压缩 GO SDK：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">cd</span> /opt</span> <br><span class="hljs-meta">#</span><span class="bash"> yum install -y wget</span><br><span class="hljs-meta">#</span><span class="bash"> wget https://golang.google.cn/dl/go1.16.6.linux-amd64.tar.gz</span><br><span class="hljs-meta">#</span><span class="bash"> tar -zxvf go1.16.6.linux-amd64.tar.gz -C /usr/<span class="hljs-built_in">local</span></span><br></code></pre></td></tr></table></figure><h2 id="4-2-设置环境变量"><a href="#4-2-设置环境变量" class="headerlink" title="4.2 设置环境变量"></a>4.2 设置环境变量</h2><p>&emsp;&emsp;编辑 /etc/profile 文件，在文件末尾添加下面内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">export GO111MODULE=on<br>export GOROOT=/usr/local/go<br>export PATH=$PATH:$GOROOT/bin<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;编辑保存后，在命令行执行如下语句使上面的配置生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">source</span> /etc/profile</span><br></code></pre></td></tr></table></figure><h2 id="4-3-验证是否安装成功"><a href="#4-3-验证是否安装成功" class="headerlink" title="4.3 验证是否安装成功"></a>4.3 验证是否安装成功</h2><p>&emsp;&emsp;安装完毕并设置好环境变量后，在命令行执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> go version</span><br>go version go1.16.6 linux/amd64<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;如果能正确显示 GO SDK 的版本（如上所示），则说明 SDK 安装成功。</p><h2 id="4-4-配置下载代理（可选但推荐）"><a href="#4-4-配置下载代理（可选但推荐）" class="headerlink" title="4.4 配置下载代理（可选但推荐）"></a>4.4 配置下载代理（可选但推荐）</h2><p>&emsp;&emsp;首先声明该步骤是可选的，但笔者强烈建议执行此步骤，因为在后面开发中会下载很多依赖包，如果采用默认代理，要么可能下载不到（具体原因，你懂的），要么下载速度巨慢，所以建议在命令行执行下面命令修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># GOPROXY=&quot;https://proxy.golang.org,direct&quot;</span></span><br><span class="hljs-meta">#</span><span class="bash"> go env GOPROXY</span><br><span class="hljs-meta">#</span><span class="bash"> go env -w GOPROXY=<span class="hljs-string">&quot;https://goproxy.io,direct&quot;</span></span><br><span class="hljs-meta">#</span><span class="bash"> go env GOPROXY</span><br>https://goproxy.io,direct<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;如果命令执行结果如上所示，表示修改成功，新代理路径已经改成 <a href="https://goproxy.io./">https://goproxy.io。</a></p><p>&emsp;&emsp;自此，整个 GO SDK 设置结束，读者可以进入到后续 GO 开发了。</p><h1 id="5-参考文献"><a href="#5-参考文献" class="headerlink" title="5 参考文献"></a>5 参考文献</h1><p>1 <a href="https://github.com/kubernetes/client-go">client-go 仓库</a> <a href="https://github.com/kubernetes/client-go">https://github.com/kubernetes/client-go</a></p>]]></content>
    
    
    <categories>
      
      <category>client-go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>client-go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式事务系列之二《事务》</title>
    <link href="/2021/08/14/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E3%80%8A%E4%BA%8B%E5%8A%A1%E3%80%8B/"/>
    <url>/2021/08/14/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E3%80%8A%E4%BA%8B%E5%8A%A1%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;上节介绍了单体架构，单体架构是整个漫长软件架构演进过程中使用人数最多、应用范围最广、也相对最稳定的一种架构。但随着业务多变、逻辑复杂性增加、交付时间越来越短，单体架构逐渐显出疲态，慢慢被分布式微服务架构所代替。</p><p>&emsp;&emsp;早期单体架构解决的核心问题是信息化，信息化处理的对象是数据，数据的质量直接影响到信息化的好坏。数据质量的判断有很多维度，其中最重要维度之一便是数据一致性。</p><h1 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h1><p>&emsp;&emsp;单纯的说教容易让人云里雾里，不妨举一个生活的例子。</p><p>&emsp;&emsp;我成长的年代还比较单纯，父母起名一般不会想太多。我至今记得一对男女同桌，女的叫做张开凤，男的叫做王里岛。下面就是他们的故事：</p><blockquote><p><strong>张开凤银行账户有 1000 块， 王里岛银行账户也有 1000 块</strong></p><p><strong>张开凤和王里岛相约进行爱的鼓掌，完事后，王里岛付给张开凤 200 块</strong></p><p><strong>张开凤现在账户里有 1200 块，而王里岛账户有 800 块</strong></p></blockquote><p>&emsp;&emsp;银行交易系统会执行如下语句：</p><blockquote><p><em><strong>update table account set savings = savings - 200 where name = “王里岛”</strong></em></p><p><em><strong>update table account set savings = savings + 200 where name = “张开凤”</strong></em></p></blockquote><p>&emsp;&emsp;如果交易系统执行第一条语句成功了，但在执行第二条语句的时候却失败了，那么张开凤就被白嫖了（但是王里岛是不会承认的，你仔细品一下）。</p><p>&emsp;&emsp;这真是一个悲伤的故事，悲剧的核心就在于数据不一致，碰到这样的事，作为一个有责任心的工程师是绝对不能坐视不理的。经过思考，我们发现该技术场景的痛点在于，如何保证一个事件序列的执行是原子的，即：要么全部执行成功，要么全部失败。</p><p><img src="/img/2021081402.png" srcset="/img/loading.gif" lazyload alt="02"></p><h1 id="事务定义"><a href="#事务定义" class="headerlink" title="事务定义"></a>事务定义</h1><p>&emsp;&emsp;事务想解决的本质问题就是数据状态的一致，有关事务的非官方定义如下：</p><ul><li><p>事务是操作数据源的程序（比如：一个事务可以是一条 SQL 语句，一组 SQL 语句或高级语言写的程序）</p></li><li><p>事务是一个不可分割的工作单元，单元内的操作要么全部执行成功，要么全部执行失败</p></li><li><p>事务是恢复和并发控制的基本单元</p></li></ul><h1 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h1><p>&emsp;&emsp;事务具有四个特征，这是小白面试时常被考的问题，教科书教导的顺序是 ACID（acid 中文翻译：酸）。笔者是个极其蠢笨的人，总是记不住，于是改良成 ICDA（中文翻译：爱操洞啊），就再没忘记过，这里冒死提供给读者，你们不用谢我。</p><blockquote><ul><li>I : isolation      （隔离性）。指一个事务内的事件序列执行时，不能被另外的事务所干扰</li><li>C: consistency（一致性）。指数据状态转换过程中必须是一致性</li><li>D: durability   （持久性）。指一旦事务提交之后，对数据库的改变就是永久的</li><li>A: atomic        （原子性）。指事务内的事件序列执行时是不可分割的，要么全部执行，要么都不执行</li></ul></blockquote><p>&emsp;&emsp;如果上面的学术解释让你昏昏欲睡，你可以换下面一种记法，结合“爱操洞啊”来理解，还是那句话，不用谢。</p><blockquote><ul><li>I : isolation      （隔离性）。I  就是“我”，世界上只有一个我，独一无二。所以本身具备隔离性、排他性</li><li>C: consistency（一致性）。C 就是“操”，操的对象必须一致，否则容易得病（你懂的）</li><li>D: durability   （持久性）。D 就是“洞”，面对洞一定要持久，这样她才会永远记得你（即使分手）</li><li>A: atomic        （原子性）。A  就是”啊“，高潮后发出的满足声音。要做就一定要高潮，否则就别做</li></ul></blockquote><p><img src="/img/2021081403.png" srcset="/img/loading.gif" lazyload alt="03"></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/9744607?fr=aladdin">事务百科</a> <a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/9744607?fr=aladdin">https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/9744607?fr=aladdin</a></li><li><a href="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fhbimg.b0.upaiyun.com%2F5ee7d275ed5f6adea8af216f4ae194ad0da7aa2d1a520-6askWI_fw658&refer=http%3A%2F%2Fhbimg.b0.upaiyun.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1631530265&t=40527bb540fa342f3c6211e57782423c">杜蕾斯图片</a> <a href="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fhbimg.b0.upaiyun.com%2F5ee7d275ed5f6adea8af216f4ae194ad0da7aa2d1a520-6askWI_fw658&amp;refer=http%3A%2F%2Fhbimg.b0.upaiyun.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1631530265&amp;t=40527bb540fa342f3c6211e57782423c">https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fhbimg.b0.upaiyun.com%2F5ee7d275ed5f6adea8af216f4ae194ad0da7aa2d1a520-6askWI_fw658&amp;refer=http%3A%2F%2Fhbimg.b0.upaiyun.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1631530265&amp;t=40527bb540fa342f3c6211e57782423c</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式事务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式事务系列之一《单体架构》</title>
    <link href="/2021/08/14/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E3%80%8A%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E3%80%8B/"/>
    <url>/2021/08/14/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E3%80%8A%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;分布式事务目标是解决数据一致性问题。在整个波澜壮阔的计算机科技发展史上，分布式事务并非一开始就存在，它只是历史发展的产物，随着软、硬件架构的不断更迭和演进才逐步发展起来的。</p><p>&emsp;&emsp;我还记得那是一个夏天，窗外鸟语花香，空气中满是新鲜和幸福的味道。那时路上还没有那么多车，苏堤远没有现在人流如织。在那个还流淌着小资的年代，软件从业者是小众的文艺小清新，也就在那时，我怀揣着改造世界的憧憬，莽撞地踏进了计算机的世界。</p><p>&emsp;&emsp;那时，世界远没有现在复杂，人心还没有那么险恶。我们没有微信、没有抖音、没有996、更没有内卷。我们悠闲地带耳机听着音乐、喝着咖啡。我们充满希望，用代码编织着内心的向往和美丽的梦。</p><p>&emsp;&emsp;那时，我们没有微服务，没有分布式，更没有分布式事务。我们只写单体……</p><p><img src="/img/2021081401.png" srcset="/img/loading.gif" lazyload alt="致敬那消失不再有的文艺时代"></p><h1 id="单体架构定义"><a href="#单体架构定义" class="headerlink" title="单体架构定义"></a>单体架构定义</h1><p>&emsp;&emsp;在网上找了很多的资料，不知道是不是因为单体架构简单到让人忽略的缘故，竟然很难找到官方定义或词条解释。但或许人类的认知都是从定义事物开始，所以我们不得不把搜寻的目光从官方转回到民间找寻答案，于是便有了下面的蹩脚英文定义：</p><blockquote><p><strong>What is a Monolith i.e. a monolithic architecture ?</strong></p><p><em>A monolithic application</em>, let’s call it a <em>Monolith</em>, is an application delivered via a single deployment unit. Examples could be an application delivered as single WAR or a Node application with a single entrypoint.</p></blockquote><p>&emsp;&emsp;翻译过来就是：</p><blockquote><p><strong>什么是单体应用/架构 ？</strong></p><p><em>单体应用（俗称巨石系统），是整体交付、统一部署的一类应用。比如通过 War 或者 node 部署的具有单一访问入口的应用</em></p></blockquote><p>&emsp;&emsp;分析上面非官方的定义，我们可以得出单体架构的特点：原子性。基于单体架构的应用都是原子而不可再分的，无论是交付还是部署，都必须作为一个统一的整体。</p><h1 id="单体架构分层"><a href="#单体架构分层" class="headerlink" title="单体架构分层"></a>单体架构分层</h1><p>&emsp;&emsp;上面我们定义了单体架构，但是通过定义，很容易会让我们产生认知错误，即：单体架构应用是简单的、缺乏层次的、由数据结构和算法堆积起来的、架构不友好的应用。</p><p>&emsp;&emsp;我承认，单体架构早期阶段确实是用血泪书写的。那时项目缺乏规范，从业者缺少指导，开发者又生猛异常。技术处理，多的是血性，少的是敬畏。在那个没有 bug，只有事故的年代，只要你敢乱来，就没有攻不破的系统。在笔者的亲身经历中就有幸经历过几个“生死”瞬间，为了不招惹是非，特隐去公司名。</p><blockquote><p>事故一：因为不合理的修改导致股票系统出问题，结果开发被能征惯战的东北股民问候了家长</p><p>事故二：因为电信出账单计算错误，贵州某地电信用户直接在营业厅上演平民版导火线</p><p>事故三：国内某电商支付公司早期秒杀业务，因为并发控制没控制好，导致手机被疯抢</p></blockquote><p>&emsp;&emsp;即使不出事故和故障，单体架构系统体量也足可以庞大到惊人，从编译到运行往往持续几十分钟，加一个 print 调试逻辑，一根烟都抽完了，结果却跑不出来。写到这里，笔者不禁停下来莞尔，过往经历犹如走马灯般在回忆中被解放。真怀念那个没有流程图、没有章法、信马由缰、涂鸦般的编码年代，一切都是那么“云原生”。每当黑黢黢的控制台颤悠悠显示出 XXX successful 字样时，那种赌徒般、大难不死的幸福感油然而生。</p><p>&emsp;&emsp;历史总是反复，而科技永远向前。技术最不愿放过的就是“痛点”，伴随着解决一个痛点，又生出一堆新的痛点 :-)。</p><p>&emsp;&emsp;工程师们被随心所欲的开发模式搞得苦不堪言，软件大师也被腐败不堪的技术负债搞得斯文扫地。于是大家围炉而坐，痛定思痛反省解决方案。终于，一切尘埃落定，“分层”腾空出世。从业务或职能（视图、控制、模型）等维度对单体应用进行分层，分层后的系统焕然一新，可维护性大幅提高。</p><p>&emsp;&emsp;分层架构模式如下图所示：</p><p><img src="/img/20210823174649.jpg" srcset="/img/loading.gif" lazyload alt="分层架构"></p><p>&emsp;&emsp;这样的分层架构模式一直延续至今，大名鼎鼎的 MVC 架构模式就脱胎于此，即便已经步入微服务时代，它依旧经典，依旧璀璨。</p><h1 id="单体架构部署"><a href="#单体架构部署" class="headerlink" title="单体架构部署"></a>单体架构部署</h1><p>&emsp;&emsp;单体架构应用因为原子性，不得不在单一进程空间，所有模块以及方法调用都不用考虑远程调用和网络。这样的部署、运行和访问方式简单、高效，出错的几率小，但同时也带来了隔离难、内存泄漏以及升级/扩展困难等不足。</p><p>&emsp;&emsp;下图是经典单体架构应用部署图：</p><p><img src="/img/20210823174716.jpg" srcset="/img/loading.gif" lazyload alt="单体架构"></p><h1 id="单体架构优点"><a href="#单体架构优点" class="headerlink" title="单体架构优点"></a>单体架构优点</h1><p>&emsp;&emsp;单体架构应用有很多优点：</p><ul><li>易于开发和调试：IDE（无论是本地还是云端）都天然支持单体架构应用的开发和调试</li><li>易于部署和运行：只需要在支持的运行时（Runtime）上部署交付组件即可（比如 war 包）</li><li>易于横向扩缩容：只需要通过在负载均衡器（比如 Nginx）后增加单体架构应用的多个副本即可</li></ul><h1 id="单体架构不足"><a href="#单体架构不足" class="headerlink" title="单体架构不足"></a>单体架构不足</h1><p>&emsp;&emsp;单体架构应用也有很多不足：</p><ul><li>复杂性高：所有代码在同一代码空间，即使分层，随着时间推移也会变得越来越庞大和复杂</li><li>全量部署：每次功能迭代或缺陷修复都需要部署整个应用。全量部署耗时长、影响范围广、风险高</li><li>隔离性差：整个单体架构应用依赖于相同运行环境。一旦某个模块出错，可能导致整个系统崩溃</li><li>垂直扩缩容成本高：遵从木桶理论。即使只有一个模块性能出现短板，也要求全量扩容</li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://programmerfriend.com/monolith-vs-microservices/">单体和微服务</a> <a href="https://programmerfriend.com/monolith-vs-microservices/">https://programmerfriend.com/monolith-vs-microservices/</a></li><li><a href="http://icyfenix.cn/architecture/architect-history/monolithic.html">凤凰架构</a> <a href="http://icyfenix.cn/architecture/architect-history/monolithic.html">http://icyfenix.cn/architecture/architect-history/monolithic.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式事务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
