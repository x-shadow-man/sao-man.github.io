<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Linux - vim 格式化 json</title>
    <link href="/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Linux-vim-%E6%A0%BC%E5%BC%8F%E5%8C%96-json/"/>
    <url>/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Linux-vim-%E6%A0%BC%E5%BC%8F%E5%8C%96-json/</url>
    
    <content type="html"><![CDATA[<p>1 创建或编辑 .vimrc 文件</p><p>2 vim 控制命令 :%!python json.tool</p><hr><h1 id="1-创建或编辑-vimrc-文件"><a href="#1-创建或编辑-vimrc-文件" class="headerlink" title="1 创建或编辑 .vimrc 文件"></a>1 创建或编辑 .vimrc 文件</h1><p>&emsp;&emsp;在用户家目录下创建 .vimrc 文件，如果已经有该文件，则直接在末尾添加如下关于格式化 json 的配置：</p><blockquote><p>map <F4><Esc>:%!python -m json.tool<CR></p></blockquote><p>&emsp;&emsp;截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1596177201107956.png" srcset="/img/loading.gif" lazyload alt="第十三章 九析带你轻松完爆 Linux - vim 格式化 json_linux 学习_02"></p><hr><h1 id="2-vim-控制命令-python-json-tool"><a href="#2-vim-控制命令-python-json-tool" class="headerlink" title="2 vim 控制命令 :%!python json.tool"></a>2 vim 控制命令 :%!python json.tool</h1><p>&emsp;&emsp;使用 vim 编辑器打开某个 json 格式的文件，然后进行命令编辑模式执行如下格式化过滤语句：</p><blockquote><p>%!python -m json.tool</p></blockquote><p>&emsp;&emsp;截图如下所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1596177208525240.png" srcset="/img/loading.gif" lazyload alt="第十三章 九析带你轻松完爆 Linux - vim 格式化 json_vim 格式化 json_03"></p><p>&emsp;&emsp;最终执行结果如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1596177217232856.png" srcset="/img/loading.gif" lazyload alt="第十三章 九析带你轻松完爆 Linux - vim 格式化 json_linux 视频_04"></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Linux - 网络虚拟化之 network namespace 续二</title>
    <link href="/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Linux-%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8B-network-namespace-%E7%BB%AD%E4%BA%8C/"/>
    <url>/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Linux-%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8B-network-namespace-%E7%BB%AD%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 多 netns 桥接通信</p><p>4 创建网桥</p><p>5 分别创建 netns 跟网桥的连接</p><p>  5.1 创建西门庆与王婆的***：</p><p>  5.2 创建潘金莲与王婆的***：</p><p>  5.3 查看网桥状态</p><p>  5.4 鹊桥约会</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>&emsp;&emsp;如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589360364852535.png" srcset="/img/loading.gif" lazyload alt="第十二章 九析带你轻松完爆 Linux - 网络虚拟化之 network namespace 续二_ip link veth"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>&emsp;&emsp;你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589360374644030.png" srcset="/img/loading.gif" lazyload alt="第十二章 九析带你轻松完爆 Linux - 网络虚拟化之 network namespace 续二_ip link veth_02"></p><hr><h1 id="3-多-netns-桥接通信"><a href="#3-多-netns-桥接通信" class="headerlink" title="3 多 netns 桥接通信"></a>3 多 netns 桥接通信</h1><p>&emsp;&emsp;西门庆和潘金莲一见钟情、情比金坚、冲破世俗的眼光偷偷地交往了。</p><p>&emsp;&emsp;为了捍卫心中的爱情，西门庆投巨资，偷偷买下了潘金莲家隔壁的房产。</p><p>&emsp;&emsp;白天，当武大出去摆地摊的时候，西门庆就让下人将***架在两家房檐之上，自己攀爬过去与心上人愉快地进行爱之鼓掌。如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589360383712298.png" srcset="/img/loading.gif" lazyload alt="第十二章 九析带你轻松完爆 Linux - 网络虚拟化之 network namespace 续二_ip netns add_03"></p><p>&emsp;&emsp;流光容易把人抛，红了樱桃、绿了芭蕉，美好的光阴如流水般从指缝滑过。</p><p>&emsp;&emsp;正所谓好花不常开，好景不常在，多事的巧歌向武大告知了此事，武大闻后勃然大怒，气愤难消，心中不禁怒吼，“西门这个死扑街，丢你老母”。</p><p>&emsp;&emsp;武大有了情绪，回到家闷闷不乐。潘金莲似乎猜到事情不妙，只好低眉顺目，尽量多做些家务，不惹武大生气。</p><p>&emsp;&emsp;武大心中不爽，于是花园中溜达，一抬头看到了墙头上绿色的***，立刻猜中了缘由，二话不说，回到屋中取出利斧，三下五除二砍断了绿梯。为了保险，武大又从集市买了一条疯狗，置于园中，等一切妥当之后，武大蹲在墙角下拿出旱烟点上，吧嗒吧嗒抽得好不惬意。</p><p>&emsp;&emsp;现在 netns 的拓补图如下所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589360390572691.png" srcset="/img/loading.gif" lazyload alt="第十二章 九析带你轻松完爆 Linux - 网络虚拟化之 network namespace 续二_ip netns exec_04"></p><p>&emsp;&emsp;做完了这一切，武大开心地又出门开工去了。他就是这么豪迈，就是这么任性。</p><p>&emsp;&emsp;联系被切断，西门庆和潘金莲只能望洋兴叹。</p><p>&emsp;&emsp;春天到了，一切都是那么盎然，潘金莲在庭院中顾影自怜。正所谓良辰美景奈何天，赏心悦事谁家院。就在她觉得此情无计可消除，才下眉头，又上心头时，突然闻得有人敲门。敲门一看原来是街坊王婆。</p><p>&emsp;&emsp;王婆一直都是个助人为乐、雪中送炭的热心肠，年轻的时候还被街道表彰并赋予优秀 38 红旗手称号。</p><p>&emsp;&emsp;    潘金莲一看是王婆，立即把她引入客厅。王婆落座后就说：“有段日子没见你了，怕你出事就来看看。你最近生活情况如何？武大有没有家暴你、有没有 PUA 你。</p><p>&emsp;&emsp;潘金莲一时懵逼，欲语还休。</p><p>&emsp;&emsp;两个不同经历、拥有不同故事的女人面对面坐着，谁也不说话。天地间一时静谧，时间慢慢温柔了伤痛。</p><p>&emsp;&emsp;    “我爱他，尽管他是个渣男。”潘金莲鼓足勇气说道。</p><p>&emsp;&emsp;“你不后悔？”王婆其实早就洞穿了一切。</p><p>&emsp;&emsp;“不后悔。”</p><p>&emsp;&emsp;“那我帮你”。王婆总是这么善解人意。</p><p>&emsp;&emsp;“怎么帮？武大这个刚烈的汉子把绿***给砍了。”</p><p>&emsp;&emsp;“没事。小事一桩。你俩可以不通过绿梯。”</p><p>&emsp;&emsp;“那通过？”</p><p>&emsp;&emsp;“桥！”难道你没听过方文山作曲、王力宏作曲的“缘分一道桥”吗？</p><p>&emsp;&emsp;“没。”</p><p>&emsp;&emsp;“那我给你唱唱。谈爱恨，不能潦草，红尘烧啊烧，以生死，无愧证明谁重要，这缘分，像一道桥，故事瞧一瞧……”</p><p>&emsp;&emsp;潘金莲皱起了眉头，因为王婆唱歌发出的声音就像一脚踩到了鸭脖子上。不过这歌词写得当真不赖。</p><p>&emsp;&emsp;“可是我们哪有桥？”潘金莲不禁问道。</p><p>&emsp;&emsp;“我家就是你们的桥啊！这样西门大官人就可以通过我家到你家里来喽！”，王婆欢快地说。</p><p>&emsp;&emsp;“原来如此！”</p><hr><h1 id="4-创建网桥"><a href="#4-创建网桥" class="headerlink" title="4 创建网桥"></a>4 创建网桥</h1><p>&emsp;&emsp;使用如下语句创建虚拟网桥：</p><blockquote><p>ip link add wangpo type bridge</p></blockquote><p>&emsp;&emsp;虚拟网桥创建成功后，还需要启动它。也就是只有王婆家的门保持开放，西门庆才可以通过王婆访问到潘金莲。</p><p>&emsp;&emsp;启用网桥的命令如下：</p><blockquote><p>ip link set wangpo up</p></blockquote><p>&emsp;&emsp;目标网络拓补图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589364281832340.png" srcset="/img/loading.gif" lazyload alt="第十二章 九析带你轻松完爆 Linux - 网络虚拟化之 network namespace 续二_ip link veth_05"></p><hr><h1 id="5-分别创建-netns-跟网桥的连接"><a href="#5-分别创建-netns-跟网桥的连接" class="headerlink" title="5 分别创建 netns 跟网桥的连接"></a>5 分别创建 netns 跟网桥的连接</h1><h2 id="5-1-创建西门庆与王婆的"><a href="#5-1-创建西门庆与王婆的" class="headerlink" title="5.1 创建西门庆与王婆的***"></a>5.1 创建西门庆与王婆的***</h2><blockquote><p>ip link add wangpo4ximen type veth peer name ximen4wangpo</p></blockquote><p>&emsp;&emsp;命令执行结果如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589360403761668.png" srcset="/img/loading.gif" lazyload alt="第十二章 九析带你轻松完爆 Linux - 网络虚拟化之 network namespace 续二_ip netns exec_06"></p><p>&emsp;&emsp;架好西门庆到王婆这端的***：</p><blockquote><p>ip link set ximen4wangpo netns ximenqing</p><p>ip netns exec ximenqing ip addr add dev ximen4wangpo 192.168.188.69/24</p></blockquote><p>&emsp;&emsp;启用西门庆到王婆端的***：</p><blockquote><p>ip netns exec ximenqing ip link set ximen4wangpo up</p></blockquote><p>&emsp;&emsp;架好王婆到西门庆这端的***：</p><blockquote><p>ip link set wangpo4ximen master wangpo</p></blockquote><p>&emsp;&emsp;启用王婆到西门庆端的***：</p><blockquote><p>ip link set wangpo4ximen up</p></blockquote><h2 id="5-2-创建潘金莲与王婆的"><a href="#5-2-创建潘金莲与王婆的" class="headerlink" title="5.2 创建潘金莲与王婆的***"></a>5.2 创建潘金莲与王婆的***</h2><blockquote><p>ip link add wp4pjl type veth peer name pjl4wp</p></blockquote><p>&emsp;&emsp;架好潘金莲到王婆这端的***：</p><blockquote><p>ip link set pjl4wp netns panjinlian</p><p>ip netns exec panjinlian ip addr add dev pjl4wp 192.168.188.96/24</p></blockquote><p>&emsp;&emsp;启用潘金莲到王婆这端的***：</p><blockquote><p>ip netns exec panjinlian ip link set pjl4wp up</p></blockquote><p>&emsp;&emsp;架好王婆到潘金莲这端的***：</p><blockquote><p>ip link set wp4pjl master wangpo    </p></blockquote><p>&emsp;&emsp;启用王婆到潘金莲端的***：</p><blockquote><p>ip link set wp4pjl up</p></blockquote><h2 id="5-3-查看网桥状态"><a href="#5-3-查看网桥状态" class="headerlink" title="5.3 查看网桥状态"></a>5.3 查看网桥状态</h2><blockquote><p>bridge link</p></blockquote><p>&emsp;&emsp;命令执行结果如下所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589360412826556.png" srcset="/img/loading.gif" lazyload alt="第十二章 九析带你轻松完爆 Linux - 网络虚拟化之 network namespace 续二_ip netns add_08"></p><h2 id="5-4-鹊桥约会"><a href="#5-4-鹊桥约会" class="headerlink" title="5.4 鹊桥约会"></a>5.4 鹊桥约会</h2><p>&emsp;&emsp;一切准备就绪，该让西门庆和潘金莲相会了，作为男人，西门庆当然要主动一点：</p><blockquote><p>ip netns exec ximenqing ping -c 3 192.168.188.96</p></blockquote><p>&emsp;&emsp;命令执行结果如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589360421386518.png" srcset="/img/loading.gif" lazyload alt="第十二章 九析带你轻松完爆 Linux - 网络虚拟化之 network namespace 续二_ip link_10"></p><p>&emsp;&emsp;最终，西门庆跟潘金莲再次有情人终成眷属。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589364245275917.png" srcset="/img/loading.gif" lazyload alt="第十二章 九析带你轻松完爆 Linux - 网络虚拟化之 network namespace 续二_ip netns exec_11"></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Linux - 网络虚拟化之 network namespace 续</title>
    <link href="/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Linux-%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8B-network-namespace-%E7%BB%AD/"/>
    <url>/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Linux-%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8B-network-namespace-%E7%BB%AD/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 多网络空间之间通信</p><p>4 两个 netns 之间的通信</p><p>5 两个 netns 之间通信实践</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>&emsp;&emsp;如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589341343299037.png" srcset="/img/loading.gif" lazyload alt="第十一章 九析带你轻松完爆 Linux - 网络虚拟化之 network namespace 续_linux netns exec"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>&emsp;&emsp;你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589341351231485.png" srcset="/img/loading.gif" lazyload alt="第十一章 九析带你轻松完爆 Linux - 网络虚拟化之 network namespace 续_linux netns exec_02"></p><hr><h1 id="3-多网络空间之间通信"><a href="#3-多网络空间之间通信" class="headerlink" title="3 多网络空间之间通信"></a>3 多网络空间之间通信</h1><p>&emsp;&emsp;多 netns 实现了网络的隔离，每个 netns 就相当于一台独立的主机，把这些 netns 用网络设备连接起来就可以实现多 netns 通信，就实现了局域网的功能。</p><hr><h1 id="4-两个-netns-之间的通信"><a href="#4-两个-netns-之间的通信" class="headerlink" title="4 两个 netns 之间的通信"></a>4 两个 netns 之间的通信</h1><p>&emsp;&emsp;就像用一根网线把两台物理机连通就可以实现通信一样，两台 netns 通信也是同样的思路。所以要先创建一根虚拟的网线出来，这根网线就是 veth pair。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589341361565172.png" srcset="/img/loading.gif" lazyload alt="第十一章 九析带你轻松完爆 Linux - 网络虚拟化之 network namespace 续_linux ip addr_04"></p><p>&emsp;&emsp;首先创建 2 个 netns（潘金莲、西门庆）：</p><blockquote><p>ip netns add ximenqing</p><p>ip netns add panjinlian</p></blockquote><p>&emsp;&emsp;接着执行如下指令创建 Veth pair：</p><blockquote><p>ip link add panjinlian type veth peer name ximenqing</p></blockquote><p>&emsp;&emsp;该命令会生成月老的一条红线，可以通过 ip link 指令查看到：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589341371855363.png" srcset="/img/loading.gif" lazyload alt="第十一章 九析带你轻松完爆 Linux - 网络虚拟化之 network namespace 续_linux netns exec_06"></p><hr><h1 id="5-两个-netns-之间通信实践"><a href="#5-两个-netns-之间通信实践" class="headerlink" title="5 两个 netns 之间通信实践"></a>5 两个 netns 之间通信实践</h1><p>&emsp;&emsp;在上面，我们创建了西门庆、潘金莲以及它们之间思念的红线，现在是时候将红线的两头种在西门庆和潘金莲的心中了，正所谓：我住长江头，君住长江尾，日夜思君不见君，共饮一江水。</p><blockquote><p>ip link set panjinlian netns ximenqing</p><p>ip link set ximenqing netns panjinlian</p></blockquote><p>&emsp;&emsp;上面命令执行完毕之后，在宿主机执行 ip link 后，发现前面创建的红线已经不见了。下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589341410521834.png" srcset="/img/loading.gif" lazyload alt="第十一章 九析带你轻松完爆 Linux - 网络虚拟化之 network namespace 续_linux ip addr_07"></p><p>&emsp;&emsp;原因就在于它们已经被西门庆和潘金莲牢牢印在心底了。如下所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589341419380923.png" srcset="/img/loading.gif" lazyload alt="第十一章 九析带你轻松完爆 Linux - 网络虚拟化之 network namespace 续_ip link netns_08"></p><p>&emsp;&emsp;但是仅仅有相思苦还是无计可施的，需要让他们能够相见，相见的途径就是让他们确切知道对方的住址。如下所示：</p><blockquote><p>ip netns exec panjinlian ip addr add dev ximenqing 192.168.188.69/24</p><p>ip netns exec ximenqing ip addr add dev panjinlian 192.168.188.96/24</p></blockquote><p>&emsp;&emsp;一切都准备就绪了，但是还缺少了一点什么，对，那就是需要点燃他们之间的欲火，来吧，还等什么呢？</p><blockquote><p>ip netns exec ximenqing ip link set panjinlian up</p><p>ip netns exec panjinlian ip link set ximenqing up</p></blockquote><p>&emsp;&emsp;正所谓金风玉露一相逢，便胜却人间无数。现在这对热恋中的青年男女可以尽情地进行爱的鼓掌了，他们可以尽情施展 69 姿势。</p><blockquote><p>ip netns exec ximenqing ping -c 3 192.168.188.69</p></blockquote><p>&emsp;&emsp;命令执行结果如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589341432235419.png" srcset="/img/loading.gif" lazyload alt="第十一章 九析带你轻松完爆 Linux - 网络虚拟化之 network namespace 续_linux netns exec_09"></p><p>&emsp;&emsp;自此，九析已经带你轻松完爆了多个 netns 通信。有关西门大官人和潘家大小姐的后续待下次分解。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Linux - 网络虚拟化之 network namespace</title>
    <link href="/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Linux-%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8B-network-namespace/"/>
    <url>/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Linux-%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8B-network-namespace/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 Linux network namespace 简介</p><p>4 查看 network namespace</p><p>5 创建 network namespace</p><p>6 进入创建的 network namespace</p><p>7 操作网络命名空间网络资源</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>&emsp;&emsp;如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589337247198648.png" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 Linux - 网络虚拟化之 network namespace_ip addr"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>&emsp;&emsp;你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589337257625595.png" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 Linux - 网络虚拟化之 network namespace_linux 命名空间_02"></p><hr><h1 id="3-Linux-network-namespace-简介"><a href="#3-Linux-network-namespace-简介" class="headerlink" title="3 Linux network namespace 简介"></a>3 Linux network namespace 简介</h1><p>&emsp;&emsp;network namespace 是 linux 内核提供的特性，是网络虚拟化的重要功能，使用它可以创建多个相互独立且隔离的网络空间。</p><hr><h1 id="4-查看-network-namespace"><a href="#4-查看-network-namespace" class="headerlink" title="4 查看 network namespace"></a>4 查看 network namespace</h1><p>&emsp;&emsp;使用如下命令可以查看当前系统的 network namespace：</p><blockquote><p>ip netns ls</p></blockquote><p>&emsp;&emsp;默认情况下，并没有 network namespace。</p><p>&emsp;&emsp;可以通过如下命令查看 netns 用法：</p><blockquote><p>ip netns help</p></blockquote><p>&emsp;&emsp;执行结果如下所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589337267227846.png" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 Linux - 网络虚拟化之 network namespace_linux 命名空间_04"></p><hr><h1 id="5-创建-network-namespace"><a href="#5-创建-network-namespace" class="headerlink" title="5 创建 network namespace"></a>5 创建 network namespace</h1><p>&emsp;&emsp;使用如下命令创建网络命名空间：</p><blockquote><p>ip netns add lvcha</p></blockquote><p>&emsp;&emsp;上述命令会创建一个名叫“绿茶”的网络命名空间，并且还会在 /var/run/netns 目录下面创建一个 lvcha 的文件。</p><hr><h1 id="6-进入创建的-network-namespace"><a href="#6-进入创建的-network-namespace" class="headerlink" title="6 进入创建的 network namespace"></a>6 进入创建的 network namespace</h1><p>&emsp;&emsp;网络空间一旦创建，该网络空间下就会有独立的网卡、路由表、arp 表、iptables 等跟网络相关的资源。</p><p>&emsp;&emsp;执行如下命令进入创建的网络命名空间：</p><blockquote><p>ip netns exec lvcha bash</p></blockquote><p>&emsp;&emsp;进入 lvcha 的 network namespace 后，可以执行如下命令查看跟该网络命名空间相关的资源信息：</p><blockquote><p>route -n  # 查看路由</p><p>iptables -nvL     # 查看 filter 表防火墙规则</p><p>arp -n        # 查看 arp 表信息</p><p>ifconfig    # 查看启用的网卡信息</p><p>ip link        # 查看网卡信息，不包括 IP 信息</p><p>ip addr        # 查看网卡信息，包括 IP 信息</p></blockquote><p>&emsp;&emsp;初始情况下，网络命名空间中只有 lo 网卡信息，并且该信息还处于停用状态，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589337277111195.png" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 Linux - 网络虚拟化之 network namespace_linux network ns_06"></p><p>&emsp;&emsp;退出网络命名空间通过命令 exit 即可。</p><hr><h1 id="7-操作网络命名空间网络资源"><a href="#7-操作网络命名空间网络资源" class="headerlink" title="7 操作网络命名空间网络资源"></a>7 操作网络命名空间网络资源</h1><p>&emsp;&emsp;通过 ip netns exec 命令不仅可以进入 network namespace，而且还可以在网络空间外直接操作该网络空间内的网络资源，只需要在 ip netns exec 网络地址空间名后添加命令即可：</p><blockquote><p>ip netns exec lvcha ip link        # 查看 lvcha 空间中的网卡信息</p><p>ip netns exec lvcha ip link set lo up     # 启用 lvcha 空间中 lo 网卡</p><p>ip netns exec lvcha ping -c 3 127.0.0.1 # lvcha 空间中访问 lo 网卡</p></blockquote><p>&emsp;&emsp;lvcha 空间中访问 lo 网卡结果如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589337286434057.png" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 Linux - 网络虚拟化之 network namespace_ip addr_08"></p><p>&emsp;&emsp;自此，九析带你轻松完爆单 network namespace 的操作。有关多 network namespace 之间的通信可以看我下节内容。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Linux - vmware 网络连接之 HOST_ONLY</title>
    <link href="/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Linux-vmware-%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E4%B9%8B-HOST-ONLY/"/>
    <url>/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Linux-vmware-%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E4%B9%8B-HOST-ONLY/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 HOST-ONLY 模式介绍</p><p>4 HOST-ONLY 模式网络拓补图</p><p>5 宿主机和虚拟机通信</p><p>6 虚拟机访问外网</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>&emsp;&emsp;如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589188050180720.png" srcset="/img/loading.gif" lazyload alt="第九章 九析带你轻松完爆 Linux - vmware 网络连接之 HOST_ONLY_vmware 桥接"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>&emsp;&emsp;你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589188059971635.png" srcset="/img/loading.gif" lazyload alt="第九章 九析带你轻松完爆 Linux - vmware 网络连接之 HOST_ONLY_linux_02"></p><hr><h1 id="3-HOST-ONLY-模式介绍"><a href="#3-HOST-ONLY-模式介绍" class="headerlink" title="3 HOST-ONLY 模式介绍"></a>3 HOST-ONLY 模式介绍</h1><p>&emsp;&emsp;前面两章中细致分析并轻松完爆了 Bridged 和 NAT 方式，有了这两种方式的认识，接下来了解 HOST-ONLY 方式就会更容易一些。</p><p>&emsp;&emsp;vmware 如果采用 HOST-ONLY 网络连接模式，则会绑定 VMnet1 虚拟交换机，同时会绑定虚拟网卡 vmware network adapter vmnet1。如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589188069574714.png" srcset="/img/loading.gif" lazyload alt="第九章 九析带你轻松完爆 Linux - vmware 网络连接之 HOST_ONLY_vmware 桥接_04"></p><p>&emsp;&emsp;HOST-ONLY 使用场景是虚拟机之间通信或者虚拟机与宿主机之间通信，而不作为跟互联网通信用。当然如果虚拟机也能联网，只需将宿主机网卡共享给 vmware network adapter vmnet1 即可。</p><hr><h1 id="4-HOST-ONLY-模式网络拓补图"><a href="#4-HOST-ONLY-模式网络拓补图" class="headerlink" title="4 HOST-ONLY 模式网络拓补图"></a>4 HOST-ONLY 模式网络拓补图</h1><p>&emsp;&emsp;网络拓补图如下所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589188502803604.png" srcset="/img/loading.gif" lazyload alt="第九章 九析带你轻松完爆 Linux - vmware 网络连接之 HOST_ONLY_vmware bridged_06"></p><hr><h1 id="5-宿主机和虚拟机通信"><a href="#5-宿主机和虚拟机通信" class="headerlink" title="5 宿主机和虚拟机通信"></a>5 宿主机和虚拟机通信</h1><p>&emsp;&emsp;如果要保持宿主机和虚拟机可以通信，首先要保证 vmware network adapter vmnet1 处于已启用状态，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589188516938160.png" srcset="/img/loading.gif" lazyload alt="第九章 九析带你轻松完爆 Linux - vmware 网络连接之 HOST_ONLY_vmware 桥接_08"></p><p>&emsp;&emsp;选择已经创建完毕的虚拟机，然后点击“编辑虚拟机设置选项”：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589188524728701.png" srcset="/img/loading.gif" lazyload alt="第九章 九析带你轻松完爆 Linux - vmware 网络连接之 HOST_ONLY_linux_10"></p><p>&emsp;&emsp;在“虚拟机设置”弹出框中，指定网络连接为“仅主机模式”，然后点击“确定”：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589188532190976.png" srcset="/img/loading.gif" lazyload alt="第九章 九析带你轻松完爆 Linux - vmware 网络连接之 HOST_ONLY_vmware bridged_12"></p><p>&emsp;&emsp;启动虚拟机。设置为 dhcp 方式，即：自动分配 IP 方式。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589188541740374.png" srcset="/img/loading.gif" lazyload alt="第九章 九析带你轻松完爆 Linux - vmware 网络连接之 HOST_ONLY_vmware bridged_14"></p><p>&emsp;&emsp;然后重启网络：</p><blockquote><p>systemctl restart network</p></blockquote><p>&emsp;&emsp;宿主机 vmware network adapter vmnet1 信息如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589188549784963.png" srcset="/img/loading.gif" lazyload alt="第九章 九析带你轻松完爆 Linux - vmware 网络连接之 HOST_ONLY_linux_16"></p><p>&emsp;&emsp;虚拟机网卡信息如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589188557742480.png" srcset="/img/loading.gif" lazyload alt="第九章 九析带你轻松完爆 Linux - vmware 网络连接之 HOST_ONLY_vmware nat_18"></p><p>&emsp;&emsp;重启网络，宿主机访问虚拟机可以连通，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589188564287676.png" srcset="/img/loading.gif" lazyload alt="第九章 九析带你轻松完爆 Linux - vmware 网络连接之 HOST_ONLY_vmware bridged_20"></p><p>&emsp;&emsp;虚拟机访问宿主机也可以连通，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589188574832806.png" srcset="/img/loading.gif" lazyload alt="第九章 九析带你轻松完爆 Linux - vmware 网络连接之 HOST_ONLY_vmware 桥接_22"></p><p>&emsp;&emsp;如果虚拟机无法访问宿主机，而宿主机却可以正常访问虚拟机，关闭宿主机防火墙重新尝试，一般可以轻松完爆。</p><hr><h1 id="6-虚拟机访问外网"><a href="#6-虚拟机访问外网" class="headerlink" title="6 虚拟机访问外网"></a>6 虚拟机访问外网</h1><p>&emsp;&emsp;由网络拓补可知，如果虚拟机要联通外网，必须要通过宿主机物理网卡共享给 vmware network adapter vmnet1。具体操作方式如下：</p><p>&emsp;&emsp;选择宿主机上网网卡，比如本人是通过无线网卡上网，那么打开网络连接，选中上网网卡，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589188584629036.png" srcset="/img/loading.gif" lazyload alt="第九章 九析带你轻松完爆 Linux - vmware 网络连接之 HOST_ONLY_vmware bridged_24"></p><p>&emsp;&emsp;右键网卡选择“属性”，在弹出框中选择“共享”，然后再选择 Internet 连接共享，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589188599453126.png" srcset="/img/loading.gif" lazyload alt="第九章 九析带你轻松完爆 Linux - vmware 网络连接之 HOST_ONLY_vmware host-only_26"></p><p>&emsp;&emsp;宿主机网卡绑定 vmnet1 虚拟网卡之后，再次查看 vmnet1 虚拟网卡信息，发现此时网卡信息已经改变，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589188607319360.png" srcset="/img/loading.gif" lazyload alt="第九章 九析带你轻松完爆 Linux - vmware 网络连接之 HOST_ONLY_vmware nat_27"></p><p>&emsp;&emsp;编辑 vmware 的“虚拟网络编辑器”，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589188615426782.png" srcset="/img/loading.gif" lazyload alt="第九章 九析带你轻松完爆 Linux - vmware 网络连接之 HOST_ONLY_vmware 桥接_30"></p><p>&emsp;&emsp;在弹出框中选择“更改设置”，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589188623321047.png" srcset="/img/loading.gif" lazyload alt="第九章 九析带你轻松完爆 Linux - vmware 网络连接之 HOST_ONLY_vmware 桥接_32"></p><p>&emsp;&emsp;修改 vmnet1 的子网信息，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589188633661731.png" srcset="/img/loading.gif" lazyload alt="第九章 九析带你轻松完爆 Linux - vmware 网络连接之 HOST_ONLY_vmware host-only_33"></p><p>&emsp;&emsp;编辑虚拟机的网卡信息，添加网关和 DNS 配置，分别制定为宿主机 vmnet1 虚拟网卡的 IP。如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589188643405064.png" srcset="/img/loading.gif" lazyload alt="第九章 九析带你轻松完爆 Linux - vmware 网络连接之 HOST_ONLY_vmware host-only_36"></p><p>&emsp;&emsp;重启网络访问外网，发现可以轻松完爆：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589188650191681.png" srcset="/img/loading.gif" lazyload alt="第九章 九析带你轻松完爆 Linux - vmware 网络连接之 HOST_ONLY_vmware nat_38"></p><p>&emsp;&emsp;如果你发现无法访问外网，可以通过设置路由的方式，添加默认网关，网关地址为 192.168.137.1。如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589188661792308.png" srcset="/img/loading.gif" lazyload alt="第九章 九析带你轻松完爆 Linux - vmware 网络连接之 HOST_ONLY_vmware 桥接_40"></p><p>&emsp;&emsp;自此，九析带你轻松完爆了 vmware 网络连接的三种方式。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vmware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Linux - vmware 网络连接之 NAT</title>
    <link href="/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Linux-vmware-%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E4%B9%8B-NAT/"/>
    <url>/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Linux-vmware-%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E4%B9%8B-NAT/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 NAT 介绍</p><p>4 NAT 网络拓步说明</p><p>5 NAT 设置</p><p>6 Vmware Network Adapter VMnet8</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>&emsp;&emsp;如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588924406903490.png" srcset="/img/loading.gif" lazyload alt="第八章 九析带你轻松完爆 Linux - vmware 网络连接之 NAT_wmware vmnet0"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>&emsp;&emsp;你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588924415220912.png" srcset="/img/loading.gif" lazyload alt="第八章 九析带你轻松完爆 Linux - vmware 网络连接之 NAT_vmware vmnet8_02"></p><hr><h1 id="3-NAT-介绍"><a href="#3-NAT-介绍" class="headerlink" title="3 NAT 介绍"></a>3 NAT 介绍</h1><p>&emsp;&emsp;上章节中介绍了 vmware 的三种网络连接方式的桥接，知道桥接方式的组网虚拟机必须跟宿主机网卡必须处于同一网段。如果在你的网络 IP 资源相对紧张，且你又迫切希望虚拟机可以联网，此时 NAT 就可以轻松完爆。</p><p>&emsp;&emsp;处于 NAT 网络连接下的多个虚拟机同处于一个局域网，且该局域网网络跟宿主机所在局域网网络不同。NAT 网络下的虚拟机可以通过宿主机网卡单向跟宿主机网络中的其他主机通信或者访问外网，但是反过来却不成立。</p><hr><h1 id="4-NAT-网络拓步说明"><a href="#4-NAT-网络拓步说明" class="headerlink" title="4 NAT 网络拓步说明"></a>4 NAT 网络拓步说明</h1><p>&emsp;&emsp;NAT 网络拓补图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588924451847283.png" srcset="/img/loading.gif" lazyload alt="第八章 九析带你轻松完爆 Linux - vmware 网络连接之 NAT_vmware nat_03"></p><p>&emsp;&emsp;NAT 模式中，宿主机内所有虚拟机通过 VMnet8 虚拟交换机互连，这样虚拟机之间就可以互相通信。此外 VMnet8  虚拟交换机上又连接了另外两个虚拟设备：虚拟 NAT 和虚拟 DHCP 服务器，后者解决连接在虚拟交换器 VMnet8 上的其他虚拟机的 IP  自动分配问题，虚拟 NAT 解决的是虚拟机跟外界通信数据报文的地址转换问题。从上面网络拓补图来看虚拟机并不依靠虚拟网卡 vmware  network adapter vmnet8 来联网的。而 vmware network adapter vmnet8  只是提供宿主机跟各个虚拟机的通信功能，如果我们关闭此虚拟网卡，只会导致宿主机无法访问虚拟机，但并不会导致虚拟机访问不了宿主机，因为虚拟机可以通过 NAT 设备跟宿主机网卡通信。后续我会带你们轻松完爆进行验证。</p><p>&emsp;&emsp;本人 vmware network adapter vmnet8 信息如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588924467863025.png" srcset="/img/loading.gif" lazyload alt="第八章 九析带你轻松完爆 Linux - vmware 网络连接之 NAT_vmware nat_05"></p><p>&emsp;&emsp;本人实际使用无线网卡上网，无线网卡信息如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588924475113736.png" srcset="/img/loading.gif" lazyload alt="第八章 九析带你轻松完爆 Linux - vmware 网络连接之 NAT_wmware vmnet0_07"></p><hr><h1 id="5-NAT-设置"><a href="#5-NAT-设置" class="headerlink" title="5 NAT 设置"></a>5 NAT 设置</h1><p>&emsp;&emsp;打开 vmware，首先创建需要的虚拟机（一个或多个），然后选择“编辑”-&gt;“虚拟网络编辑器”，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588924483882914.png" srcset="/img/loading.gif" lazyload alt="第八章 九析带你轻松完爆 Linux - vmware 网络连接之 NAT_wmware vmnet0_08"></p><p>&emsp;&emsp;弹出框中查看 VMnet8 模式下的虚拟 NAT 和虚拟 DHCP 设置信息，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588924491194045.png" srcset="/img/loading.gif" lazyload alt="第八章 九析带你轻松完爆 Linux - vmware 网络连接之 NAT_wmware vmnet0_09"></p><p>&emsp;&emsp;从虚拟 NAT 设置中可知网关 IP 信息：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588924502728205.png" srcset="/img/loading.gif" lazyload alt="第八章 九析带你轻松完爆 Linux - vmware 网络连接之 NAT_vmware vmnet0 vmnet_10"></p><p>&emsp;&emsp;从虚拟 DHCP 设置中可知虚拟机网卡所分配的 IP 网段信息：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588924513933669.png" srcset="/img/loading.gif" lazyload alt="第八章 九析带你轻松完爆 Linux - vmware 网络连接之 NAT_vmware vmnet0 vmnet_11"></p><p>&emsp;&emsp;掌握了虚拟交换机 VMnet8 相关信息后，创建虚拟机，创建完后，点击“编辑虚拟机设置”：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588924521486051.png" srcset="/img/loading.gif" lazyload alt="第八章 九析带你轻松完爆 Linux - vmware 网络连接之 NAT_vmware vmnet0 vmnet_12"></p><p>&emsp;&emsp;在弹出框“虚拟机设置”中，网络连接选择 “NAT模式”：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588924530688563.png" srcset="/img/loading.gif" lazyload alt="第八章 九析带你轻松完爆 Linux - vmware 网络连接之 NAT_vmware 网络连接_13"></p><p>&emsp;&emsp;设置完毕后，进入虚拟机操作系统 centos，编辑网卡文件：</p><blockquote><p>vi /etc/sysconfig/network-scripts/ifcfg-ens32</p></blockquote><p>&emsp;&emsp;有两种方式设置网卡文件。</p><p>&emsp;&emsp;第一种方式：直接将 BOOTPROTO 设置为 dhcp，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588924539356308.png" srcset="/img/loading.gif" lazyload alt="第八章 九析带你轻松完爆 Linux - vmware 网络连接之 NAT_vmware vmnet8_15"></p><p>&emsp;&emsp;设置完毕后，重启网络：</p><blockquote><p>systemctl restart network</p></blockquote><p>&emsp;&emsp;查看网卡信息，发现 IP 已经自动分配，且处于虚拟 DHCP 默认分配的地址段：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588924548835625.png" srcset="/img/loading.gif" lazyload alt="第八章 九析带你轻松完爆 Linux - vmware 网络连接之 NAT_vmware nat_17"></p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588924559736989.png" srcset="/img/loading.gif" lazyload alt="第八章 九析带你轻松完爆 Linux - vmware 网络连接之 NAT_vmware nat_19"></p><p>&emsp;&emsp;虚拟机可以访问外网和宿主机，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588924566524564.png" srcset="/img/loading.gif" lazyload alt="第八章 九析带你轻松完爆 Linux - vmware 网络连接之 NAT_vmware vmnet8_21"></p><p>&emsp;&emsp;宿主机访问虚拟机，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588924575813341.png" srcset="/img/loading.gif" lazyload alt="第八章 九析带你轻松完爆 Linux - vmware 网络连接之 NAT_vmware vmnet8_23"></p><p>&emsp;&emsp;第二种方式，采用静态 IP 方式，同样修改网卡文件：</p><blockquote><p>vi /etc/sysconfig/network-scripts/ifcfg-ens32</p></blockquote><blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588924583986837.png" srcset="/img/loading.gif" lazyload alt="第八章 九析带你轻松完爆 Linux - vmware 网络连接之 NAT_vmware vmnet8_25"></p></blockquote><hr><h1 id="6-Vmware-Network-Adapter-VMnet8"><a href="#6-Vmware-Network-Adapter-VMnet8" class="headerlink" title="6 Vmware Network Adapter VMnet8"></a>6 Vmware Network Adapter VMnet8</h1><p>&emsp;&emsp;上面我们介绍过一个知识点，虚拟机访问外网或者宿主机并不通过 vmware network adapter vmnet8，vmware network adapter vmnet8  是宿主机跟虚拟机通信的媒介，下面我们来证明一下。进入操作系统的网络连接，停用 vmware network adapter  vmnet8，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588924594111361.png" srcset="/img/loading.gif" lazyload alt="第八章 九析带你轻松完爆 Linux - vmware 网络连接之 NAT_vmware vmnet0 vmnet_27"></p><p>&emsp;&emsp;禁用 vmnet8 网络适配器之后，打开 cmd，使用 ping 访问虚拟机，发现此时已经访问不通了：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588924604848245.png" srcset="/img/loading.gif" lazyload alt="第八章 九析带你轻松完爆 Linux - vmware 网络连接之 NAT_vmware vmnet0 vmnet_29"></p><p>&emsp;&emsp;但是在虚拟机内部，再次访问宿主机和外网，发现网络仍然是通的，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588924612185616.png" srcset="/img/loading.gif" lazyload alt="第八章 九析带你轻松完爆 Linux - vmware 网络连接之 NAT_vmware vmnet8_31"></p><p>&emsp;&emsp;自此，九析带你轻松完爆 Linux - vmware 网络连接之 NAT 模式。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vmware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Linux - vmware 网络连接之桥接</title>
    <link href="/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Linux-vmware-%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E4%B9%8B%E6%A1%A5%E6%8E%A5/"/>
    <url>/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Linux-vmware-%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E4%B9%8B%E6%A1%A5%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 网络连接方式介绍</p><p>4 查看网络连接三种方式</p><p>5 桥接模式（Bridged）</p><p>6 桥接模式设置</p><p>7 总结</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>&emsp;&emsp;如果你对博客有任何疑问，请告诉我。<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588845581631987.png" srcset="/img/loading.gif" lazyload alt="第七章 九析带你轻松完爆 Linux - vmware 网络连接之桥接_linux 教程"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>&emsp;&emsp;你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588845588391293.png" srcset="/img/loading.gif" lazyload alt="第七章 九析带你轻松完爆 Linux - vmware 网络连接之桥接_vmware 网络连接_02"></p><hr><h1 id="3-网络连接方式介绍"><a href="#3-网络连接方式介绍" class="headerlink" title="3 网络连接方式介绍"></a>3 网络连接方式介绍</h1><p>&emsp;&emsp;Vmware workstation 是一款虚拟机软件，可以用它创建虚拟机。VMware 提供了三种网络连接的方式，可以结合自己实际的使用场景来选择不同的网络连接方法。这三种网络连接方式分别为：</p><blockquote><p>桥接模式（Bridged）</p><p>网络地址转换模式（NAT）</p><p>主机模式（Host-Only）</p></blockquote><p>&emsp;&emsp;不同的网络连接方式使用不同的网络通信介质，下表是针对上面网络连接方式对应的通信介质：</p><blockquote><p>VMnet0</p><p>VMnet1</p><p>VMnet8</p></blockquote><p>&emsp;&emsp;因此一旦选择了网络连接方式，相当于同时指定了网络通讯介质。其实这里的通信介质（VMnet0、VMnet1、VMnet8）就是用软件的方式实现的交换机（switch），即：虚拟交换机。不同网络通信介质搭配不同的网络适配器（即网卡，无论是软网卡、虚拟网卡还是实际网卡）。下表是针对上面的网络通讯介质对应的网络适配器：</p><blockquote><p>宿主机网卡（无线、有线）</p><p>VMware Virtual Ethernet Adapter for VMnet1</p><p>VMware Virtual Ethernet Adapter for VMnet8</p></blockquote><p>&emsp;&emsp;简单来说，如果你一旦选定了虚拟机的网络连接方式，那么同时也就选定了虚拟交换机（VMnetN）、同时选定了配套的网络适配器。</p><hr><h1 id="4-查看网络连接三种方式"><a href="#4-查看网络连接三种方式" class="headerlink" title="4 查看网络连接三种方式"></a>4 查看网络连接三种方式</h1><p>&emsp;&emsp;vmware 三种网络连接方式的查看方式如下：</p><p>&emsp;&emsp;选择“虚拟网络编辑器”：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588845599365850.png" srcset="/img/loading.gif" lazyload alt="第七章 九析带你轻松完爆 Linux - vmware 网络连接之桥接_linux 视频_03"></p><p>&emsp;&emsp;选择更改设置：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588845608616385.png" srcset="/img/loading.gif" lazyload alt="第七章 九析带你轻松完爆 Linux - vmware 网络连接之桥接_linux 视频_04"></p><p>&emsp;&emsp;三种网络连接方式如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588845615267925.png" srcset="/img/loading.gif" lazyload alt="第七章 九析带你轻松完爆 Linux - vmware 网络连接之桥接_linux 视频_05"></p><hr><h1 id="5-桥接模式（Bridged）"><a href="#5-桥接模式（Bridged）" class="headerlink" title="5 桥接模式（Bridged）"></a>5 桥接模式（Bridged）</h1><p>&emsp;&emsp;桥接模式本质就是宿主机网卡跟虚拟机网卡通过虚拟网桥进行通信。比如我宿主机使用的是无线网卡，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588845622804908.png" srcset="/img/loading.gif" lazyload alt="第七章 九析带你轻松完爆 Linux - vmware 网络连接之桥接_vmware 桥接_06"></p><p>&emsp;&emsp;我的虚拟机网卡如下图所示，本人虚拟机运行 centos，虚拟机网卡是 ens32：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588845628249721.png" srcset="/img/loading.gif" lazyload alt="第七章 九析带你轻松完爆 Linux - vmware 网络连接之桥接_linux 视频_07"></p><p>&emsp;&emsp;宿主机内运行 windows 操作系统，宿主机内运行的虚拟机内部运行 linux  操作系统，它们各自有各自的网卡（一实一虚）。我们不妨可以将它们看成两台不同的终端，如果希望这两台终端可以通信，可以通过网线直连、集线器（hub）或者交换机（switch）。在上面我们说过 VMnet0 就是桥接模式的虚拟交换机（或者网桥），自此可知：宿主机网卡（无线或者有线）跟 VMnet0 相连，而虚拟机中的虚拟网卡（比如  ens32 ）也跟 VMnet0 相连，自此构成整个数据流向通路。</p><p>&emsp;&emsp;而 VMnet0  实际上就是一个虚拟的网桥（交换机），这个网桥有很多端口，一个端口用于连接宿主机网卡，其他端口负责连接虚拟机虚拟网卡，它们的位置是对等的。此外，网桥其实是不用配置 IP 的，这也是为什么你在 vmware 软件安装后只能看到 VMnet1 和 VMnet8，但却看不到 VMnet0 的原因。</p><p>&emsp;&emsp;上述过程可以跟公司的内部网络做类比，一个公司由 4 个 IT 人员组成，每个人员都配置了一台笔记本，网管设置了一台交换机，这台交换机跟一台路由器相连，IT  人员的网线都插在这台交换机上。路由器开启了 dhcp 功能给大家自动分配处于同网段的 IP，这样这 4 台笔记本可以互相通信。</p><p>&emsp;&emsp;采用桥接方式的虚拟机如果要跟宿主机进行通信，必须要跟宿主机网卡设置在同一个网段、子网掩码、网关。就好像上面的 4 人 IT 公司一样，所有笔记本要能互相通信必须要在同一个网段一样。当然如果你的路由器开启了 DHCP  功能后，你就不用人为进行设置了，当然如果你想证明自己很屌，即使路由器 DHCP 功能开启后，你仍然可以手动进行设置虚拟机网卡。</p><p>&emsp;&emsp;桥接模式的网络通信如下图所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588847887189271.png" srcset="/img/loading.gif" lazyload alt="第七章 九析带你轻松完爆 Linux - vmware 网络连接之桥接_vmware 桥接_08"></p><p>&emsp;&emsp;宿主机内部就像实现了一个小型的局域网一样。这个局域网内部的每台主机都处于相同的网段（子网掩码相同），并且网关和 DNS 都相同。其中虚拟网桥会转发宿主机网卡接收到的广播和组播，以及目标为虚拟交换机网段的单播。所以，与虚拟交换机连接的虚拟网卡（例  ens32）接收到了路由器发出的 DHCP 信息以及路由更新。</p><p>&emsp;&emsp;上面的网络拓步图如果我想起了张艺谋的长城，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588847923149568.png" srcset="/img/loading.gif" lazyload alt="第七章 九析带你轻松完爆 Linux - vmware 网络连接之桥接_linux 教程_09"></p><p>&emsp;&emsp;巧合的是，长城的插曲就是方文山作词、王力宏作曲的《缘分一道桥》，这里正好可以比喻成虚拟网桥，而景甜在这里就充当网桥（虚拟交换机），起到连接宿主机网卡（达蒙）和各个虚拟机网卡（不同女兵）之间通信的媒介。</p><hr><h1 id="6-桥接模式设置"><a href="#6-桥接模式设置" class="headerlink" title="6 桥接模式设置"></a>6 桥接模式设置</h1><p>&emsp;&emsp;使用 vmware 创建虚拟机成功之后，选择指定虚拟机的“编辑虚拟机设置”连接：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588845674907704.png" srcset="/img/loading.gif" lazyload alt="第七章 九析带你轻松完爆 Linux - vmware 网络连接之桥接_vmware bridge_10"></p><p>&emsp;&emsp;在弹出框“虚拟机中设置”中选中“网络连接”中的桥接模式：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588845687590219.png" srcset="/img/loading.gif" lazyload alt="第七章 九析带你轻松完爆 Linux - vmware 网络连接之桥接_vmware bridge_11"></p><p>&emsp;&emsp;设置完毕后，启动虚拟机中的 centos（本人 centos7），启动完毕后，编辑网卡文件：</p><blockquote><p>vi /etc/sysconfig/network-scripts/ifcfg-ens32</p></blockquote><p>&emsp;&emsp;添加 IPADDR、NETMASK、DNS、GATEWAY 信息，以及修改 BOOTPROTO  信息，网络配置信息可以参考你的物理网卡信息，比如本人采用的是无线网卡，那么有关该网卡的 IP、子网掩码、DNS 和 网关信息如下图所示，通过命令 ipconfig/all：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588845700886426.png" srcset="/img/loading.gif" lazyload alt="第七章 九析带你轻松完爆 Linux - vmware 网络连接之桥接_linux 视频_12"></p><p>&emsp;&emsp;那么相应的虚拟机网卡信息配置内容如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588845710114155.png" srcset="/img/loading.gif" lazyload alt="第七章 九析带你轻松完爆 Linux - vmware 网络连接之桥接_linux 视频_13"></p><p>&emsp;&emsp;设置好后执行如下命令重启网络：</p><blockquote><p>systemctl restart network</p></blockquote><p>&emsp;&emsp;重启网络成功后可以通过 ping 命令来检查宿主机跟宿主机内的虚拟机是否网络通信正常。如果宿主机可以访问虚拟机而虚拟机无法访问到宿主机的话，可以考虑关闭宿主机的防火墙。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588845720310552.png" srcset="/img/loading.gif" lazyload alt="第七章 九析带你轻松完爆 Linux - vmware 网络连接之桥接_vmware bridge_14"></p><hr><h1 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h1><p>&emsp;&emsp;其实，从某种程度上类比来看，桥接模式就好像在物理网卡上创建了多个 IP。下面演示如何在 centos 上针对同一个网卡创建多个 IP。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1588845731342791.png" srcset="/img/loading.gif" lazyload alt="第七章 九析带你轻松完爆 Linux - vmware 网络连接之桥接_linux 视频_15"></p><p>&emsp;&emsp;自此，九析带你轻松完爆 Linux 之 vmware 网络连接设置之桥接模式。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vmware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 linux bash</title>
    <link href="/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-linux-bash/"/>
    <url>/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-linux-bash/</url>
    
    <content type="html"><![CDATA[<p>1 su</p><p>2 bash 操作</p><p>  2.1 ctrl + r</p><p>  2.2 esc + .</p><p>  2.3 通配符</p><p>  2.4 作业 (jobs、&amp;、bg、fg、ctrl+z）</p><hr><h1 id="1-su"><a href="#1-su" class="headerlink" title="1 su"></a>1 su</h1><p>&emsp;&emsp;su 命令是切换用户（switch user）：</p><blockquote><p>su - root # 作用是切换用户，同时进入 root 系统管理员用户环境。</p><p>su root    # 作用是只切换用户，但是仍旧停留在原用户环境中。</p></blockquote><p>&emsp;&emsp;比如你去泡温泉，如果前台给你一张 vip 卡，即 “-“ ，那么你进去就可以有一个属于自己的包间；如果什么都不给你，即没有 “-“，即使你进去了，也只能给其他人共用同一个池子。</p><p>&emsp;&emsp;在 vagrant 用户环境中声明了一个变量 NAME，如果切换到 root 用户时不加 “-“，首先你会发现 root 用户仍然在  vagrant 目录里，并仍然可以打印出本来在 vagrant 用户环境中的变量 NAME 值，说明只是换了 root  身份，但是环境依然是  vagrant 环境。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210912210515458.png" srcset="/img/loading.gif" lazyload alt="image-20210912210515458"></p><p>&emsp;&emsp;如果切换 root 用户时加了 “-“，你会发现不仅切换到了 root 自己的用户目录下，同时也不能打印原本在 vagrant 用户环境下的 NAME 值了。由此说明不仅切换了用户，同时还切换了用户的环境。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210912210532317.png" srcset="/img/loading.gif" lazyload alt="image-20210912210532317"></p><hr><h1 id="2-bash-操作"><a href="#2-bash-操作" class="headerlink" title="2 bash 操作"></a>2 bash 操作</h1><p>&emsp;&emsp;    在终端控制台中操作命令。</p><h2 id="2-1-ctrl-r"><a href="#2-1-ctrl-r" class="headerlink" title="2.1 ctrl + r"></a>2.1 ctrl + r</h2><p>&emsp;&emsp;历史记录匹配命令。根据你输入的内容，检索你的 history 命令，如果有匹配就直接显示出来。</p><p>&emsp;&emsp;比如曾经执行过命令 ls /var，然后按下 ctrl + r，再按下一个字母 v，就可以自动匹配我曾经输入的 ls /var 命令。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210912210549050.png" srcset="/img/loading.gif" lazyload alt="image-20210912210549050"></p><h2 id="2-2-esc"><a href="#2-2-esc" class="headerlink" title="2.2 esc + ."></a>2.2 esc + .</h2><p>&emsp;&emsp;先输入下面命令并执行：</p><blockquote><p>ls /var</p></blockquote><p>&emsp;&emsp;再输入 echo，然后再输入 esc 和 . ，你会发现 bash 自动把上面命令的选项 /var 直接复制到了 echo 命令后面：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210912210602035.png" srcset="/img/loading.gif" lazyload alt="image-20210912210602035"></p><h2 id="2-3-通配符"><a href="#2-3-通配符" class="headerlink" title="2.3 通配符"></a>2.3 通配符</h2><blockquote><p>[0-9]: 表示匹配 0～9 中的任何一个数字</p></blockquote><h2 id="2-4-作业-jobs、-amp-、bg、fg、ctrl-z）"><a href="#2-4-作业-jobs、-amp-、bg、fg、ctrl-z）" class="headerlink" title="2.4 作业 (jobs、&amp;、bg、fg、ctrl+z）"></a>2.4 作业 (jobs、&amp;、bg、fg、ctrl+z）</h2><blockquote><p>ctrl + c：表示终止进程</p><p>ctrl + z：表示暂停进程</p><p>&amp;： 表示将进程放到后台运行</p><p>jobs：查看当前后台运行的进程</p><p>bg num：在后台运行序列号为 num 的进程</p><p>fg num：将后台序列号为 num 的进程放到前台来执行</p></blockquote><p>&emsp;&emsp;上面命令的执行效果如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210912210615706.png" srcset="/img/loading.gif" lazyload alt="image-20210912210615706"></p><p>&emsp;&emsp;自此，轻松完爆 linux bash 操作。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 tcpdump</title>
    <link href="/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-tcpdump/"/>
    <url>/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-tcpdump/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 使用</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>&emsp;&emsp;tcpdump 是一款命令行抓包工具，普遍适用于 linux、unix、windows 操作系统中。tcpdump  工具本身依赖于库文件去获取网卡流量信息，比如在 windows 下就是 winpcap，在 linux 下就是 libpcap 等等。其中  pcap 就是 package capture 的缩写。</p><hr><h1 id="2-使用"><a href="#2-使用" class="headerlink" title="2 使用"></a>2 使用</h1><p>&emsp;&emsp;直接使用如下命令查看流量信息：</p><blockquote><p>tcpdump</p></blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210912210147706.png" srcset="/img/loading.gif" lazyload alt="image-20210912210147706"></p><p>&emsp;&emsp;命令执行会会抓取通过该主机的所有网络流量。每一行表示一条流量记录，比如：</p><blockquote><p>18:23:11.591431 ARP, Request who-has 192.168.31.100 tell 192.168.31.85, length 28</p></blockquote><p>&emsp;&emsp;这行表示一个数据包是在什么时间发生的，属于什么协议（ARP），协议内容是网络上一台主机广播寻找 IP 为 192.168.31.100 的主机。</p><h2 id="2-1-抓取指定数量数据包"><a href="#2-1-抓取指定数量数据包" class="headerlink" title="2.1 抓取指定数量数据包"></a>2.1 抓取指定数量数据包</h2><p>&emsp;&emsp;使用 -c(count)  抓取指定数量的数据包:</p><blockquote><p>tcpdump -c 3</p></blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210912210206139.png" srcset="/img/loading.gif" lazyload alt="image-20210912210206139"></p><h2 id="2-2-保存抓包记录"><a href="#2-2-保存抓包记录" class="headerlink" title="2.2 保存抓包记录"></a>2.2 保存抓包记录</h2><p>&emsp;&emsp;使用 -w(write) 保存抓包记录：</p><blockquote><p>tcpdump -c 6 -w tcpdump.out</p></blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210912210219445.png" srcset="/img/loading.gif" lazyload alt="image-20210912210219445"></p><h2 id="2-3-读取抓包记录"><a href="#2-3-读取抓包记录" class="headerlink" title="2.3 读取抓包记录"></a>2.3 读取抓包记录</h2><p>&emsp;&emsp;使用 -r(read) 从指定文件读取抓包记录：</p><blockquote><p>tcpdump -r tcpdump.out</p></blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210912210232575.png" srcset="/img/loading.gif" lazyload alt="image-20210912210232575"></p><h2 id="2-4-查询当前网卡"><a href="#2-4-查询当前网卡" class="headerlink" title="2.4 查询当前网卡"></a>2.4 查询当前网卡</h2><p>&emsp;&emsp;使用 -D 列出宿主机所有网卡信息：</p><blockquote><p>tcpdump -D</p></blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210912210245224.png" srcset="/img/loading.gif" lazyload alt="image-20210912210245224"></p><h2 id="2-5-查看指定网络流量数据"><a href="#2-5-查看指定网络流量数据" class="headerlink" title="2.5 查看指定网络流量数据"></a>2.5 查看指定网络流量数据</h2><p>&emsp;&emsp;有时我们只想查看通过指定网卡的网络流量数据，可以使用 -i(interface)  参数轻松完爆。比如我想查看环回网卡（lo，也就是 127.x.x.x)  的流量信息，就可以直接使用如下命令：</p><blockquote><p>tcpdump -i lo0</p></blockquote><p>&emsp;&emsp;再打开一个命令行终端：</p><blockquote><p>ping 127.0.0.1</p></blockquote><p>&emsp;&emsp;再回到运行 tcpdump 命令行终端中，可以看到已经捕捉并显示出流量信息数据。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210912210258945.png" srcset="/img/loading.gif" lazyload alt="image-20210912210258945"></p><p>&emsp;&emsp;自此，轻松完爆 tcpdump。</p><h2 id="2-6-查看指定网络流量数据"><a href="#2-6-查看指定网络流量数据" class="headerlink" title="2.6 查看指定网络流量数据"></a>2.6 查看指定网络流量数据</h2><p>&emsp;&emsp;如果你想查看出口流量情况，可以指定 host 选项，如下图所示：</p><blockquote><p>tcpdump -i eth0 host <a href="http://www.baidu.com/">www.baidu.com</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tcpdump</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你玩转 linux - 自建 DNS 服务器</title>
    <link href="/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E7%8E%A9%E8%BD%AC-linux-%E8%87%AA%E5%BB%BA-DNS-%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E7%8E%A9%E8%BD%AC-linux-%E8%87%AA%E5%BB%BA-DNS-%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>1 DNS 服务器安装</p><p>2 DNS 服务器配置</p><p>  2.1 DNS 服务器启动</p><p>  2.2 DNS 服务器状态查看</p><p>  2.3 DNS 服务器配置</p><p>​    2.3.1 修改 /etc/named.conf 文件</p><p>​    2.3.2 修改 /etc/named.rfc1912.zones 文件</p><p>  2.4 创建 /var/named/nexus.com.zone 文件</p><p>  2.5 DNS 服务器配置检查</p><p>  2.6 DNS 服务器配置文件权限修改</p><p>  2.7 重启 DNS 服务器</p><p>  2.8 查看 DNS 服务器启动状态</p><p>  2.9 关闭服务器防火墙</p><p>3 DNS linux 客户端配置</p><p>  3.1 设置 linux 客户端</p><p>  3.2 验证 linux 客户端</p><p>4 DNS windows 客户端配置</p><p>  4.1 设置 windows 客户端</p><p>  4.2 验证 windows 客户端</p><hr><h1 id="1-DNS-服务器安装"><a href="#1-DNS-服务器安装" class="headerlink" title="1 DNS 服务器安装"></a>1 DNS 服务器安装</h1><blockquote><p>yum install bind</p></blockquote><hr><h1 id="2-DNS-服务器配置"><a href="#2-DNS-服务器配置" class="headerlink" title="2 DNS 服务器配置"></a>2 DNS 服务器配置</h1><h2 id="2-1-DNS-服务器启动"><a href="#2-1-DNS-服务器启动" class="headerlink" title="2.1 DNS 服务器启动"></a>2.1 DNS 服务器启动</h2><blockquote><p>yum enable named &amp;&amp; yum start named</p></blockquote><h2 id="2-2-DNS-服务器状态查看"><a href="#2-2-DNS-服务器状态查看" class="headerlink" title="2.2 DNS 服务器状态查看"></a>2.2 DNS 服务器状态查看</h2><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210912205518770.png" srcset="/img/loading.gif" lazyload alt="image-20210912205518770"></p><h2 id="2-3-DNS-服务器配置"><a href="#2-3-DNS-服务器配置" class="headerlink" title="2.3 DNS 服务器配置"></a>2.3 DNS 服务器配置</h2><p>&emsp;&emsp;DNS 主要配置文件为：</p><blockquote><p>1） /etc/named.conf         # 主配置文件</p><p>\2)  /etc/named.rfc1912.zones    # 域名配置文件</p><p>3） /var/named/            # zone 配置文件目录</p></blockquote><h3 id="2-3-1-修改-etc-named-conf-文件"><a href="#2-3-1-修改-etc-named-conf-文件" class="headerlink" title="2.3.1 修改 /etc/named.conf 文件"></a>2.3.1 修改 /etc/named.conf 文件</h3><p>&emsp;&emsp;named.conf 文件是 DNS 服务器的主配置文件，关键属性如下：</p><blockquote><p>listen-on     // 监听 IPV4 地址</p><p>listen-on-v6     // 监听 IPV6 地址</p><p>allow-query     // 设置可以访问 dns 服务器的客户端</p></blockquote><p>&emsp;&emsp;修改完的文件如下：</p><blockquote><p>options {</p><pre><code>  listen-on port 53 &#123; any; &#125;;  listen-on-v6 port 53 &#123; ::1; &#125;;  directory     &quot;/var/named&quot;;  dump-file     &quot;/var/named/data/cache_dump.db&quot;;  statistics-file &quot;/var/named/data/named_stats.txt&quot;;  memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;;  recursing-file  &quot;/var/named/data/named.recursing&quot;;  secroots-file  &quot;/var/named/data/named.secroots&quot;;  allow-query   &#123; any; &#125;;  recursion yes;  dnssec-enable yes;  dnssec-validation yes;  /* Path to ISC DLV key */  bindkeys-file &quot;/etc/named.iscdlv.key&quot;;  managed-keys-directory &quot;/var/named/dynamic&quot;;  pid-file &quot;/run/named/named.pid&quot;;  session-keyfile &quot;/run/named/session.key&quot;;</code></pre><p>};</p><p>logging {</p><p>  channel default_debug {</p><p>​    file “data/named.run”;</p><p>​    severity dynamic;</p><p>  };</p><p>};</p><p>zone “.” IN {</p><pre><code>  type hint;  file &quot;named.ca&quot;;</code></pre><p>};</p><p>include “/etc/named.rfc1912.zones”;</p><p>include “/etc/named.root.key”;</p></blockquote><h3 id="2-3-2-修改-etc-named-rfc1912-zones-文件"><a href="#2-3-2-修改-etc-named-rfc1912-zones-文件" class="headerlink" title="2.3.2 修改 /etc/named.rfc1912.zones 文件"></a>2.3.2 修改 /etc/named.rfc1912.zones 文件</h3><p>&emsp;&emsp;新增 nexus.com 域名配置（自定义域名为： jiuxi.nexus.com）：</p><blockquote><p>zone “nexus.com” IN    {</p><pre><code>  type master;  file &quot;nexus.com.zone&quot;;</code></pre><p>};</p><p>zone “localhost.localdomain” IN {</p><pre><code>  type master;  file &quot;named.localhost&quot;;  allow-update &#123; none; &#125;;</code></pre><p>};</p><p>zone “localhost” IN {</p><pre><code>  type master;  file &quot;named.localhost&quot;;  allow-update &#123; none; &#125;;</code></pre><p>};</p><p>zone “1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa” IN {</p><pre><code>  type master;  file &quot;named.loopback&quot;;  allow-update &#123; none; &#125;;</code></pre><p>};</p><p>zone “1.0.0.127.in-addr.arpa” IN {</p><pre><code>  type master;  file &quot;named.loopback&quot;;  allow-update &#123; none; &#125;;</code></pre><p>};</p><p>zone “0.in-addr.arpa” IN {</p><pre><code>  type master;  file &quot;named.empty&quot;;  allow-update &#123; none; &#125;;</code></pre><p>};</p></blockquote><h2 id="2-4-创建-var-named-nexus-com-zone-文件"><a href="#2-4-创建-var-named-nexus-com-zone-文件" class="headerlink" title="2.4 创建 /var/named/nexus.com.zone 文件"></a>2.4 创建 /var/named/nexus.com.zone 文件</h2><p>&emsp;&emsp;注意文件名要跟域名配置文件中设置的 file 一致：</p><blockquote><p>cp -p /var/named/named.localhost /var/named/nexus.com.zone</p></blockquote><p>&emsp;&emsp;编辑 nexus.com.zone 文件：</p><blockquote><p>$TTL 1D</p><p>@    IN SOA    @ jiuxi.nexus.com. (</p><p>​                                            0    ; serial</p><p>​                                            1D    ; refresh</p><p>​                                            1H    ; retry</p><p>​                                            1W    ; expire</p><p>​                                            3H )    ; minimum</p><p>@        NS    jiuxi    </p><p>jiuxi    A    10.110.101.100    </p></blockquote><h2 id="2-5-DNS-服务器配置检查"><a href="#2-5-DNS-服务器配置检查" class="headerlink" title="2.5 DNS 服务器配置检查"></a>2.5 DNS 服务器配置检查</h2><blockquote><p>named-checkconf</p><p>named-checkzone nexus.com /var/named/nexus.com.zone</p></blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210912205543870.png" srcset="/img/loading.gif" lazyload alt="image-20210912205543870"></p><h2 id="2-6-DNS-服务器配置文件权限修改"><a href="#2-6-DNS-服务器配置文件权限修改" class="headerlink" title="2.6 DNS 服务器配置文件权限修改"></a>2.6 DNS 服务器配置文件权限修改</h2><blockquote><p>chmod 777 /etc/named.conf</p><p>chmod 777 /etc/named.rfc1912.zones</p></blockquote><h2 id="2-7-重启-DNS-服务器"><a href="#2-7-重启-DNS-服务器" class="headerlink" title="2.7 重启 DNS 服务器"></a>2.7 重启 DNS 服务器</h2><blockquote><p>systemctl restart named</p></blockquote><h2 id="2-8-查看-DNS-服务器启动状态"><a href="#2-8-查看-DNS-服务器启动状态" class="headerlink" title="2.8 查看 DNS 服务器启动状态"></a>2.8 查看 DNS 服务器启动状态</h2><blockquote><p>systemctl status named</p></blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210912205600707.png" srcset="/img/loading.gif" lazyload alt="image-20210912205600707"></p><h2 id="2-9-关闭服务器防火墙"><a href="#2-9-关闭服务器防火墙" class="headerlink" title="2.9 关闭服务器防火墙"></a>2.9 关闭服务器防火墙</h2><blockquote><p>systemctl stop firewalld</p></blockquote><p>&emsp;&emsp;自此，整个 DNS 服务端配置完成。</p><hr><h1 id="3-DNS-linux-客户端配置"><a href="#3-DNS-linux-客户端配置" class="headerlink" title="3 DNS linux 客户端配置"></a>3 DNS linux 客户端配置</h1><h2 id="3-1-设置-linux-客户端"><a href="#3-1-设置-linux-客户端" class="headerlink" title="3.1 设置 linux 客户端"></a>3.1 设置 linux 客户端</h2><p>&emsp;&emsp;另找一台 linux 客户端来做测试。修改 /etc/resovled.conf 文件，添加 DNS 服务器 IP：</p><blockquote><p>nameserver 10.110.101.105</p></blockquote><p>&emsp;&emsp;或修改 /etc/sysconfig/network-scripts/ifcfg-XXXXXX 网卡文件，添加 DNS 信息，并将自定义 DNS 服务器设置为 DNS1，然后重启网络：</p><blockquote><p>DNS1=10.110.101.105        # 自定义 DNS 服务器 IP</p><p>DNS2=114.114.114.114        # 公共 DNS 服务器 IP</p><p>systemctl restart network    # 重启网络</p></blockquote><p>&emsp;&emsp;重启成功后，查看 /etc/resolved.conf 文件发现自定义 DNS 更改成功。</p><h2 id="3-2-验证-linux-客户端"><a href="#3-2-验证-linux-客户端" class="headerlink" title="3.2 验证 linux 客户端"></a>3.2 验证 linux 客户端</h2><blockquote><p>yum install bind-utils</p><p>nslookup jiuxi.nexus.com</p><p>dig jiuxi.nexus.com</p><p>ping jiuxi.nexus.com</p></blockquote><hr><h1 id="4-DNS-windows-客户端配置"><a href="#4-DNS-windows-客户端配置" class="headerlink" title="4 DNS windows 客户端配置"></a>4 DNS windows 客户端配置</h1><h2 id="4-1-设置-windows-客户端"><a href="#4-1-设置-windows-客户端" class="headerlink" title="4.1 设置 windows 客户端"></a>4.1 设置 windows 客户端</h2><p>&emsp;&emsp;打开“运行”，输入 “ncpa.cpl” ：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210912205624934.png" srcset="/img/loading.gif" lazyload alt="image-20210912205624934"></p><p>&emsp;&emsp;选择你当前使用的网络连接：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210912205648841.png" srcset="/img/loading.gif" lazyload alt="image-20210912205648841"></p><p>&emsp;&emsp;选择 TCP/IPv4 协议：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210912205704614.png" srcset="/img/loading.gif" lazyload alt="image-20210912205704614"></p><p>&emsp;&emsp;填写 DNS 配置信息。注意，将自定义 DNS 设为“首选”：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210912205719847.png" srcset="/img/loading.gif" lazyload alt="image-20210912205719847"></p><p>&emsp;&emsp;选择“高级” 标签，在弹出选框中选中 “WINS” 标签页，禁用 NetBIOS：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210912205739475.png" srcset="/img/loading.gif" lazyload alt="image-20210912205739475"></p><h2 id="4-2-验证-windows-客户端"><a href="#4-2-验证-windows-客户端" class="headerlink" title="4.2 验证 windows 客户端"></a>4.2 验证 windows 客户端</h2><p>&emsp;&emsp;打开控制台：</p><blockquote><p>ipconfig/flushdns</p></blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210912205756666.png" srcset="/img/loading.gif" lazyload alt="image-20210912205756666"></p><p>&emsp;&emsp;验证 win 客户端：</p><blockquote><p>nslookup jiuxi.nexus.com</p><p>ping jiuxi.nexus.com</p></blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210912205812599.png" srcset="/img/loading.gif" lazyload alt="image-20210912205812599"></p><p>&emsp;&emsp;自此，整个自建 DNS 完成。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DNS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你处理 zombie(defunct) 进程</title>
    <link href="/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E5%A4%84%E7%90%86-zombie-defunct-%E8%BF%9B%E7%A8%8B/"/>
    <url>/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E5%A4%84%E7%90%86-zombie-defunct-%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 僵尸进程</p><p>  2.1 进程简介</p><p>  2.2 僵尸进程例子</p><p>  2.3 僵尸进程危害</p><p>3 处理僵尸进程</p><p>  3.1 kill 命令</p><p>  3.2 kill 父进程</p><p>  3.3 reboot</p><p>  3.4 magic sysrq key 方法</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>&emsp;&emsp;在 centos7 跑 Docker 和 k8s 时，偶尔会出现 systemctl 失效的情况，现象如下：</p><blockquote><p>Failed to get properties…</p></blockquote><p>&emsp;&emsp;查看系统进程，发现僵尸进程（zombie/defunct）：</p><blockquote><p>ps -ef | grep defunct</p></blockquote><hr><h1 id="2-僵尸进程"><a href="#2-僵尸进程" class="headerlink" title="2 僵尸进程"></a>2 僵尸进程</h1><h2 id="2-1-进程简介"><a href="#2-1-进程简介" class="headerlink" title="2.1 进程简介"></a>2.1 进程简介</h2><p>&emsp;&emsp;在 linux 中，父进程通过 fork 调用创建子进程。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210912205225426.png" srcset="/img/loading.gif" lazyload alt="image-20210912205225426"></p><p>&emsp;&emsp;子进程执行完毕之后，内核会释放该子进程所占用的资源，包括打开的文件，占用的内存等，但仍然会在进程表中保留一个槽位（slot）存放该子进程的文件描述符（比如进程PID、进程退出状态、进程运行时间等），直到父进程发送 wait() 或 waitpid() 调用，内核才会把子进程文件描述符从进程表中彻底清除。如果父进程不调用 wait() 或  waitpid()对子进程进行清理，那子进程将处于僵尸状态。</p><p>&emsp;&emsp;但是如果父进程先于子进程结束的话，会导致子进程变成僵尸进程吗？答案是不会。因为每当进程结束的时候，系统都会扫描当前所有运行的进程，查找是否有这个结束进程的子进程，如果有，就由 init 进程（或者 systemd 进程）来接管子进程，成为子进程的新父进程，并自动 wait  这个子进程，确保以后该子进程不会变成僵尸进程。</p><h2 id="2-2-僵尸进程例子"><a href="#2-2-僵尸进程例子" class="headerlink" title="2.2 僵尸进程例子"></a>2.2 僵尸进程例子</h2><p>&emsp;&emsp;下面展示一个 c 语言编写的僵尸进程样例，样例中主进程并不会 wait 子进程，生成文件 zombie.c：</p><blockquote><p>#include &lt;unistd.h&gt;</p><p>#include &lt;stdio.h&gt;</p><p>#include &lt;stdlib.h&gt;</p><p>int main(void)  {</p><p>  int i = 60;</p><p>  pid_t pid = fork();</p><p>  if ( pid &lt; 0 )  {</p><p>​    perror( “fork error.” );</p><p>​    exit(1);</p><p>  }</p><p>  if ( pid == 0 ) {</p><p>​    printf( “This is the child process. My PID is: %d. My PPID is: %d\n”, getpid(), getppid() );</p><p>  }</p><p>  if (pid &gt; 0)   {</p><p>​    printf( “This is the parent process. My PID is %d.\n”, getpid() );</p><p>​    for( ; i &gt; 0; i– ) {</p><p>​      sleep(1);</p><p>​    }</p><p>  }</p><p>  return 0;</p><p>}</p></blockquote><p>&emsp;&emsp;编译 zombie.c 并执行 zombie：</p><blockquote><p>yum install gcc</p><p>gcc zombie.c -o zombie</p><p>./ zombie</p></blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210912205239556.png" srcset="/img/loading.gif" lazyload alt="image-20210912205239556"></p><p>&emsp;&emsp;上图中主进程 PID：11552，子进程 PID：11553。执行如下语句：发现 PID 为 11553 的子进程正好处于僵尸状态（defunct），由程序可知，因为主进程并没有 wait 子进程。</p><blockquote><p>ps aux | grep -i defunct</p></blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210912205249036.png" srcset="/img/loading.gif" lazyload alt="image-20210912205249036"></p><p>&emsp;&emsp;分析一下 zombie.c，特别注意 fork() 调用，在 pid_t pid = fork()  语句之前，只有一个进程，但是执行到这条语句之后，就变成2个进程了，这2个进程几乎完全相同，将要执行的下一条语句都是 if ( pid &lt; 0 )。</p><p>&emsp;&emsp;fork() 函数比较特殊，它被调用一次，却能够返回两次结果，它的返回值也根据进程的不同而不同：</p><blockquote><p>1）在父进程中，fork 返回新创建子进程的 PID</p><p>\2) 在子进程中，fork 返回 0</p><p>3）如果出现错误，则 fork 返回负值</p></blockquote><h2 id="2-3-僵尸进程危害"><a href="#2-3-僵尸进程危害" class="headerlink" title="2.3 僵尸进程危害"></a>2.3 僵尸进程危害</h2><p>&emsp;&emsp;如果父进程没有 wait 子进程，子进程将变成僵尸状态，处于僵尸状态的进程将保留进程号（PID），众所周知，操作系统对进程号是有限制的，如果出现大量僵尸进程占用进程号，系统有可能无法创建新的进程。</p><h1 id="3-处理僵尸进程"><a href="#3-处理僵尸进程" class="headerlink" title="3 处理僵尸进程"></a>3 处理僵尸进程</h1><p>&emsp;&emsp;一般情况下处于僵尸状态的进程很难杀掉，当然你可以试着删除：</p><h1 id="3-1-kill-命令"><a href="#3-1-kill-命令" class="headerlink" title="3.1 kill 命令"></a>3.1 kill 命令</h1><blockquote><p>kill -9 PID</p></blockquote><h2 id="3-2-kill-父进程"><a href="#3-2-kill-父进程" class="headerlink" title="3.2 kill 父进程"></a>3.2 kill 父进程</h2><blockquote><p>kill -9 PPID</p></blockquote><h2 id="3-3-reboot"><a href="#3-3-reboot" class="headerlink" title="3.3 reboot"></a>3.3 reboot</h2><p>&emsp;&emsp;如果采用上面两种方式依然杀不掉，那么只能通过重启了。</p><blockquote><p>reboot</p></blockquote><p>&emsp;&emsp;如果重启也不生效，可以需要加选项 -nf</p><blockquote><p>reboot -nf</p></blockquote><h2 id="3-4-magic-sysrq-key-方法"><a href="#3-4-magic-sysrq-key-方法" class="headerlink" title="3.4 magic sysrq key 方法"></a>3.4 magic sysrq key 方法</h2><p>&emsp;&emsp;有时执行 reboot 命令还是无法重启，可以执行 magic sysrq 方法来通过提供给用户的 proc 接口直接向 kernel 发底层命令。</p><p>&emsp;&emsp;重启命令如下：</p><blockquote><p>echo 1 &gt; /proc/sys/kernel/sysrq</p><p>echo b &gt; /proc/sysrq-trigger</p></blockquote><p>&emsp;&emsp;强制关机命令：</p><blockquote><p>echo 1 &gt; /proc/sys/kernel/sysrq</p><p>echo b &gt; /proc/sysrq-trigger</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>zombie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Vagrant</title>
    <link href="/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Vagrant/"/>
    <url>/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Vagrant/</url>
    
    <content type="html"><![CDATA[<p>1 vagrant 介绍</p><p>2 vagrant 下载安装</p><p>3 virtualbox 下载安装</p><p>4 vagrant 初始化</p><p>5 vagrant 启动</p><p>6 vagrant 登录虚拟机</p><p>7 vagrant 退出虚拟机</p><p>8 vagrant 查看状态</p><p>9 vagrant 停止虚拟机</p><p>10 vagrant 卸载虚拟机</p><p>11 vagrant 文件</p><p>12 vagrant centos 认证信息</p><hr><h1 id="1-vagrant-介绍"><a href="#1-vagrant-介绍" class="headerlink" title="1 vagrant 介绍"></a>1 vagrant 介绍</h1><p>&emsp;&emsp;我不知道新时代的IT从业者是否真得幸福。因为自从他们踏入IT圈的那刻起，很多都是唾手可得的。</p><p>&emsp;&emsp;我还清晰地记得第一次安装linux的情景，犹如初恋般刻骨铭心。那是一个月黑风高的夜晚，当我把从卖盗版盘小贩那里买来的 redhat 插入到光驱，机箱中传来类似飞机起飞的呼啸声时，我的心是多么得热血澎湃。</p><p>&emsp;&emsp;我还记得也就是在同一天，一个广州中山大学医学研究生的女同学来杭州找我。她对我柔情蜜意，极尽挑逗魅惑之能事……</p><p>&emsp;&emsp;好吧，我们还是说回 vagrant 吧。</p><p>&emsp;&emsp;众所周知，maven 是包管理工具，负责 jar 包的下载、上传、包之间依赖关系等。 yum、apt  是程序管理工具，负责二进制程序的下载、安装、删除等。vagrant的管理对象则更猛一点，是虚拟机环境。它负责操作系统的镜像下载、把操作系统镜像安装进虚拟机、启动虚拟机运行操作系统、停止虚拟机等。</p><p>&emsp;&emsp;vagrant 跟 vbox、vmware有什么区别呢？首先 vagrant 并不是虚拟机，其次，它必须要结合虚拟机使用。vagrant  可以基于简单的命令来管理和操作虚拟机中的操作系统环境。有了 vagrant，你不必再像我一样从卖光盘小贩那里买 redhat  了，当然你还可以买其他的，比如日本爱情电影。</p><hr><h1 id="2-vagrant-下载安装"><a href="#2-vagrant-下载安装" class="headerlink" title="2 vagrant 下载安装"></a>2 vagrant 下载安装</h1><p>&emsp;&emsp;可以查看 vagrant 的官方下载<a href="https://www.vagrantup.com/downloads.html"> 网址</a>。再次强调，vagrant 只是一个工具，一个二进制程序包，它本身并不是操作系统。你首先需要下载和安装适合自己操作系统的 vagrant，然后才可以使用它来下载操作系统镜像和其他更强大的功能。</p><hr><h1 id="3-virtualbox-下载安装"><a href="#3-virtualbox-下载安装" class="headerlink" title="3 virtualbox 下载安装"></a>3 virtualbox 下载安装</h1><p>&emsp;&emsp;virgrant 支持多种虚拟机。这里选择 virtualbox，是因为免费和体积小。可以查看 virtualbox 的官方下载<a href="https://www.virtualbox.org/wiki/Downloads"> 网址</a>。</p><h1 id="4-vagrant-初始化"><a href="#4-vagrant-初始化" class="headerlink" title="4 vagrant 初始化"></a>4 vagrant 初始化</h1><hr><p>&emsp;&emsp;在下载安装了 virtualbox 和 vagrant 之后，我们就可以来初始化 vagrant 了。首先验证 vagrant 是否安装成功。</p><blockquote><p>vagrant version</p></blockquote><p>&emsp;&emsp;验证成功之后，下一步我们来初始化一个 centos7 的操作系统环境。执行如下语句：</p><blockquote><p>sudo vagrant init centos/7</p></blockquote><p>&emsp;&emsp;命令执行结果生成了一个 Vagrantfile 文件。该文件就是一份环境清单，里面记录了你需要什么操作系统，以及运行该操作系统的网络、内存等配置信息，你可以根据自己的需要做相应的调整。当然如果只是学习和试用，可以保持默认而不做任何改动。</p><hr><h1 id="5-vagrant-启动"><a href="#5-vagrant-启动" class="headerlink" title="5 vagrant 启动"></a>5 vagrant 启动</h1><p>&emsp;&emsp;完成了 vagrant 的初始化工作之后，就可以启动 vagrant 了。命令如下：</p><blockquote><p>sudo vagrant up</p></blockquote><p>&emsp;&emsp;启动过程有2个环节：检查本地是否有 centos7 的镜像，如果没有，则在线下载；如果有，则直接启动运行。当然很多情况下，第一次的经验都不会特别愉悦，vagrant  也不例外，毕竟下载个操作系统镜像真不是分分钟的事情。所以你唯一能做的就是等待，你可以去打个球、约个会什么的，应该不会有啥影响。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210912204630822.png" srcset="/img/loading.gif" lazyload alt="image-20210912204630822"></p><hr><h1 id="6-vagrant-登录虚拟机"><a href="#6-vagrant-登录虚拟机" class="headerlink" title="6 vagrant 登录虚拟机"></a>6 vagrant 登录虚拟机</h1><p>&emsp;&emsp;启动完虚拟机，你就可以愉快地登录它，感受它，搓揉它了。是不是很兴奋，很想尖叫？</p><blockquote><p>sudo vagrant ssh</p></blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210912204659101.png" srcset="/img/loading.gif" lazyload alt="image-20210912204659101"></p><hr><h1 id="7-vagrant-logout-虚拟机"><a href="#7-vagrant-logout-虚拟机" class="headerlink" title="7 vagrant logout 虚拟机"></a>7 vagrant logout 虚拟机</h1><p>&emsp;&emsp;如果你只是想暂时 logout，而不是关闭虚拟机的话，只需要在 centos7 命令行下输入 <strong>exit</strong> 即可。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210912204723705.png" srcset="/img/loading.gif" lazyload alt="image-20210912204723705"></p><hr><h1 id="8-vagrant-查看状态"><a href="#8-vagrant-查看状态" class="headerlink" title="8 vagrant 查看状态"></a>8 vagrant 查看状态</h1><p>&emsp;&emsp;当你 logout 出虚拟机时，可以通过如下命令查看当前虚拟机的运行状态。</p><blockquote><p>sudo vagrant status</p></blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210912204735344.png" srcset="/img/loading.gif" lazyload alt="image-20210912204735344"></p><hr><h1 id="9-vagrant-停止虚拟机"><a href="#9-vagrant-停止虚拟机" class="headerlink" title="9 vagrant 停止虚拟机"></a>9 vagrant 停止虚拟机</h1><p>&emsp;&emsp;可以使用 halt 命令来停止虚拟机。</p><blockquote><p>sudo vagrant halt</p></blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210912204747168.png" srcset="/img/loading.gif" lazyload alt="image-20210912204747168"></p><hr><h1 id="10-vagrant-卸载虚拟机"><a href="#10-vagrant-卸载虚拟机" class="headerlink" title="10 vagrant 卸载虚拟机"></a>10 vagrant 卸载虚拟机</h1><blockquote><p>sudo vagrant destroy</p></blockquote><p>&emsp;&emsp;别担心，这里只是删除了虚拟机而已，并没有删除掉你辛苦下载下来的 centos 镜像。所以尽情地试验吧。对待技术，就是要猛操啊。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210912204759346.png" srcset="/img/loading.gif" lazyload alt="image-20210912204759346"></p><hr><h1 id="11-vagrant-文件"><a href="#11-vagrant-文件" class="headerlink" title="11 vagrant 文件"></a>11 vagrant 文件</h1><p>&emsp;&emsp;vagrant 运行主要是依靠 Vagrant 文件。该文件就是 vagrant 的清单配置文件。它就像是 vagrant 的引擎，没有它，vagrant 将一事无成。<a href="https://app.vagrantup.com/"> vagrant cloud</a> 网站维护了很多清单配置文件。你可以根据自己的需要寻找自己心仪的环境。</p><hr><h1 id="12-vagrant-centos-认证信息"><a href="#12-vagrant-centos-认证信息" class="headerlink" title="12 vagrant centos 认证信息"></a>12 vagrant centos 认证信息</h1><p>&emsp;&emsp;vagrant 启动 centos 后的默认账户是 vagrant。如果要切换成 root 用户，默认的密码是：vagrant。</p><p>&emsp;&emsp;自此，你已经可以轻松完爆 vagrant 了。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vagrant</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - Envoy 架构概述</title>
    <link href="/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-Envoy-%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/"/>
    <url>/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-Envoy-%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 概述</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>&emsp;&emsp;如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1592970103347634.png" srcset="/img/loading.gif" lazyload alt="第四十五章 九析带你轻松完爆 Istio - Envoy 架构概述_envoy 视频"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>&emsp;&emsp;你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1592970111662295.png" srcset="/img/loading.gif" lazyload alt="第四十五章 九析带你轻松完爆 Istio - Envoy 架构概述_istio 视频_02"></p><hr><h1 id="3-Envoy-架构概述"><a href="#3-Envoy-架构概述" class="headerlink" title="3 Envoy 架构概述"></a>3 Envoy 架构概述</h1><p>&emsp;&emsp;下图展示了 Envoy 架构：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1592970136404676.png" srcset="/img/loading.gif" lazyload alt="第四十五章 九析带你轻松完爆 Istio - Envoy 架构概述_envoy 视频_03"></p><p>&emsp;&emsp;后面将根据这十个方面一一进行说明。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - Envoy 监听器简介</title>
    <link href="/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-Envoy-%E7%9B%91%E5%90%AC%E5%99%A8%E7%AE%80%E4%BB%8B/"/>
    <url>/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-Envoy-%E7%9B%91%E5%90%AC%E5%99%A8%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 上章总结</p><p>4 监听器</p><p>  4.1 TCP 监听器</p><p>  4.2 UDP 监听器</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>&emsp;&emsp;如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1593661295647236.png" srcset="/img/loading.gif" lazyload alt="第四十九章 九析带你轻松完爆 Istio - Envoy 监听器简介_Envoy 监听器"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>&emsp;&emsp;你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1593661302961492.png" srcset="/img/loading.gif" lazyload alt="第四十九章 九析带你轻松完爆 Istio - Envoy 监听器简介_Istio 视频_02"></p><hr><h1 id="3-上章总结"><a href="#3-上章总结" class="headerlink" title="3 上章总结"></a>3 上章总结</h1><p>&emsp;&emsp;上节介绍了 Envoy 的基础配置信息，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1593661310554278.png" srcset="/img/loading.gif" lazyload alt="第四十九章 九析带你轻松完爆 Istio - Envoy 监听器简介_Envoy 视频_03"></p><p>&emsp;&emsp;上面配置信息重点介绍了两块内容，管理信息（admin 部分）和静态配置信息（static_resources 部分）。管理信息包括 Envoy 的 web 管理控制台。在用 Docker  运行时可对外开放 9901 端口（并对所有客户端可见，即 address 为 0.0.0.0）。关于如何运行 Envoy  可参考我上一篇文章，轻松完爆就是。运行后的结果如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1593661537504319.png" srcset="/img/loading.gif" lazyload alt="第四十九章 九析带你轻松完爆 Istio - Envoy 监听器简介_Envoy 视频_04"></p><p>&emsp;&emsp;从上图可知，对外服务端口 9901 已经开启。打开浏览器访问，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1593661545300104.png" srcset="/img/loading.gif" lazyload alt="第四十九章 九析带你轻松完爆 Istio - Envoy 监听器简介_k8s 视频_05"></p><p>&emsp;&emsp;静态配置信息主要包括两部分内容，分别是监听器（listener，今天介绍的主角）和集群（cluster），如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1593661365273203.png" srcset="/img/loading.gif" lazyload alt="第四十九章 九析带你轻松完爆 Istio - Envoy 监听器简介_Envoy 监听器_06"></p><p>&emsp;&emsp;   listener 是 Envoy 对外提供的监听端口，默认 10000。客户端通过此端口可以与 Envoy  建立通讯，获取连接（connection）。此外，在监听器上还可设置过滤器链（filter_chains），链上设置多过滤器，这样的设置可保证对进入 Envoy 的网络流量（请求）进行相应的处理，比如：上图就设置了http 过滤器，即：进入 Envoy 的所有 http  网络流量，都将被路由到集群（clusters）配置中，在集群（clusters）配置了 http 网络流量最终流向端点（endpoints，即  baidu.com）。整个过程如图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1593661577790290.png" srcset="/img/loading.gif" lazyload alt="第四十九章 九析带你轻松完爆 Istio - Envoy 监听器简介_Envoy 教程_07"></p><hr><h1 id="4-监听器"><a href="#4-监听器" class="headerlink" title="4 监听器"></a>4 监听器</h1><p>&emsp;&emsp;Envoy 配置在单个进程中支持任意数量的监听器（listener）。Envoy 支持 TCP 和 UDP 的监听器。</p><h2 id="4-1-TCP-监听器"><a href="#4-1-TCP-监听器" class="headerlink" title="4.1 TCP 监听器"></a>4.1 TCP 监听器</h2><p>&emsp;&emsp;监听器上可以配置一系列的过滤器构成的链，并且根据匹配条件来选择某个链。单个过滤器链由一个或多个 L3 / L4 过滤器组成。当监听器上收到连接时，将选择匹配的过滤器链，实例化本地过滤器，并开始处理后续事件。这样通用的监听器体系架构设计使得 Envoy 可以执行绝大多数的代理任务（比如，速率限制、TLS 客户端身份认证、HTTP 连接管理、MongoDB 嗅探、原始 TCP  代理）等。</p><p>&emsp;&emsp;如上可知，监听器可以配置监听过滤器。这些过滤器在网络过滤器（以后会讲）之前进行处理。并且监听过滤器还可以操作连接（connection）的元数据，这通常会影响以后的过滤器（filter）、集群（cluster）如何处理该连接。</p><p>&emsp;&emsp;监听器也可以通过<a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/listeners/lds#config-listeners-lds"> 监听器发现服务（LDS）</a>动态获取。</p><p>&emsp;&emsp;有关监听器的详细配置，<a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/listeners/listeners#config-listeners"> 请点击这里</a>。</p><h2 id="4-2-UDP-监听器"><a href="#4-2-UDP-监听器" class="headerlink" title="4.2 UDP 监听器"></a>4.2 UDP 监听器</h2><p>&emsp;&emsp;Envoy 还支持 UDP 监听器，尤其是 UDP 监听器过滤器。每个监听器过滤器都会处理工作进程在监听器端口上监听的每个 UDP 数据报。实际上，UDP 监听器配置有 SO_REUSEPORT 内核选项（该选项作用是可以将多个进程绑定在同一个端口上），这将导致内核将每个 UDP  四元组一致地散列到同一个工作程序。如果需要，这可使 UDP 监听器过滤器面向“会话”。</p><p>&emsp;&emsp;自此，九析带你轻松完爆 Envoy 监听器简介，有关监听器更多的内容，请查看本人接下来的文章。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - Envoy 一分钟上手</title>
    <link href="/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-Envoy-%E4%B8%80%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8B/"/>
    <url>/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-Envoy-%E4%B8%80%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 简介</p><p>4 Envoy 下载</p><p>5 Envoy 运行</p><p>6 Envoy 访问</p><p>7 Envoy 窥视</p><p>8 Envoy 修改</p><p>  8.1 修改 envoy.yaml</p><p>  8.2 创建新 Envoy 镜像</p><p>  8.3 运行新 Envoy 镜像</p><p>  8.4 访问新 Envoy 容器</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>&emsp;&emsp;如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1593504118517590.png" srcset="/img/loading.gif" lazyload alt="第四十八章 九析带你轻松完爆 Istio - Envoy 一分钟上手_Envoy 教程"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>&emsp;&emsp;你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1593504125131340.png" srcset="/img/loading.gif" lazyload alt="第四十八章 九析带你轻松完爆 Istio - Envoy 一分钟上手_Istio 视频_02"></p><hr><h1 id="3-简介"><a href="#3-简介" class="headerlink" title="3 简介"></a>3 简介</h1><p>&emsp;&emsp;本小节使你快速上手 Envoy。在使用 Envoy 前，首先需要下载并运行它。有两种方式获取 Envoy：下载编译好的二进制包；直接下载 Envoy 的学习镜像。本文使用后者。</p><hr><h1 id="4-Envoy-下载"><a href="#4-Envoy-下载" class="headerlink" title="4 Envoy 下载"></a>4 Envoy 下载</h1><p>&emsp;&emsp;使用如下语句下载 Envoy 学习镜像：</p><blockquote><p>docker pull envoyproxy/envoy-dev:89d6c6c6fa202aa7a01e85d2d887b56c8a3268ad</p></blockquote><p>&emsp;&emsp;下载成功后的截图如下所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1593504133206795.png" srcset="/img/loading.gif" lazyload alt="第四十八章 九析带你轻松完爆 Istio - Envoy 一分钟上手_Envoy 教程_03"></p><hr><h1 id="5-Envoy-运行"><a href="#5-Envoy-运行" class="headerlink" title="5 Envoy 运行"></a>5 Envoy 运行</h1><p>&emsp;&emsp;使用如下语句运行 Envoy 学习镜像：</p><blockquote><p>docker run –rm -d -p 10000:10000 envoyproxy/envoy-dev:89d6c6c6fa202aa7a01e85d2d887b56c8a3268ad</p></blockquote><p>&emsp;&emsp;上述命令会对外开启 Envoy 监听器，监听器端口为 10000。Envoy 容器启动成功后，可以执行如下命令查看 envoy 对外暴露的端口：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1593504197389764.png" srcset="/img/loading.gif" lazyload alt="第四十八章 九析带你轻松完爆 Istio - Envoy 一分钟上手_Istio 视频_04"></p><hr><h1 id="6-Envoy-访问"><a href="#6-Envoy-访问" class="headerlink" title="6 Envoy 访问"></a>6 Envoy 访问</h1><p>&emsp;&emsp;使用如下语句来访问 Envoy 容器提供的 http 路由服务：</p><blockquote><p>curl -v <a href="http://localhost:10000/"> http://localhost:10000</a></p></blockquote><p>&emsp;&emsp;执行结果一般会出错，结果如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1593504205343342.png" srcset="/img/loading.gif" lazyload alt="第四十八章 九析带你轻松完爆 Istio - Envoy 一分钟上手_k8s 视频_05"></p><p>&emsp;&emsp;出错的原因是官方提供的 Envoy 学习镜像是将所有对该 Envoy 的 http 请求路由到美国一个知名的搜索引擎网站去，而这个网站你们都知道，但是一般情况下却都访问不了。</p><p>&emsp;&emsp;为了操作成功，需要做一定的调整，经过简单调整，你也可以对 Envoy 有比较深入的了解。</p><hr><h1 id="7-Envoy-窥视"><a href="#7-Envoy-窥视" class="headerlink" title="7 Envoy 窥视"></a>7 Envoy 窥视</h1><p>&emsp;&emsp;执行如下语句进入到 Envoy 容器内部：</p><blockquote><p>docker exec -it $(docker ps | grep -i envoy | awk ‘{print $1}’) /bin/bash</p></blockquote><p>&emsp;&emsp;进入到容器内部之后，执行 ps -ef 查看当前容器内部运行进程列表：</p><blockquote><p>ps -ef</p></blockquote><p>&emsp;&emsp;执行结果如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1593504215202328.png" srcset="/img/loading.gif" lazyload alt="第四十八章 九析带你轻松完爆 Istio - Envoy 一分钟上手_k8s 视频_06"></p><p>&emsp;&emsp;由上图可知 Envoy 启动时的配置文件 envoy.yaml，查看该文件内容如下所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1593504223604962.png" srcset="/img/loading.gif" lazyload alt="第四十八章 九析带你轻松完爆 Istio - Envoy 一分钟上手_Envoy start_07"></p><p>&emsp;&emsp;从上图中，我们可以看到基本 Envoy 配置包括两部分内容：</p><blockquote><p>admin：管理信息。配置管理服务器</p><p>static_resources: 静态配置内容。此配置包含 Envoy 启动时静态配置的所有内容，比如监听器（listener）和集群（clusters）。监听器里又配置了过滤器链（filter_chains）</p></blockquote><p>&emsp;&emsp;结论：整个 Envoy 启动都是根据 envoy.yaml 的配置。上图配置中，Envoy 对外服务监听端口是 10000，所有 http 请求都路由到 <a href="http://www.gxxgle.com./">www.gxxgle.com。</a></p><hr><h1 id="8-Envoy-修改"><a href="#8-Envoy-修改" class="headerlink" title="8 Envoy 修改"></a>8 Envoy 修改</h1><p>&emsp;&emsp;因为初始的学习配置，导致很多人无法成功访问的。我们可以修改 envoy.yaml 配置文件，改成路由到百度即可。</p><h2 id="8-1-修改-envoy-yaml"><a href="#8-1-修改-envoy-yaml" class="headerlink" title="8.1 修改 envoy.yaml"></a>8.1 修改 envoy.yaml</h2><p>&emsp;&emsp;执行如下语句将容器内的原始 envoy.yaml 配置文件拷贝到 docker 所在宿主机：</p><blockquote><p># 下面的 75f8e71991f2 代表运行的 envoy 容器</p><p>docker cp 75f8e71991f2:/etc/envoy/envoy.yaml ./</p></blockquote><p>&emsp;&emsp;编辑 envoy.yaml 文件如下：</p><blockquote><p>route:</p><p>host_rewrite: <a href="http://www.baidu.com/">www.baidu.com</a>    # 31行</p><p>socket_address:</p><p>address: <a href="http://www.baidu.com/">www.baidu.com</a>    # 49行</p><p>sni: <a href="http://www.baidu.com/">www.baidu.com</a>        # 55行</p></blockquote><p>&emsp;&emsp;修改内容如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1593504236339192.png" srcset="/img/loading.gif" lazyload alt="第四十八章 九析带你轻松完爆 Istio - Envoy 一分钟上手_Envoy 视频_08"></p><h2 id="8-2-创建新-Envoy-镜像"><a href="#8-2-创建新-Envoy-镜像" class="headerlink" title="8.2 创建新 Envoy 镜像"></a>8.2 创建新 Envoy 镜像</h2><p>&emsp;&emsp;首先编写 Dockerfile 文件，内容如下 ：</p><blockquote><p>FROM envoyproxy/envoy-dev:89d6c6c6fa202aa7a01e85d2d887b56c8a3268ad</p><p>COPY envoy.yaml /etc/envoy/envoy.yaml</p></blockquote><p>&emsp;&emsp;接着执行如下语句创建镜像：</p><blockquote><p>docker build -t envoy:v1 .</p></blockquote><p>&emsp;&emsp;然后执行如下语句查看是否镜像创建成功：</p><blockquote><p>docker images | grep -i envoy</p></blockquote><h2 id="8-3-运行新-Envoy-镜像"><a href="#8-3-运行新-Envoy-镜像" class="headerlink" title="8.3 运行新 Envoy 镜像"></a>8.3 运行新 Envoy 镜像</h2><p>&emsp;&emsp;执行如下语句运行新创建的镜像：</p><blockquote><p>docker run -d –name envoy -p 9901:9901 -p 10000:10000 envoy:v1</p></blockquote><h2 id="8-4-访问新-Envoy-容器"><a href="#8-4-访问新-Envoy-容器" class="headerlink" title="8.4 访问新 Envoy 容器"></a>8.4 访问新 Envoy 容器</h2><p>&emsp;&emsp;执行如下语句访问新 Envoy 容器：</p><blockquote><p>curl <a href="http://localhost:10000/"> http://localhost:10000</a></p></blockquote><p>&emsp;&emsp;执行效果如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1593504248859976.png" srcset="/img/loading.gif" lazyload alt="第四十八章 九析带你轻松完爆 Istio - Envoy 一分钟上手_k8s 视频_09"></p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - Envoy 线程模型</title>
    <link href="/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-Envoy-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <url>/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-Envoy-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 Envoy 线程模型</p><p>4 监听器连接负载均衡</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>&emsp;&emsp;如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1593409130289324.png" srcset="/img/loading.gif" lazyload alt="第四十七章 九析带你轻松完爆 Istio - Envoy 线程模型_Istio 视频"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>&emsp;&emsp;你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1593409138244915.png" srcset="/img/loading.gif" lazyload alt="第四十七章 九析带你轻松完爆 Istio - Envoy 线程模型_Envoy 视频_02"></p><hr><h1 id="3-Envoy-线程模型"><a href="#3-Envoy-线程模型" class="headerlink" title="3 Envoy 线程模型"></a>3 Envoy 线程模型</h1><p>&emsp;&emsp;Envoy 是单进程内包含多线程的架构设计。单进程内部包含两种线程-主线程（master thread）和工作线程（worker thread）。主线程的作用是控制、协调任务；工作线程的作用是执行监听、过滤和转发。如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1593409156694519.png" srcset="/img/loading.gif" lazyload alt="第四十七章 九析带你轻松完爆 Istio - Envoy 线程模型_Envoy 视频_03"></p><p>&emsp;&emsp;Envoy 进程启动时会开启监听端口（listener），一旦监听器接受了客户端的连接，此连接的生命周期就会绑定到 Envoy  内的一个工作线程上。由此可知，Envoy 被设计成多个单线程并行，100%  无阻塞的模式。对于大多数工作负载，我们建议将工作线程的数量配置为等于计算机上硬件线程的数量。查看 Linux 操作系统最大进程数命令为：</p><blockquote><p>sysctl kernel.pid_max 或 cat /proc/sys/kernel/pid_max</p></blockquote><hr><h1 id="4-监听器连接负载均衡"><a href="#4-监听器连接负载均衡" class="headerlink" title="4 监听器连接负载均衡"></a>4 监听器连接负载均衡</h1><p>&emsp;&emsp;默认情况下，Envoy  工作线程之间相互独立且并无联系，这意味着所有工作线程都独立尝试在监听器上接受连接，并依靠内核在线程之间做负载均衡。对于大多数工作负载，内核对这些连接的负载均衡处理会非常出色。但是，对于某些工作负载（例如，服务网格 HTTP2 / gRPC 出口），必须强制 Envoy 在工作线程和连接之间负载均衡，为了支持上述特性，Envoy  允许在其监听端口上针对连接设置不同种类的负载均衡策略。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - Envoy 介绍</title>
    <link href="/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-Envoy-%E4%BB%8B%E7%BB%8D/"/>
    <url>/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-Envoy-%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 Envoy 介绍</p><p>4 Envoy 特性</p><p>  4.1 自包含</p><p>  4.2 C++ 11 代码库</p><p>  4.3 L3 / L4 过滤器体系架构</p><p>  4.4 HTTP L7 过滤器体系架构</p><p>  4.5 HTTP / 2 支持</p><p>  4.6 MongoDB &amp; DynamoDB L7 支持</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>&emsp;&emsp;如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1592483307304493.png" srcset="/img/loading.gif" lazyload alt="第四十四章 九析带你轻松完爆 Istio - Envoy 介绍_envoy"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>&emsp;&emsp;你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1592483316585445.png" srcset="/img/loading.gif" lazyload alt="第四十四章 九析带你轻松完爆 Istio - Envoy 介绍_Istio 视频_02"></p><hr><h1 id="3-Envoy-介绍"><a href="#3-Envoy-介绍" class="headerlink" title="3 Envoy 介绍"></a>3 Envoy 介绍</h1><p>&emsp;&emsp;Envoy 是类似 Nginx 的网络边缘代理工具，是专为大型现代微服务架构而设计的。</p><p>&emsp;&emsp;下图是 Nginx 使用场景：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1592483325727030.png" srcset="/img/loading.gif" lazyload alt="第四十四章 九析带你轻松完爆 Istio - Envoy 介绍_Istio 视频_03"></p><p>&emsp;&emsp;上图中，Nginx 作为边缘代理，是整个网络流量的入口。通过配置 Nginx，可将访问者请求路由到后端 Server 内的 Service  进行处理。但是问题来了，如果我们想控制 Service A 和 Service B 之间的流量就没有办法了，因为它们之间并没有任何边缘代理。</p><p>&emsp;&emsp;下图是 Envoy 使用场景：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1592483333452261.png" srcset="/img/loading.gif" lazyload alt="第四十四章 九析带你轻松完爆 Istio - Envoy 介绍_envoy_04"></p><p>&emsp;&emsp;上图中，Envoy 不但作为边缘代理（类似  Nginx）是整个网络流量的入口，同时也可以作为服务（service）代理。这样的网络拓补结构不但可以设置访问者路由规则，也可以设置  service A 与 Service B 之间的路由规则。因此，这样就可以全方位控制微服务内部到内部、外部到内部的所有网络流量，而上图中  Nginx 仅仅控制由外到内的网络流量。</p><hr><h1 id="4-Envoy-特性"><a href="#4-Envoy-特性" class="headerlink" title="4 Envoy 特性"></a>4 Envoy 特性</h1><h2 id="4-1-自包含"><a href="#4-1-自包含" class="headerlink" title="4.1 自包含"></a>4.1 自包含</h2><p>&emsp;&emsp;Envoy 是自包含的设计，它和应用服务器各自独立运行，并不对服务器内的应用进行侵入。这样设计的好处在于可以支持任何语言、任何框架所编写的微服务。此外，正因为自包含、无侵入的设计可以使得升级或部署更透明和高效</p><h2 id="4-2-C-11-代码库"><a href="#4-2-C-11-代码库" class="headerlink" title="4.2 C++ 11 代码库"></a>4.2 C++ 11 代码库</h2><p>&emsp;&emsp;Envoy 是基于 C++ 11 代码库进行编写的，因为 C++ 11 跟其他编程语言相比，既提供了出色的性能，又大大提高了开发人员的生产力。</p><h2 id="4-3-L3-L4-过滤器体系架构"><a href="#4-3-L3-L4-过滤器体系架构" class="headerlink" title="4.3 L3 / L4 过滤器体系架构"></a>4.3 L3 / L4 过滤器体系架构</h2><p>&emsp;&emsp;Envoy 的设计采用过滤器的体系架构。它通过原生或者自定义的过滤器来执行不同的 TCP 代理任务。已经提供的原生过滤器包括原始 TCP 代理、HTTP 代理、TLS 客户端证书认证等。</p><h2 id="4-4-HTTP-L7-过滤器体系架构"><a href="#4-4-HTTP-L7-过滤器体系架构" class="headerlink" title="4.4 HTTP L7 过滤器体系架构"></a>4.4 HTTP L7 过滤器体系架构</h2><p>&emsp;&emsp;Envoy 除了在 L3、L4 提供过滤器外，还在 L7 提供了 HTTP 过滤器，可以提供诸如缓冲、速率限制、路由/转发等功能。</p><h2 id="4-5-HTTP-2-支持"><a href="#4-5-HTTP-2-支持" class="headerlink" title="4.5 HTTP / 2 支持"></a>4.5 HTTP / 2 支持</h2><p>&emsp;&emsp;在 HTTP 模式下运行时，Envoy 支持 HTTP / 1.1 和 HTTP / 2。这就意味着可以桥接 HTTP / 1.1 和 HTTP / 2 客户端与目标服务器的任何组合。</p><h2 id="4-6-MongoDB-amp-DynamoDB-L7-支持"><a href="#4-6-MongoDB-amp-DynamoDB-L7-支持" class="headerlink" title="4.6 MongoDB &amp; DynamoDB L7 支持"></a>4.6 MongoDB &amp; DynamoDB L7 支持</h2><p>&emsp;&emsp;Envoy 支持 MongoDB 和 DynamoDB 连接的 L7 嗅探和统计信息生成。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - 安全之加密三</title>
    <link href="/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8A%A0%E5%AF%86%E4%B8%89/"/>
    <url>/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8A%A0%E5%AF%86%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 加密简介</p><p>4 非对称加密介绍</p><p>5 非对称加密原理</p><p>6 SSL / TLS 与非对称加密</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>&emsp;&emsp;如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1591602918289392.png" srcset="/img/loading.gif" lazyload alt="第四十二章 九析带你轻松完爆 Istio - 安全之加密三_Istio security"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>&emsp;&emsp;你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1591602926907711.png" srcset="/img/loading.gif" lazyload alt="第四十二章 九析带你轻松完爆 Istio - 安全之加密三_Istio 安全_02"></p><hr><h1 id="3-加密简介"><a href="#3-加密简介" class="headerlink" title="3 加密简介"></a>3 加密简介</h1><p>&emsp;&emsp;加密是基础，是安全绕不开的话题。常用的加密方式有三种，分别为哈希、对称加密和非对称加密。上节我们重点介绍了 Hash 和对称密钥加密，这节介绍一下非对称密钥加密。</p><hr><h1 id="4-非对称加密介绍"><a href="#4-非对称加密介绍" class="headerlink" title="4 非对称加密介绍"></a>4 非对称加密介绍</h1><p>&emsp;&emsp;在上节中介绍了对称加密。在对称加密中，相同的密钥用于加密和解密，一旦密钥被偷，所有数据将无任何安全可言。因此新的加密算法需求被提出，所幸的是业界很快就有了解决方案。</p><p>&emsp;&emsp;1976 年，Diffie、Hellman 首次提出非对称加密概念。</p><p>&emsp;&emsp;1978 年，麻省理工三人组 Rivest、Shamir、Adleman 发布了 RSA 算法。</p><p>&emsp;&emsp;自此，非对称加密开始正式走向历史舞台。</p><hr><h1 id="5-非对称加密原理"><a href="#5-非对称加密原理" class="headerlink" title="5 非对称加密原理"></a>5 非对称加密原理</h1><p>&emsp;&emsp;非对称加密跟对称加密相比有两个关注点，而不是一个。除了加密算法本身，还需要一对公私钥。其中公钥用来加密、私钥用来解密。在启动通信过程中，首先生成一对公私钥，</p><p>&emsp;&emsp;公钥发送给对方，私钥则需要妥善保管。对方通过公钥对信息进行加密（加密算法会在公钥中指定），当你收到信息，就用保管好的私钥进行解密。</p><p>&emsp;&emsp;加密过程如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1592359257398290.png" srcset="/img/loading.gif" lazyload alt="第四十二章 九析带你轻松完爆 Istio - 安全之加密三_Istio 视频_03"></p><p>&emsp;&emsp;解密过程如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1592359474532732.png" srcset="/img/loading.gif" lazyload alt="第四十二章 九析带你轻松完爆 Istio - 安全之加密三_Istio 安全_04"></p><hr><h1 id="6-SSL-TLS-与非对称加密"><a href="#6-SSL-TLS-与非对称加密" class="headerlink" title="6 SSL / TLS 与非对称加密"></a>6 SSL / TLS 与非对称加密</h1><p>&emsp;&emsp;在本节介绍中，非对称加密显示出了它的安全优势，即：只要保持私钥安全，数据就是安全的。如果再结合前面的教程知道，SSL / TLS 是构建在传输层和应用层之间的虚拟层，这层主要负责数据安全。那么将非对称加密算法作为 SSL / TLS  的唯一性算法就是整个数据通路的安全解决方案了，但现实是这样的吗？答案是否定的。因为现实仍然是在 SSL / TLS  层主要使用对称加密，原因在于：双密钥架构的加密、解密开销非常高，与对称密钥相比，它需要更多的时间和 CPU  占有率，这就意味着在互联网使用非常频繁的今天，如果只通过非对称加密进行通信，那么浏览器和服务器之间数据通信会让用户等待更长的时间。</p><p>&emsp;&emsp;因此在 SSL / TLS 层经常的做法是双密钥机制在客户端和服务器交换对称密钥时才使用，此过程建立之后，客户端和服务端通信就按照对称加密进行。至于整个操作如何进行，将在后续课程中一一指出。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - 安全之加密二</title>
    <link href="/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8A%A0%E5%AF%86%E4%BA%8C/"/>
    <url>/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8A%A0%E5%AF%86%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 加密简介</p><p>4 对称秘钥加密</p><p>5 对称秘钥不足</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>&emsp;&emsp;如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1591588745379409.png" srcset="/img/loading.gif" lazyload alt="第四十一章 九析带你轻松完爆 Istio - 安全之加密二_Istio 安全"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>&emsp;&emsp;你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1591588753179092.png" srcset="/img/loading.gif" lazyload alt="第四十一章 九析带你轻松完爆 Istio - 安全之加密二_Istio security_02"></p><hr><h1 id="3-加密简介"><a href="#3-加密简介" class="headerlink" title="3 加密简介"></a>3 加密简介</h1><p>&emsp;&emsp;加密是基础，是安全绕不开的话题。常用的加密方式有三种，分别为哈希、对称加密和非对称加密。上节我们重点介绍了 Hash，这节介绍一下对称密钥加密。</p><hr><h1 id="4-对称密钥加密"><a href="#4-对称密钥加密" class="headerlink" title="4  对称密钥加密"></a>4  对称密钥加密</h1><p>&emsp;&emsp;古罗马军事家凯撒大帝一生征战无数，鲜有敌手，除了卓越的军事才能之外，他对军事信息的流通和保护也特别重视，凯撒密码就是体现之一。据传，凯撒曾用此方法与其将军们进行联系。</p><p>&emsp;&emsp;凯撒密码的原理非常简单，就是将明文中的所有字母在字母表上向后（或向前）按照一个固定数目（步长）进行偏移，比如明文是 “abc”，偏移量为 3，就变成了新的字符串 “def”，其中偏移量 3 就是加密密钥（对称密钥），而字符串 “def”  就是密文。如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1591588767107074.png" srcset="/img/loading.gif" lazyload alt="第四十一章 九析带你轻松完爆 Istio - 安全之加密二_Istio security_04"></p><hr><h1 id="5-对称密钥不足"><a href="#5-对称密钥不足" class="headerlink" title="5  对称密钥不足"></a>5  对称密钥不足</h1><p>&emsp;&emsp;凯撒密码会有很多问题，这种算法很容易被破解。可以将密钥的值从 1 更改为任何值，并逐个轮询 26 个字母。如果使用计算机，破解几毫秒就搞定了。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1591588781156241.png" srcset="/img/loading.gif" lazyload alt="第四十一章 九析带你轻松完爆 Istio - 安全之加密二_Istio 免费视频_05"></p><p>&emsp;&emsp;如今，比较安全的对称密钥算法是 AES（高级加密标准）和 3DES（三重数据加密算法）。它们都被公认为很难破解。</p><p>&emsp;&emsp;即使密码再难破解，但如果偷窃者在信息交换双方共享密钥时捕获了密钥，一样会造成信息泄露。因此，就需要一种更为安全的机制来交换密码，而不让偷窃者真正看到它。这就是后文将要介绍的非对称加密算法。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - 安全之加密</title>
    <link href="/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8A%A0%E5%AF%86/"/>
    <url>/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8A%A0%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 加密简介</p><p>4  Hash</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>&emsp;&emsp;如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1591356282457280.png" srcset="/img/loading.gif" lazyload alt="第四十章 九析带你轻松完爆 Istio - 安全之加密_Istio 免费视频。"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>&emsp;&emsp;你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1591356289184711.png" srcset="/img/loading.gif" lazyload alt="第四十章 九析带你轻松完爆 Istio - 安全之加密_Istio 免费视频。_02"></p><hr><h1 id="3-加密简介"><a href="#3-加密简介" class="headerlink" title="3 加密简介"></a>3 加密简介</h1><p>&emsp;&emsp;加密是基础，是安全绕不开的话题。常用的加密方式有三种，分别为哈希、对称加密和非对称加密。下面分别进行介绍。</p><hr><h1 id="4-Hash"><a href="#4-Hash" class="headerlink" title="4  Hash"></a>4  Hash</h1><p>&emsp;&emsp;哈希（Hash），又称散列，是数据无法恢复的一项加密技术。比如字符串 “qingsongwanbao” 经过 md5 加密后的结果就是 “a90d298c15992ad107dfafca1f1deb9c”。如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1591356351862148.png" srcset="/img/loading.gif" lazyload alt="第四十章 九析带你轻松完爆 Istio - 安全之加密_Istio 加密_04"></p><p>&emsp;&emsp;哈希后的结果一般情况下是不可逆的，也就是说无法根据 “a90d298c15992ad107dfafca1f1deb9c” 根据算法推导出 “qingsongwanbao”  。哈希经常的使用场景是密码。用户注册网站会员，在保存密码时就可以使用哈希，这样做即使数据库泄露，哈希后的密码被黑客获取，仍然无法推导出用户的明文密码。过程如下图所示：</p><p>&emsp;&emsp;用户注册：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1591356359876615.png" srcset="/img/loading.gif" lazyload alt="第四十章 九析带你轻松完爆 Istio - 安全之加密_Istio 加密_06"></p><p>&emsp;&emsp;数据库被黑，用户名（hongxing）和散列后密码（5ea79ec42b3c05ec3b530276d83b3961）被盗，黑客通过盗取的用户名、散列后的密码登录，散列后的密码会再经过 Hash 变成一个新的密码值，此时就无法跟数据库原先的信息进行匹配，进而无法通过鉴权，也就无法登录网站和进行下一步操作。</p><p>Hash 还常用在网站的 cookie 里，如下所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1591356369229019.png" srcset="/img/loading.gif" lazyload alt="第四十章 九析带你轻松完爆 Istio - 安全之加密_Istio 免费视频。_07"></p><p>&emsp;&emsp;常用的 Hash 算法有：md5、sha256、sha512 等。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - SSL 与 TLS 简介</title>
    <link href="/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-SSL-%E4%B8%8E-TLS-%E7%AE%80%E4%BB%8B/"/>
    <url>/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-SSL-%E4%B8%8E-TLS-%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 SSL / TLS 介绍</p><p>4 SSL / TLS 作用</p><p>5 SSL / TLS 历史</p><p>6 SSL / TLS 样例</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>&emsp;&emsp;如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1591183354270680.png" srcset="/img/loading.gif" lazyload alt="第三十九章 九析带你轻松完爆 Istio - SSL 与 TLS 简介_Istio 教程"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>&emsp;&emsp;你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1591183361270330.png" srcset="/img/loading.gif" lazyload alt="第三十九章 九析带你轻松完爆 Istio - SSL 与 TLS 简介_Istio 视频_02"></p><hr><h1 id="3-SSL-TLS-介绍"><a href="#3-SSL-TLS-介绍" class="headerlink" title="3 SSL / TLS 介绍"></a>3 SSL / TLS 介绍</h1><p>&emsp;&emsp;对朋友有一个遗憾，至今都感到愧疚。</p><p>&emsp;&emsp;他曾是我初中的一个好友，在那个情窦初开的年级，他无可救药地爱上了一个女孩。他一直纠结到底该不该表白，无数个夜里，他鼻涕一把泪一把向我诉说对她的思念。我实在厌烦他的婆妈，于是便敷衍他，要是实在害羞不敢面对，那就干脆写个纸条，我代为转交。他想了想，加上我不停地怂恿和酒精的作用，他就照办了。纸条写好后，他郑重其事封装好交道我手中。</p><p>&emsp;&emsp;我拿着他的信回到家，想都没想就打开了，上面只有一行字：“我爱你”。我看了看，然后加了两个字“妹妹”。</p><p>&emsp;&emsp;结果我的朋友被骂了三年流氓，直到他初中毕业。因为那个女孩的妹妹才10岁。</p><p>&emsp;&emsp;好吧，这一切都是我瞎掰的，为的就是解释 SSL / TLS。</p><p>&emsp;&emsp;SSL / TLS 就是为了解决端到端通讯的信息泄露以及篡改等安全问题。它位于传输层和应用层之间。应用层的数据是明文，传输层解决的是端到端的数据可到达，而 SSL / TLS 层则处理明文数据在传递过程中的安全和可靠。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1591183384588435.png" srcset="/img/loading.gif" lazyload alt="第三十九章 九析带你轻松完爆 Istio - SSL 与 TLS 简介_Istio 安全_03"></p><hr><h1 id="4-SSL-TLS-作用"><a href="#4-SSL-TLS-作用" class="headerlink" title="4 SSL / TLS 作用"></a>4 SSL / TLS 作用</h1><p>&emsp;&emsp;SSL / TLS 主要解决三个网络问题：</p><blockquote><p>保密：所有通信信息通过加密处理，防止第三方嗅探</p><p>完整：通过 MAC 校验机制，一旦被篡改，通信双方会立刻发现</p><p>认证：双方认证，双方都可以配备证书，防止身份被冒充</p></blockquote><p>&emsp;&emsp;就像我们经常看到的谍战片，不相识的特工见面首先都会拿本书或者花（认证），双方对话都是云里雾里的话（加密），谈话内容一旦出现偏差立刻会有所警觉（完整）。</p><hr><h1 id="5-SSL-TLS-历史"><a href="#5-SSL-TLS-历史" class="headerlink" title="5 SSL / TLS 历史"></a>5 SSL / TLS 历史</h1><blockquote><p>1995 年，SSL 2.0，NetScape 提出。后因为安全问题废弃。</p><p>1996 年，SSL 3.0，也因为安全问题必须禁用。</p><p>1999 年，TLS 1.0，互联网标准化组织接替 NetScape 公司，发布了 SSL 3.0 升级版 TLS 1.0。</p><p>2006 年，TLS 1.1 发布。</p><p>2008 年，TLS 1.2 发布。目前主要使用该版本。</p><p>2018 年，TLS 1.3 发布。</p></blockquote><p>&emsp;&emsp;总结如下：</p><blockquote><p>SSL 2.0 -&gt; SSL 3.0 -&gt; TLS 1.0 -&gt; TLS 1.1 -&gt; TLS 1.2 -&gt; TLS 1.3</p></blockquote><hr><h1 id="6-SSL-TLS-样例"><a href="#6-SSL-TLS-样例" class="headerlink" title="6 SSL / TLS 样例"></a>6 SSL / TLS 样例</h1><p>&emsp;&emsp;curl 工具支持多种安全层协议，我们可以通过 –help 进行查看，截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1591183398580008.png" srcset="/img/loading.gif" lazyload alt="第三十九章 九析带你轻松完爆 Istio - SSL 与 TLS 简介_Istio security_04"></p><p>&emsp;&emsp;下面可以针对多种协议进行访问：</p><blockquote><p>curl <a href="https://www.baidu.com/">https://www.baidu.com</a> –tlsv1.0</p><p>curl <a href="https://www.baidu.com/">https://www.baidu.com</a> –tlsv1.1</p><p>curl <a href="https://www.baidu.com/">https://www.baidu.com</a> –tlsv1.2</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - Fortio、Circuit breakers 断路器</title>
    <link href="/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-Fortio%E3%80%81Circuit-breakers-%E6%96%AD%E8%B7%AF%E5%99%A8/"/>
    <url>/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-Fortio%E3%80%81Circuit-breakers-%E6%96%AD%E8%B7%AF%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 Circuit breakers 断路器介绍</p><p>4 Circuit breakers 实例</p><p>  4.1 jiuxi-deploy.yaml</p><p>  4.2 jiuxi-svc.yaml</p><p>  4.3 jiuxi-dr.yaml</p><p>5 Circuit breakers 实例部署</p><p>  5.1 Istio 注入</p><p>  5.2 部署其他资源文件</p><p>6 验证断路器功能</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>&emsp;&emsp;如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590659334512568.png" srcset="/img/loading.gif" lazyload alt="第三十八章 九析带你轻松完爆 Istio - Fortio、Circuit breakers 断路器_Istio 教程"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>&emsp;&emsp;你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590659342792972.png" srcset="/img/loading.gif" lazyload alt="第三十八章 九析带你轻松完爆 Istio - Fortio、Circuit breakers 断路器_Istio circuits_02"></p><hr><h1 id="3-Circuit-breakers-断路器介绍"><a href="#3-Circuit-breakers-断路器介绍" class="headerlink" title="3 Circuit breakers 断路器介绍"></a>3 Circuit breakers 断路器介绍</h1><p>&emsp;&emsp;印象里，很多年前，居民区靠街有一种门面房。屋子不大，粉色的灯光，开放式的推拉门。门口总是坐着一个美丽的大姐姐，每当我从路边经过，她都会露出热情的微笑。“帅哥进来玩啊”。印象中，这是她经常对我说的话。</p><p>&emsp;&emsp;那时，我还很年轻，还很帅，我觉得她一定是不可救药地爱上我了，直到有一天我看到了我不愿意看到的一幕。</p><p>&emsp;&emsp;还记得是一个夏日的傍晚，我刚加班完回出租房，路上又经过了她的小屋，大老远就听到她温柔的声音：“帅哥来玩啊”。连日的工作劳累让我疲惫不堪，当我终于鼓足勇气准备接受她的邀请、迎接她的感情时，忽然从身后传来一个沙哑的声音：“来了”。我回头一看，原来是一个民工打扮的人。那一刻，我觉得自己像是被耍了一样，落荒而逃。</p><p>&emsp;&emsp;后来，我经常看到有民工模样的人走进那扇落地窗开拉门，有时有好几个，每当这个时候，我都会看到小姐姐会把开拉门从里面锁好，然后再把厚厚的窗帘放下……</p><p>&emsp;&emsp;慢慢地，当我社会阅历丰富，我终于知道了大姐姐的职业，为人民服务。</p><p>&emsp;&emsp;而记忆中的推拉门，竟是她一个弱女子面对这个世界的安全保障，是她对过载请求的一种天然防护，就像我经常使用的断路器一样。</p><p>&emsp;&emsp;断路器是 Istio 提供的一个有用的技术。在微服务设置断路器可以有效保障微服务的抗操性。比如在断路器中，你可以设置服务并发连接次数限制或者服务调用失败次数，一旦达到设置的阈值，断路器将“跳闸”并停止与该主机的进一步连接。</p><p>&emsp;&emsp;因为断路器适用于负载平衡池中“真正”的服务网格（Istio 资源注入后的 Pod），因此可以在 Destination Rule 配置断路器，而 Destination Rule 最终会被翻译成  Envoy 的配置，然后作用在 Envoy 上。这样当流量进入到被 Istio 注入后的 Pod，流量就会被 Envoy  拦截，这样断路器就会针对流量发生作用。</p><hr><h1 id="4-Circuit-breakers-实例"><a href="#4-Circuit-breakers-实例" class="headerlink" title="4 Circuit breakers 实例"></a>4 Circuit breakers 实例</h1><p>&emsp;&emsp;本实例用到 3 个资源文件：</p><blockquote><p># Istio 注入后的目标 Pod 资源</p><p>jiuxi-deploy.yaml    </p><p># Istio 目标规则文件</p><p>jiuxi-dr.yaml</p><p># Pod 资源的对外服务</p><p>jiuxi-svc.yaml</p></blockquote><h2 id="4-1-jiuxi-deploy-yaml"><a href="#4-1-jiuxi-deploy-yaml" class="headerlink" title="4.1 jiuxi-deploy.yaml"></a>4.1 jiuxi-deploy.yaml</h2><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590659353738215.png" srcset="/img/loading.gif" lazyload alt="第三十八章 九析带你轻松完爆 Istio - Fortio、Circuit breakers 断路器_Istio 视频_04"></p><h2 id="4-2-jiuxi-svc-yaml"><a href="#4-2-jiuxi-svc-yaml" class="headerlink" title="4.2 jiuxi-svc.yaml"></a>4.2 jiuxi-svc.yaml</h2><p>&emsp;&emsp;该文件是对上面 deploy 文件的一个 service 暴露：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590659364599149.png" srcset="/img/loading.gif" lazyload alt="第三十八章 九析带你轻松完爆 Istio - Fortio、Circuit breakers 断路器_Istio 断路器_06"></p><h2 id="4-3-jiuxi-dr-yaml"><a href="#4-3-jiuxi-dr-yaml" class="headerlink" title="4.3 jiuxi-dr.yaml"></a>4.3 jiuxi-dr.yaml</h2><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590659385856602.png" srcset="/img/loading.gif" lazyload alt="第三十八章 九析带你轻松完爆 Istio - Fortio、Circuit breakers 断路器_Istio 视频_07"></p><p>&emsp;&emsp;详细说明如下：</p><blockquote><p>http1MaxPendingRequests: http 请求挂起状态的最大请求数</p><p>maxRequestsPerConnection: 一定时间内限制对后端服务发起的最大请求数，如果超过了此配置，就会出现限流。</p><p>outlierDetection.consecutiveErrors: 拒绝连接的最大失败次数</p><p>outlierDetection.interval: 触发熔断的时间间隔，在 interval 时间间隔内，达到 consecutiveErrors 即触发熔断</p><p>outlierDetection.baseEjectionTime: 熔断时长</p><p>maxEjectionPercent: 熔断连接最大百分比</p></blockquote><hr><h1 id="5-Circuit-breakers-实例部署"><a href="#5-Circuit-breakers-实例部署" class="headerlink" title="5 Circuit breakers 实例部署"></a>5 Circuit breakers 实例部署</h1><h2 id="5-1-Istio-注入"><a href="#5-1-Istio-注入" class="headerlink" title="5.1 Istio 注入"></a>5.1 Istio 注入</h2><p>&emsp;&emsp;对 jiuxi-deploy.yaml 文件进行 Istio 注入：</p><blockquote><p>istioctl kube-inject -f jiuxi-deploy.yaml | kubectl apply -f -</p></blockquote><p>&emsp;&emsp;执行成功后的结果如下：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590659394818991.png" srcset="/img/loading.gif" lazyload alt="第三十八章 九析带你轻松完爆 Istio - Fortio、Circuit breakers 断路器_Istio 教程_09"></p><p>&emsp;&emsp;发现 nginx 容器个数已经是 2 个，就说明注入成功了。</p><h2 id="5-2-部署其他资源文件"><a href="#5-2-部署其他资源文件" class="headerlink" title="5.2 部署其他资源文件"></a>5.2 部署其他资源文件</h2><p>&emsp;&emsp;直接部署 jiuxi-svc.yaml 和 jiuxi-dr.yaml：</p><blockquote><p>kubectl apply -f jiuxi-dr.yaml</p><p>kubectl apply -f jiuxi-svc.yaml</p></blockquote><p>&emsp;&emsp;自此，整个实例部署成功。</p><hr><h1 id="6-验证断路器功能"><a href="#6-验证断路器功能" class="headerlink" title="6 验证断路器功能"></a>6 验证断路器功能</h1><p>&emsp;&emsp;使用 Istio 的负载测试工具 Fortio，有关 Fortio 的安装和使用，请参考我上章的内容，分分钟容易到爆。</p><p>&emsp;&emsp;执行如下命令：</p><blockquote><p>fortio load -c 10 -n 50 -qps 0 <a href="http://10.103.150.90/">http://10.103.150.90</a> (CLUSTER_IP:PORT)</p></blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590659409585223.png" srcset="/img/loading.gif" lazyload alt="第三十八章 九析带你轻松完爆 Istio - Fortio、Circuit breakers 断路器_Istio circuits_10"></p><p>&emsp;&emsp;执行结果如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590659417525055.png" srcset="/img/loading.gif" lazyload alt="第三十八章 九析带你轻松完爆 Istio - Fortio、Circuit breakers 断路器_Istio 断路器_11"></p><p>&emsp;&emsp;从执行结果来看，有 27 个报错。 说明断路器生效。</p><p>&emsp;&emsp;自此，九析带你轻松完爆 Fortio、Circuit breakers 断路器功能。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - Fortio 部署</title>
    <link href="/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-Fortio-%E9%83%A8%E7%BD%B2/"/>
    <url>/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-Fortio-%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 Fortio 介绍</p><p>4 Fortio 下载</p><p>5 Fortio 命令行</p><p>6 Fortio web 控制台方式</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590632941354098.png" srcset="/img/loading.gif" lazyload alt="第三十七章 九析带你轻松完爆 Istio - Fortio 部署_Istio 学习"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590632951668869.png" srcset="/img/loading.gif" lazyload alt="第三十七章 九析带你轻松完爆 Istio - Fortio 部署_Istio 免费 视频_02"></p><hr><h1 id="3-Fortio-介绍"><a href="#3-Fortio-介绍" class="headerlink" title="3 Fortio 介绍"></a>3 Fortio 介绍</h1><p>​    Fortio 是 Istio 的负载测试工具，它提供了 web 控制台和命令行控制台的操作方式。因为后期我们在 Istio 断路器介绍中会使用到 Fortio，因此这节需要对 Fortio 进行安装和简单地操作。</p><hr><h1 id="4-Fortio-下载"><a href="#4-Fortio-下载" class="headerlink" title="4 Fortio 下载"></a>4 Fortio 下载</h1><p>​    推荐使用 Fortio 的命令行操作方式，因此我们选择 rpm 的安装方式。</p><blockquote><p>curl -L <a href="https://github.com/fortio/fortio/releases/download/v1.3.1/fortio-1.3.1-1.x86_64.rpm">https://github.com/fortio/fortio/releases/download/v1.3.1/fortio-1.3.1-1.x86_64.rpm</a> -o fortio-1.3.1-1.x86_64.rpm</p><p>rpm -ivh fortio-1.3.1-1.x86_64.rpm</p></blockquote><hr><h1 id="5-Fortio-命令行"><a href="#5-Fortio-命令行" class="headerlink" title="5 Fortio 命令行"></a>5 Fortio 命令行</h1><p>​    执行如下语句向百度进行负载压测。</p><blockquote><p>fortio load -c 5 -n 20 -qps 0 <a href="http://www.baidu.com/"> http://www.baidu.com</a></p></blockquote><blockquote><p># 命令解释如下：</p><p># -c 表示并发数</p><p># -n 一共多少请求</p><p># -qps 每秒查询数，0 表示不限制</p></blockquote><p>​    命令执行的结果如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590632961627818.png" srcset="/img/loading.gif" lazyload alt="第三十七章 九析带你轻松完爆 Istio - Fortio 部署_Istio Fortio_04"></p><hr><h1 id="6-Fortio-web-控制台方式"><a href="#6-Fortio-web-控制台方式" class="headerlink" title="6 Fortio web 控制台方式"></a>6 Fortio web 控制台方式</h1><p>​    web 控制台方式就是提供给习惯使用 web 界面操作的同学一个途径来使用 Fortio。因为是基于 web 方式，所以就需要首先启动一个 web  server，这样客户端浏览器才可以访问到 web server 提供的操作界面进行负载压测。</p><blockquote><p>nohup fortio server &amp;</p></blockquote><p>​    默认情况 fortio server 会启动 8080 端口，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590632971586578.png" srcset="/img/loading.gif" lazyload alt="第三十七章 九析带你轻松完爆 Istio - Fortio 部署_Istio 学习_05"></p><p>​    打开浏览器，输入 <a href="http://ip:8080/fortio%EF%BC%8C%E8%AE%BF%E9%97%AE">http://IP:8080/fortio，访问</a> Fortio server：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590632982971129.png" srcset="/img/loading.gif" lazyload alt="第三十七章 九析带你轻松完爆 Istio - Fortio 部署_Istio 免费 视频_07"></p><p>​    直接点击“start”按钮，将会看到压测效果：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590632992841011.png" srcset="/img/loading.gif" lazyload alt="第三十七章 九析带你轻松完爆 Istio - Fortio 部署_Istio Fortio_09">   自此，九析带你轻松完爆了 Istio Fortio 负载压测工具。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - 网络弹性之重试（retry）</title>
    <link href="/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-%E7%BD%91%E7%BB%9C%E5%BC%B9%E6%80%A7%E4%B9%8B%E9%87%8D%E8%AF%95%EF%BC%88retry%EF%BC%89/"/>
    <url>/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-%E7%BD%91%E7%BB%9C%E5%BC%B9%E6%80%A7%E4%B9%8B%E9%87%8D%E8%AF%95%EF%BC%88retry%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 网络弹性介绍</p><p>4 重试介绍</p><p>5 重试样例</p><p>  5.1 jiuxi-client.yaml 文件</p><p>  5.2 jiuxi-deploy.yaml</p><p>  5.3 jiuxi-svc.yaml</p><p>  5.4 jiuxi-vs.yaml</p><p>6 重试实例部署</p><p>  6.1 Istio 注入</p><p>  6.2 部署 k8s service</p><p>  6.3 部署 Istio 虚拟服务</p><p>7 重试实例设置</p><p>8 重试实例验证</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590485793878575.png" srcset="/img/loading.gif" lazyload alt="第三十六章 九析带你轻松完爆 Istio - 网络弹性之重试（retry）_Istio 教程"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590485800450604.png" srcset="/img/loading.gif" lazyload alt="第三十六章 九析带你轻松完爆 Istio - 网络弹性之重试（retry）_Istio retry_02"></p><hr><h1 id="3-网络弹性介绍"><a href="#3-网络弹性介绍" class="headerlink" title="3 网络弹性介绍"></a>3 网络弹性介绍</h1><p>​    网络弹性也称为运维弹性，是指网络在遇到灾难事件时快速恢复和继续运行的能力。灾难事件的范畴很广泛，比如长时间停电、网络设备故障、恶意入侵等。</p><hr><h1 id="4-重试介绍"><a href="#4-重试介绍" class="headerlink" title="4 重试介绍"></a>4 重试介绍</h1><p>​    你爱上一个玉女，你想把她变成欲女。于是你疯狂地追求了她。第一次，她拒绝了，你不死心；你又追求她第二次，结果她又拒绝了你，你依旧不死心；你又追求她第三次，结果她又拒绝了你，这次你不再死缠烂打，你改变了策略。你去了整型医院，你整成她的模样，结果你在夜深人静的时候你对着镜子疯狂爱抚自己。你胜利了。</p><p>很多时候，换个角度，也许你就可以解决问题，只是很多人都想不到而已……</p><p>​    好了，不扯淡了。言归正传。</p><p>​    Istio 重试机制就是如果调用服务失败，Envoy 代理尝试连接服务的最大次数。而默认情况下，Envoy 代理在失败后并不会尝试重新连接服务，除非我们启动 Istio 重试机制。</p><hr><h1 id="5-重试样例"><a href="#5-重试样例" class="headerlink" title="5 重试样例"></a>5 重试样例</h1><p>​    本样例中在一次调用服务失败后最多配 3 次重试。</p><p>​    本样例需要结合 Istio 故障注入模拟被调用服务宕机，假如不了解故障注入也没关系，直接执行我的样例就行。下面先展示一下整个实例的架构图：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590485808816801.png" srcset="/img/loading.gif" lazyload alt="第三十六章 九析带你轻松完爆 Istio - 网络弹性之重试（retry）_Istio 重试_04"></p><p>​    架构说明如下，本实例模拟客户端调用 nginx，nginx 将请求转发给 tomcat。tomcat 通过故障注入而中止对外服务，nginx 设置如果访问 tomcat 失败则会重试 3 次。</p><p>​    该实例资源文件一共有 4 个，分别如下：</p><blockquote><p>jiuxi-client.yaml</p><p>jiuxi-deploy.yaml</p><p>jiuxi-svc.yaml</p><p>jiuxi-vs.yaml</p></blockquote><h2 id="5-1-jiuxi-client-yaml-文件"><a href="#5-1-jiuxi-client-yaml-文件" class="headerlink" title="5.1 jiuxi-client.yaml 文件"></a>5.1 jiuxi-client.yaml 文件</h2><p>​    资源内容如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590485817157460.png" srcset="/img/loading.gif" lazyload alt="第三十六章 九析带你轻松完爆 Istio - 网络弹性之重试（retry）_Istio 教程_06"></p><h2 id="5-2-jiuxi-deploy-yaml"><a href="#5-2-jiuxi-deploy-yaml" class="headerlink" title="5.2 jiuxi-deploy.yaml"></a>5.2 jiuxi-deploy.yaml</h2><p>​    内容如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590485824954620.png" srcset="/img/loading.gif" lazyload alt="第三十六章 九析带你轻松完爆 Istio - 网络弹性之重试（retry）_Istio 视频_08"></p><h2 id="5-3-jiuxi-svc-yaml"><a href="#5-3-jiuxi-svc-yaml" class="headerlink" title="5.3 jiuxi-svc.yaml"></a>5.3 jiuxi-svc.yaml</h2><p>​    内容如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590485831239422.png" srcset="/img/loading.gif" lazyload alt="第三十六章 九析带你轻松完爆 Istio - 网络弹性之重试（retry）_Istio 重试_10"></p><h2 id="5-4-jiuxi-vs-yaml"><a href="#5-4-jiuxi-vs-yaml" class="headerlink" title="5.4 jiuxi-vs.yaml"></a>5.4 jiuxi-vs.yaml</h2><p>​    内容如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590485836248871.png" srcset="/img/loading.gif" lazyload alt="第三十六章 九析带你轻松完爆 Istio - 网络弹性之重试（retry）_Istio retires_12"></p><p>​    此虚拟服务有两个知识点。</p><p>​    第一：故障注入。该虚拟服务的作用对象就是 tomcat-svc。使用此故障注入后，在网格中该 tomcat 就是不可用的。</p><blockquote><p>http:</p><p>- fault:</p><p>   abort:</p><p>​     percentage:</p><p>​       value: 100</p><p>​     httpStatus: 503</p></blockquote><p>​    该设置说明每次调用 tomcat-svc，都会调用失败，并且返回错误状态码 503。</p><p>​    第二：重试。代码如下：</p><blockquote><p>http:</p><p>- route:</p><p>  - destination:</p><p>​     host: nginx-svc</p><p>  reties:</p><p>   attempts: 3</p></blockquote><p>​    该设置说明每次调用 nginx-svc，如果调用失败的话就会重试 3 次。</p><hr><h1 id="6-重试实例部署"><a href="#6-重试实例部署" class="headerlink" title="6 重试实例部署"></a>6 重试实例部署</h1><h2 id="6-1-Istio-注入"><a href="#6-1-Istio-注入" class="headerlink" title="6.1 Istio 注入"></a>6.1 Istio 注入</h2><p>​    需要对 client 和 deploy 资源进行 Istio 注入，将 client、nginx、tomcat 都放到网格中。本人是手工注入 Istio，如果你设置了自动资源注入也不会有影响，一样可以轻松完爆。</p><blockquote><p>istioctl kube-inject -f jiuxi-client.yaml | kubectl apply -f -</p><p>istioctl kube-inject -f jiuxi-deploy.yaml | kubectl apply -f -</p></blockquote><p>​    执行成功后，通过 kubectl get pods 查看 Istio 注入情况：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590485851519677.png" srcset="/img/loading.gif" lazyload alt="第三十六章 九析带你轻松完爆 Istio - 网络弹性之重试（retry）_Istio retry_14"></p><h2 id="6-2-部署-k8s-service"><a href="#6-2-部署-k8s-service" class="headerlink" title="6.2 部署 k8s service"></a>6.2 部署 k8s service</h2><p>​    部署 jiuxi-svc.yaml：</p><blockquote><p>kubectl apply -f jiuxi-svc.yaml</p></blockquote><h2 id="6-3-部署-Istio-虚拟服务"><a href="#6-3-部署-Istio-虚拟服务" class="headerlink" title="6.3 部署 Istio 虚拟服务"></a>6.3 部署 Istio 虚拟服务</h2><p>​    部署 jiuxi-vs.yaml</p><blockquote><p>kubectl apply -f jiuxi-vs.yaml</p></blockquote><hr><h1 id="7-重试实例设置"><a href="#7-重试实例设置" class="headerlink" title="7 重试实例设置"></a>7 重试实例设置</h1><p>​    因为要用到 nginx 到 tomcat 的转发功能，因此需要对 nginx 做一些设置：</p><p>​    登录 nginx pod：</p><blockquote><p>kubectl exec -it nginx-7559f7d487-79q9p – sh</p></blockquote><p>​    编辑 nginx 配置文件：</p><blockquote><p>vi /etc/nginx/conf.d/default.conf</p></blockquote><p>​    添加和修改如下内容：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590485861546663.png" srcset="/img/loading.gif" lazyload alt="第三十六章 九析带你轻松完爆 Istio - 网络弹性之重试（retry）_Istio 重试_16"></p><p>​    编辑完成后，再执行如下语句验证配置和让配置生效：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590485869612451.png" srcset="/img/loading.gif" lazyload alt="第三十六章 九析带你轻松完爆 Istio - 网络弹性之重试（retry）_Istio retires_18"></p><p>​    自此，整个样例配置和部署完毕。</p><hr><h1 id="8-重试实例验证"><a href="#8-重试实例验证" class="headerlink" title="8 重试实例验证"></a>8 重试实例验证</h1><p>​    登录 client，执行如下语句：</p><blockquote><p>kubectl exec -it client-5b77d5949f-nzdtl – sh # 别照抄本人 pod，根据各自情况修改</p></blockquote><p>​    执行如下语句：</p><blockquote><p>wget -q -O - <a href="http://nginx-svc/"> http://nginx-svc</a></p></blockquote><p>​    执行如下语句首先将 nginx 的日志打印到控制台：</p><blockquote><p>kubectl logs -f nginx-7559f7d487-79q9p -c istio-proxy</p></blockquote><p>​    执行结果如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590485878604489.png" srcset="/img/loading.gif" lazyload alt="第三十六章 九析带你轻松完爆 Istio - 网络弹性之重试（retry）_Istio retires_20"></p><p>​    由上图可知，重试设置生效。</p><p>​    自此，九析带你轻松完爆了 Istio 的重试（retry）机制。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - 网络弹性之超时（timeout）</title>
    <link href="/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-%E7%BD%91%E7%BB%9C%E5%BC%B9%E6%80%A7%E4%B9%8B%E8%B6%85%E6%97%B6%EF%BC%88timeout%EF%BC%89/"/>
    <url>/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-%E7%BD%91%E7%BB%9C%E5%BC%B9%E6%80%A7%E4%B9%8B%E8%B6%85%E6%97%B6%EF%BC%88timeout%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 网络弹性介绍</p><p>4 超时时间</p><p>5 Istio 超时实例</p><p>5.1    jiuxi-client.yaml 文件</p><p>5.2 jiuxi-deploy.yaml</p><p>5.3 jiuxi-svc.yaml</p><p>5.4 jiuxi-vs.yaml</p><p>6 超时实例部署</p><p>6.1 Istio 注入</p><p>6.2 部署 k8s service:</p><p>6.3 部署 Istio 虚拟服务：</p><p>7 超时实例设置</p><p>8 超时实例验</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590378990221451.png" srcset="/img/loading.gif" lazyload alt="第三十五章 九析带你轻松完爆 Istio - 网络弹性之超时（timeout）_istio 教程"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590378998739752.png" srcset="/img/loading.gif" lazyload alt="第三十五章 九析带你轻松完爆 Istio - 网络弹性之超时（timeout）_Istio 超时_02"></p><hr><h1 id="3-网络弹性介绍"><a href="#3-网络弹性介绍" class="headerlink" title="3 网络弹性介绍"></a>3 网络弹性介绍</h1><p>​    网络弹性也称为运维弹性，是指网络在遇到灾难事件时快速恢复和继续运行的能力。灾难事件的范畴很广泛，比如长时间停电、网络设备故障、恶意入侵等。</p><hr><h1 id="4-超时时间"><a href="#4-超时时间" class="headerlink" title="4 超时时间"></a>4 超时时间</h1><p>​    工作中常常会碰到这样的开发、测试场景，比如：“对方处理请求时间过长，没有及时响应，我们的程序要怎么处理来确保不会无限期地等待”。常见的处理方式是被调用方使用 sleep  语句模拟响应时间过长，调用方设定请求超时时间过短，来造成请求超时的结果。但是这种处理方法有很多的弊端，第一：本属于网络弹性层的东西，却需要在代码中体现；第二：超时时间设置过长可能导致过多的延迟、设置过短可能导致不必要的失败，因此超时时间需要动态调整。基于上面两个弊端，Istio  使用虚拟服务来优雅实现超时处理。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590379008447397.png" srcset="/img/loading.gif" lazyload alt="第三十五章 九析带你轻松完爆 Istio - 网络弹性之超时（timeout）_Istio 超时_04"></p><hr><h1 id="5-Istio-超时实例"><a href="#5-Istio-超时实例" class="headerlink" title="5 Istio 超时实例"></a>5 Istio 超时实例</h1><p>​    本实例需要结合 Istio 故障注入模拟被调用方响应请求慢的场景，有关 Istio 失败注入之延迟请参考本人的另外一篇<a href="https://blog.51cto.com/14625168/2496878"> 博文</a>，简单到让你分分钟轻松完爆。</p><p>​    该实例的架构图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590379015698550.png" srcset="/img/loading.gif" lazyload alt="第三十五章 九析带你轻松完爆 Istio - 网络弹性之超时（timeout）_Istio 故障注入_06"></p><p>​    架构说明如下，本实例就是模拟客户端调用 nginx，nginx 将请求转发给 tomcat 的常见功能。tomcat 响应请求设置为 5s（通过故障注入实现，相当于 sleep 5s 逻辑），nginx 设置 client 的请求超时时间为 2s。因为 nginx 需要在 2s 内返回给 client，而 nginx 请求  tomcat 却需要 5s，因此模拟 client 调用 nginx 超时的情景。</p><p>​    该实例资源文件一共有 4 个，分别如下：</p><blockquote><p>jiuxi-client.yaml    # 客户端资源</p><p>jiuxi-deploy.yaml    # nginx、tomcat 的 deployment 资源</p><p>jiuxi-svc.yaml        # nginx、tomcat 的 service 资源</p><p>jiuxi-vs.yaml        # Istio 虚拟资源</p></blockquote><h2 id="5-1-jiuxi-client-yaml-文件"><a href="#5-1-jiuxi-client-yaml-文件" class="headerlink" title="5.1    jiuxi-client.yaml 文件"></a>5.1    jiuxi-client.yaml 文件</h2><p>​    资源内容如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590379023441708.png" srcset="/img/loading.gif" lazyload alt="第三十五章 九析带你轻松完爆 Istio - 网络弹性之超时（timeout）_istio 视频_08"></p><h2 id="5-2-jiuxi-deploy-yaml"><a href="#5-2-jiuxi-deploy-yaml" class="headerlink" title="5.2 jiuxi-deploy.yaml"></a>5.2 jiuxi-deploy.yaml</h2><p>​    资源内容如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590379031255812.png" srcset="/img/loading.gif" lazyload alt="第三十五章 九析带你轻松完爆 Istio - 网络弹性之超时（timeout）_istio 视频_10"></p><h2 id="5-3-jiuxi-svc-yaml"><a href="#5-3-jiuxi-svc-yaml" class="headerlink" title="5.3 jiuxi-svc.yaml"></a>5.3 jiuxi-svc.yaml</h2><p>​    资源内容如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590379036583530.png" srcset="/img/loading.gif" lazyload alt="第三十五章 九析带你轻松完爆 Istio - 网络弹性之超时（timeout）_Istio timeout_12"></p><h2 id="5-4-jiuxi-vs-yaml"><a href="#5-4-jiuxi-vs-yaml" class="headerlink" title="5.4 jiuxi-vs.yaml"></a>5.4 jiuxi-vs.yaml</h2><p>​    Istio 虚拟服务资源内容如下所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590379043793457.png" srcset="/img/loading.gif" lazyload alt="第三十五章 九析带你轻松完爆 Istio - 网络弹性之超时（timeout）_istio 教程_14"></p><p>​    此虚拟服务有两个知识点。</p><p>​    第一：故障注入：</p><blockquote><p>http:</p><p>- fault:</p><p>   delay:</p><p>​     percentage:</p><p>​     value: 100</p><p>   fixedDelay: 5s</p></blockquote><p>​    该设置说明每次调用 tomcat-svc 的 k8s service，都会延迟 5s 才会调用。</p><p>​    第二：调用超时：</p><blockquote><p>hosts:</p><p>- nginx-svc</p><p>http:</p><p>- route:</p><p> - destination:</p><p>   host: nginx-svc</p><p>timeout: 2s</p></blockquote><p>​    该设置说明调用 nginx-svc 的 k8s service，请求超时时间是 2s。</p><hr><h1 id="6-超时实例部署"><a href="#6-超时实例部署" class="headerlink" title="6 超时实例部署"></a>6 超时实例部署</h1><p>​    在上面我们编写完样例，下面准备部署。</p><h2 id="6-1-Istio-注入"><a href="#6-1-Istio-注入" class="headerlink" title="6.1 Istio 注入"></a>6.1 Istio 注入</h2><p>​    需要对 client 和 deploy 资源文件进行 Istio 注入，将 client、nginx、tomcat 都放入到网格中。本人是手工注入 Istio 方式，如果你设置了自动 Istio 注入不会影响，一样可以轻松完爆。</p><blockquote><p>istioctl kube-inject -f jiuxi-client.yaml | kubectl apply -f -</p><p>istioctl kube-inject -f jiuxi-deploy.yaml | kubectl apply -f -</p></blockquote><p>​    执行成功后，通过 kubectl get pods 查看 Istio 注入情况：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590379054696222.png" srcset="/img/loading.gif" lazyload alt="第三十五章 九析带你轻松完爆 Istio - 网络弹性之超时（timeout）_istio 视频_16"></p><h2 id="6-2-部署-k8s-service"><a href="#6-2-部署-k8s-service" class="headerlink" title="6.2 部署 k8s service"></a>6.2 部署 k8s service</h2><p>​    部署 jiuxi-svc.yaml：</p><blockquote><p>kubectl apply -f jiuxi-svc.yaml</p></blockquote><h2 id="6-3-部署-Istio-虚拟服务"><a href="#6-3-部署-Istio-虚拟服务" class="headerlink" title="6.3 部署 Istio 虚拟服务"></a>6.3 部署 Istio 虚拟服务</h2><p>​    部署 jiuxi-vs.yaml:</p><blockquote><p>kubectl apply -f jiuxi-vs.yaml</p></blockquote><hr><h1 id="7-超时实例设置"><a href="#7-超时实例设置" class="headerlink" title="7 超时实例设置"></a>7 超时实例设置</h1><p>​    因为要用到 nginx 对 tomcat 的转发功能，因此需要对 nginx 做一些设置：</p><p>​    登录 nginx pod：</p><blockquote><p>kubectl exec -it nginx-7559f7d487-djzbb – sh</p></blockquote><p>​    编辑 nginx 配置文件：</p><blockquote><p>vi /etc/nginx/conf.d/default.conf</p></blockquote><p>​    添加和修改如下内容：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590379063523307.png" srcset="/img/loading.gif" lazyload alt="第三十五章 九析带你轻松完爆 Istio - 网络弹性之超时（timeout）_istio 视频_18"></p><p>​    编辑完后，再执行如下语句验证配置和让配置生效：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590379070550212.png" srcset="/img/loading.gif" lazyload alt="第三十五章 九析带你轻松完爆 Istio - 网络弹性之超时（timeout）_istio 教程_20"></p><p>​    自此，整个样例配置和部署完毕。</p><hr><h1 id="8-超时实例验证"><a href="#8-超时实例验证" class="headerlink" title="8 超时实例验证"></a>8 超时实例验证</h1><p>​    登录 client，执行如下语句：</p><blockquote><p>kubectl exec -it client-5b77d5949f-nzdtl – sh    # 别照抄本人 pod，根据各自情况修改</p></blockquote><p>​    执行如下语句：</p><blockquote><p>wget -q -O - <a href="http://nginx-svc/"> http://nginx-svc</a></p></blockquote><p>​    执行结果如下所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1590379078144155.png" srcset="/img/loading.gif" lazyload alt="第三十五章 九析带你轻松完爆 Istio - 网络弹性之超时（timeout）_istio 教程_22"></p><p>​    说明 timeout 样例运行成功。</p><p>​    也可以同样验证故障注入效果，执行如下语句：</p><blockquote><p>wget -q -O - <a href="http://tomcat-svc:8080/"> http://tomcat-svc:8080</a></p></blockquote><p>​    执行效果是请求 5s 后才会返回，说明 Istio 故障注入（延迟 5s）运行成功。</p><p>​    自此，九析带你轻松完爆了 Istio。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - fault injection 故障注入之中止</title>
    <link href="/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-fault-injection-%E6%95%85%E9%9A%9C%E6%B3%A8%E5%85%A5%E4%B9%8B%E4%B8%AD%E6%AD%A2/"/>
    <url>/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-fault-injection-%E6%95%85%E9%9A%9C%E6%B3%A8%E5%85%A5%E4%B9%8B%E4%B8%AD%E6%AD%A2/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 故障注入之中止</p><p>4 Istio 故障注入之中止实例</p><p>  4.1 客户端资源文件</p><p>  4.2 k8s 服务文件</p><p>  4.3 部署工作负载（deployment）</p><p>  4.4 虚拟服务文件</p><p>5 验证故障注入</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589954813582556.png" srcset="/img/loading.gif" lazyload alt="第三十四章 九析带你轻松完爆 Istio - fault injection 故障注入之中止_istio 视频"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589954822606472.png" srcset="/img/loading.gif" lazyload alt="第三十四章 九析带你轻松完爆 Istio - fault injection 故障注入之中止_istio 流量管理_02"></p><hr><h1 id="3-故障注入之中止"><a href="#3-故障注入之中止" class="headerlink" title="3 故障注入之中止"></a>3 故障注入之中止</h1><p>​    上章介绍了故障注入原理和实操，知道了故障注入多用在两个场景：</p><blockquote><p>延迟：模拟增加网络延迟或上游服务过载</p><p>中止：模拟服务故障而导致调用服务不可用。中止通常以 HTTP 错误代码或 TCP 连接失败表示</p></blockquote><p>​    在上节中已经介绍了故障注入延迟的实例，这节重点介绍故障注入的中止。</p><hr><h1 id="4-Istio-故障注入之中止实例"><a href="#4-Istio-故障注入之中止实例" class="headerlink" title="4 Istio 故障注入之中止实例"></a>4 Istio 故障注入之中止实例</h1><p>​    本实例包括 4 个资源文件，3 个 k8s 相关，1 个 istio 相关：</p><blockquote><p>jiuxi-client.yaml</p><p>jiuxi-nginx-svc.yaml</p><p>jiuxi-nginx-deploy.yaml</p><p>jiuxi-nginx-vs.yaml</p></blockquote><h2 id="4-1-客户端资源文件"><a href="#4-1-客户端资源文件" class="headerlink" title="4.1 客户端资源文件"></a>4.1 客户端资源文件</h2><p>​    jiuxi-client.yaml 内容如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589954889697928.png" srcset="/img/loading.gif" lazyload alt="第三十四章 九析带你轻松完爆 Istio - fault injection 故障注入之中止_istio 视频_03"></p><p>​    执行如下语句进行 Istio 注入，注入后，此 client 将处于网格之内：</p><blockquote><p>istioctl kube-inject -f jiuxi-client.yaml | kubectl apply -f -</p></blockquote><p>​    Istio 注入成功成功如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589954895184626.png" srcset="/img/loading.gif" lazyload alt="第三十四章 九析带你轻松完爆 Istio - fault injection 故障注入之中止_istio 视频_04"></p><h2 id="4-2-k8s-服务文件"><a href="#4-2-k8s-服务文件" class="headerlink" title="4.2 k8s 服务文件"></a>4.2 k8s 服务文件</h2><p>​    jiuxi-nginx-svc.yaml 内容如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589954902303383.png" srcset="/img/loading.gif" lazyload alt="第三十四章 九析带你轻松完爆 Istio - fault injection 故障注入之中止_istio fault inject_05"></p><p>​    执行如下语句部署 service：</p><blockquote><p>kubectl apply -f jiuxi-nginx-svc.yaml</p></blockquote><h2 id="4-3-部署工作负载（deployment）"><a href="#4-3-部署工作负载（deployment）" class="headerlink" title="4.3 部署工作负载（deployment）"></a>4.3 部署工作负载（deployment）</h2><p>​    jiuxi-nginx-deploy.yaml 内容如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589954910549427.png" srcset="/img/loading.gif" lazyload alt="第三十四章 九析带你轻松完爆 Istio - fault injection 故障注入之中止_istio fault inject_06"></p><p>​    部署语句如下：</p><blockquote><p>kubectl apply -f jiuxi-nginx-deploy.yaml</p></blockquote><h2 id="4-4-虚拟服务文件"><a href="#4-4-虚拟服务文件" class="headerlink" title="4.4 虚拟服务文件"></a>4.4 虚拟服务文件</h2><p>​    故障注入就在虚拟服务资源中，内容如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589954917713253.png" srcset="/img/loading.gif" lazyload alt="第三十四章 九析带你轻松完爆 Istio - fault injection 故障注入之中止_istio 失败注入_07"></p><p>​    部署语句如下：</p><blockquote><p>kubectl apply -f jiuxi-nginx-vs.yaml</p></blockquote><p>​    自此，整个实例部署完毕。</p><hr><h1 id="5-验证故障注入"><a href="#5-验证故障注入" class="headerlink" title="5 验证故障注入"></a>5 验证故障注入</h1><p>​    执行如下语句登录客户端：</p><blockquote><p>kubectl exec -it client-5b77d5949f-clrb7 – sh</p></blockquote><p>​    使用 wget 访问 nginx-svc：</p><blockquote><p>wget -q -O - <a href="http://nginx-svc/"> http://nginx-svc</a></p></blockquote><p>​    发现模拟后端服务中止失效。如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589954925218922.png" srcset="/img/loading.gif" lazyload alt="第三十四章 九析带你轻松完爆 Istio - fault injection 故障注入之中止_istio 流量管理_08"></p><p>​    自此，九析带你轻松完爆故障注入之中止。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - fault injection 故障注入</title>
    <link href="/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-fault-injection-%E6%95%85%E9%9A%9C%E6%B3%A8%E5%85%A5/"/>
    <url>/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-fault-injection-%E6%95%85%E9%9A%9C%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 故障注入简介</p><p>4 Istio 故障注入</p><p>5 Istio 故障注入实例</p><p>  5.1 客户端资源文件</p><p>  5.2 k8s 服务文件</p><p>  5.3 部署工作负载（deployment）</p><p>  5.4 虚拟服务文件</p><p>6 验证故障注入</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589943444388659.png" srcset="/img/loading.gif" lazyload alt="第三十三章 九析带你轻松完爆 Istio - fault injection 故障注入_Istio 故障注入"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589943453222671.png" srcset="/img/loading.gif" lazyload alt="第三十三章 九析带你轻松完爆 Istio - fault injection 故障注入_istio 教程_02"></p><hr><h1 id="3-故障注入简介"><a href="#3-故障注入简介" class="headerlink" title="3 故障注入简介"></a>3 故障注入简介</h1><p>​    很多年前，我看过这样一部电影：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589943462847897.png" srcset="/img/loading.gif" lazyload alt="第三十三章 九析带你轻松完爆 Istio - fault injection 故障注入_istio 教程_04"></p><p>​    没错，周星驰演得，逃学威龙2。电影的开头讲述了周星驰的飞虎队执行反恐演习，在最后却误射了可爱的小骚妹。</p><p>​    但是这跟故障注入有神马关系呢？</p><p>​    周星驰的反恐演习其实并不是真的反恐，而只是演习；故障注入本身也并没有故障，而是人为引入故障。这种机制都是为了测试和提高体系健壮性的手段。</p><p>​    在程序开发过程中，我们经常会有这样的场景，比如要测试调用第三方服务失败后系统的反应，或者上游服务雪崩时下游服务逻辑处理等。如果没有故障注入，那么我们就只能采用断网、压测等手段模拟故障，但是这样的操作实在费事费力，一点都不随风。</p><hr><h1 id="4-Istio-故障注入"><a href="#4-Istio-故障注入" class="headerlink" title="4 Istio 故障注入"></a>4 Istio 故障注入</h1><p>​    Istio 故障注入与其他在网络层引入错误（例如延迟数据包或者直接杀死 Pod）的机制不同，Istio 允许在应用程序层注入故障。这使得可以注入更多相关的故障，比如 HTTP 错误代码等。</p><p>​    Istio 可以注入两种类型的故障，而这两种故障都是使用虚拟服务来配置的：</p><blockquote><p>延迟：模拟增加网络延迟或上游服务过载。</p><p>中止：模拟服务故障而导致调用服务不可用。中止通常以 HTTP 错误代码或 TCP 连接失败表示</p></blockquote><hr><h1 id="5-Istio-故障注入实例"><a href="#5-Istio-故障注入实例" class="headerlink" title="5 Istio 故障注入实例"></a>5 Istio 故障注入实例</h1><p>​    本实例包括 4 个资源文件，3 个 k8s 相关，1 个 istio 相关：</p><blockquote><p>jiuxi-client.yaml    </p><p>jiuxi-nginx-svc.yaml        </p><p>jiuxi-nginx-deploy.yaml</p><p>jiuxi-nginx-vs.yaml</p></blockquote><h2 id="5-1-客户端资源文件"><a href="#5-1-客户端资源文件" class="headerlink" title="5.1 客户端资源文件"></a>5.1 客户端资源文件</h2><p>​    jiuxi-client.yaml 内容如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589943486418393.png" srcset="/img/loading.gif" lazyload alt="第三十三章 九析带你轻松完爆 Istio - fault injection 故障注入_Istio 失败注入_06"></p><p>​    执行如下语句进行 Istio 注入，注入后，此 client 将处于网格之内：</p><blockquote><p>istioctl kube-inject -f jiuxi-client.yaml | kubectl apply -f -</p></blockquote><p>​    Istio 注入成功成功如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589943499357696.png" srcset="/img/loading.gif" lazyload alt="第三十三章 九析带你轻松完爆 Istio - fault injection 故障注入_istio 教程_08"></p><h2 id="5-2-k8s-服务文件"><a href="#5-2-k8s-服务文件" class="headerlink" title="5.2 k8s 服务文件"></a>5.2 k8s 服务文件</h2><p>​    jiuxi-nginx-svc.yaml 内容如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589943507931635.png" srcset="/img/loading.gif" lazyload alt="第三十三章 九析带你轻松完爆 Istio - fault injection 故障注入_Istio 失败注入_10"></p><p>​    执行如下语句部署 service：</p><blockquote><p>kubectl apply -f jiuxi-nginx-svc.yaml</p></blockquote><h2 id="5-3-部署工作负载（deployment）"><a href="#5-3-部署工作负载（deployment）" class="headerlink" title="5.3 部署工作负载（deployment）"></a>5.3 部署工作负载（deployment）</h2><p>​    jiuxi-nginx-deploy.yaml 内容如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589943513722118.png" srcset="/img/loading.gif" lazyload alt="第三十三章 九析带你轻松完爆 Istio - fault injection 故障注入_istio 教程_12"></p><p>​    部署语句如下：</p><blockquote><p>kubectl apply -f jiuxi-nginx-deploy.yaml</p></blockquote><h2 id="5-4-虚拟服务文件"><a href="#5-4-虚拟服务文件" class="headerlink" title="5.4 虚拟服务文件"></a>5.4 虚拟服务文件</h2><p>​    故障注入就在虚拟服务资源中，内容如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589943521891904.png" srcset="/img/loading.gif" lazyload alt="第三十三章 九析带你轻松完爆 Istio - fault injection 故障注入_Istio fault inject_14"></p><p>​    部署语句如下：</p><blockquote><p>kubectl apply -f jiuxi-nginx-vs.yaml</p></blockquote><p>​    自此，整个实例部署完毕。</p><hr><h1 id="6-验证故障注入"><a href="#6-验证故障注入" class="headerlink" title="6 验证故障注入"></a>6 验证故障注入</h1><p>​    执行如下语句登录客户端：</p><blockquote><p>kubectl exec -it client-5b77d5949f-clrb7 – sh</p></blockquote><p>​    使用 wget 访问 nginx-svc：</p><blockquote><p>wget -q -O - <a href="http://nginx-svc/"> http://nginx-svc</a></p></blockquote><p>​    发现延迟生效，因为设置的延迟时间是 5s。除去我中间操作花去了大约 3s，发现最终的延迟确实是 5s。如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589943531644226.png" srcset="/img/loading.gif" lazyload alt="第三十三章 九析带你轻松完爆 Istio - fault injection 故障注入_Istio fault inject_16"></p><p>​    自此，九析带你轻松完爆了 Istio 故障注入。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - configmap istio-ca-root-cer</title>
    <link href="/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-configmap-istio-ca-root-cer/"/>
    <url>/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-configmap-istio-ca-root-cer/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 错误现象</p><p>4 解决方案</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589879701743186.png" srcset="/img/loading.gif" lazyload alt="第三十二章 九析带你轻松完爆 Istio - configmap istio-ca-root-cer_istiod-ca-cert"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589879708134145.png" srcset="/img/loading.gif" lazyload alt="第三十二章 九析带你轻松完爆 Istio - configmap istio-ca-root-cer_istio 视频_02"></p><hr><h1 id="3-错误现象"><a href="#3-错误现象" class="headerlink" title="3 错误现象"></a>3 错误现象</h1><p>​    Istio 升级到 1.5.x，当新创建命名空间，在该命名空间中对工作负载进行 Istio 注入（自动或手动），出现 configmap 挂载错误：</p><blockquote><p>SetUp failed for volume “istiod-ca-cert” : configmap “istio-ca-root-cert” not found.</p></blockquote><hr><h1 id="4-解决方案"><a href="#4-解决方案" class="headerlink" title="4 解决方案"></a>4 解决方案</h1><p>​    执行如下语句：</p><blockquote><p>kubectl rollout restart istiod -n istion-system</p></blockquote><p>​    kubectl rollout 命令是对资源进行管理，restart 表示重启资源。因此上面的命令作用是重启 istiod。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - 服务条目 ServiceEntry 实例</title>
    <link href="/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-%E6%9C%8D%E5%8A%A1%E6%9D%A1%E7%9B%AE-ServiceEntry-%E5%AE%9E%E4%BE%8B/"/>
    <url>/2021/09/12/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-%E6%9C%8D%E5%8A%A1%E6%9D%A1%E7%9B%AE-ServiceEntry-%E5%AE%9E%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 服务条目（Service Entries）介绍</p><p>4 服务条目样例</p><p>  4.1 服务条目资源</p><p>  4.2 istio 注入客户端资源</p><p>5 验证服务条目样例</p><p>  5.1 登录 client</p><p>  5.2 调整 service entiries 解析类型</p><p>6 总结</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589874028884872.png" srcset="/img/loading.gif" lazyload alt="第三十一章 九析带你轻松完爆 Istio - 服务条目 ServiceEntry 实例_istio 服务条目"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589874036233340.png" srcset="/img/loading.gif" lazyload alt="第三十一章 九析带你轻松完爆 Istio - 服务条目 ServiceEntry 实例_istio service entry_02"></p><hr><h1 id="3-服务条目（Service-Entries）介绍"><a href="#3-服务条目（Service-Entries）介绍" class="headerlink" title="3 服务条目（Service Entries）介绍"></a>3 服务条目（Service Entries）介绍</h1><p>​    使用服务条目资源（Service Entries）可以将条目添加到 Istio 内部维护的服务注册表中。添加服务条目后，Envoy  代理可以将流量发送到该服务，就好像该服务条目是网格中的服务一样。通过配置服务条目，可以管理在网格外部运行的服务的流量。</p><p>​    此外，可以配置虚拟服务和目标规则，以更精细的方式控制到服务条目的流量，就像为网格中的其他任何服务配置流量一样。</p><hr><h1 id="4-服务条目样例"><a href="#4-服务条目样例" class="headerlink" title="4 服务条目样例"></a>4 服务条目样例</h1><p>​    上面的介绍有点晦涩，不如我们直接给一个样例出来，该样例包含两个资源文件：</p><blockquote><p>jiuxi-client.yaml    # istio 要注入的客户端资源文件</p><p>jiuxi-svc-entry.yaml    # 服务条目资源文件</p></blockquote><h2 id="4-1-服务条目资源"><a href="#4-1-服务条目资源" class="headerlink" title="4.1 服务条目资源"></a>4.1 服务条目资源</h2><p>​    jiuxi-svc-entry.yaml 内容如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589874045559306.png" srcset="/img/loading.gif" lazyload alt="第三十一章 九析带你轻松完爆 Istio - 服务条目 ServiceEntry 实例_istio service entry_04"></p><p>​    该服务条目资源定义了一个外部网站 baidu，并将它纳入到 Istio 内部维护的服务注册表中。执行如下语句创建 service entry 资源：</p><blockquote><p>kubectl apply -f jiuxi-svc-entry.yaml</p></blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589874053316318.png" srcset="/img/loading.gif" lazyload alt="第三十一章 九析带你轻松完爆 Istio - 服务条目 ServiceEntry 实例_istio traffic manag_06"></p><h2 id="4-2-istio-注入客户端资源"><a href="#4-2-istio-注入客户端资源" class="headerlink" title="4.2 istio 注入客户端资源"></a>4.2 istio 注入客户端资源</h2><p>​    jiuxi-client.yaml 客户端资源文件如下：</p><p><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第三十一章 九析带你轻松完爆 Istio - 服务条目 ServiceEntry 实例_istio 流量管理_03"></p><p>​    编辑完，执行如下语句进行 Istio 注入：</p><blockquote><p>istioctl kube-inject -f jiuxi-client.yaml | kubectl apply -f -</p></blockquote><p>​    执行成功后，查看 pod 发现容器个数为 2 个，说明 istio 注入成功：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589874101280021.png" srcset="/img/loading.gif" lazyload alt="第三十一章 九析带你轻松完爆 Istio - 服务条目 ServiceEntry 实例_istio service entry_10"></p><p>​    Istio 注入后，client 就处于 Istio 服务网格之中。</p><hr><h1 id="5-验证服务条目样例"><a href="#5-验证服务条目样例" class="headerlink" title="5 验证服务条目样例"></a>5 验证服务条目样例</h1><h2 id="5-1-登录-client"><a href="#5-1-登录-client" class="headerlink" title="5.1 登录 client"></a>5.1 登录 client</h2><p>​    执行如下语句登录 client：</p><blockquote><p>kubectl exec -it $(kubectl get pods | grep -i client | awk ‘{print $1}’) – sh</p></blockquote><p>​    登陆 client，访问 <a href="http://www.baidu.com/">www.baidu.com</a> 成功，如下所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589874108331494.png" srcset="/img/loading.gif" lazyload alt="第三十一章 九析带你轻松完爆 Istio - 服务条目 ServiceEntry 实例_istio 视频_12"></p><p>​    你可能会迷惑，难道这就是服务条目？不是访问外网吗？</p><p>​    好吧，这还就真是服务条目。为了解除你心中的疑惑，我们现在来对刚才编写的 service entries 资源做一些手脚。</p><h2 id="5-2-调整-service-entiries-解析类型"><a href="#5-2-调整-service-entiries-解析类型" class="headerlink" title="5.2 调整 service entiries 解析类型"></a>5.2 调整 service entiries 解析类型</h2><p>​    调整内容如下所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589874117646658.png" srcset="/img/loading.gif" lazyload alt="第三十一章 九析带你轻松完爆 Istio - 服务条目 ServiceEntry 实例_istio 视频_14"></p><p>​    添加了域名解析类型为 static，同时给出一个自定义 IP：192.168.182.188。再次 kubectl apply 后登陆 client 查看：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589874124875325.png" srcset="/img/loading.gif" lazyload alt="第三十一章 九析带你轻松完爆 Istio - 服务条目 ServiceEntry 实例_istio 流量管理_16"></p><p>​    再次访问 baidu，发现已经不会成功了，多试验几次，一样不会成功。</p><p>​    出现此问题的原因是，service entry 一直都在发挥作用，前面没报错的原因是默认指定的域名解析是基于 DNS  的。而调整后，我们设置了静态域名解析的方式，并随意给了一个内网 IP 来标识 baidu。kubectl apply service entry 后此配置立刻就被应用在网格内（client）的 envoy，那么在网格内访问 baidu 的时候，流量就被路由到了我们所指定的  192.168.182.188 去了。</p><p>​    执行如下语句删除 service entry，再次登录 client 访问 baidu，发现岁月静好。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589874132638545.png" srcset="/img/loading.gif" lazyload alt="第三十一章 九析带你轻松完爆 Istio - 服务条目 ServiceEntry 实例_istio traffic manag_18"></p><hr><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h1><p>​    使用 service entry  使用场景有哪些？九析这里给你一个场景，比如工作过程中你需要调用外部合作方服务，该服务跟你的集群毫无关系，甚至对方服务可以布置在美国。但是通过服务条目，你可以将对方服务纳入到自己的 Istio 网格之内，就像它本身存在你的集群之内一样，就好像你做了内网拦截一样。而且服务条目可以结合虚拟服务（virtual  service）、目的地规则（destination rule）做更加精细的流量控制，不仅如此，还可以做失败注入、重试等功能。</p><p>​    自此，九析带你轻松完爆 service entry。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - 网关 gateway 实例</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-%E7%BD%91%E5%85%B3-gateway-%E5%AE%9E%E4%BE%8B/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-%E7%BD%91%E5%85%B3-gateway-%E5%AE%9E%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 Istio 网关介绍</p><p>4 Istio 网关实例资源</p><p>  4.1 k8s 服务资源</p><p>  4.2 k8s deployment 资源</p><p>  4.3 Istio virtual service 资源</p><p>  4.4 Istio gateway 资源</p><p>5 istio-ingressgateway 配置</p><p>  5.1 修改 istio-ingressgateway 服务类型</p><p>  5.2 修改 istio-ingressgateway 网络命名空间配置</p><p>​    5.2.1 开启 istio-ingressgateway 容器 80、443 端口</p><p>​    5.2.2 将容器网络空间绑定宿主机网络空间</p><p>6 部署 Istio 资源</p><p>7 访问 istio 网关</p><p>8 总结</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589788560717573.png" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_Docker"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589788568456395.png" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio virtual servi_02"></p><hr><h1 id="3-Istio-网关介绍"><a href="#3-Istio-网关介绍" class="headerlink" title="3 Istio 网关介绍"></a>3 Istio 网关介绍</h1><p>​    在前面的 Istio 系列文章中轻松完爆了 Virtual Service、Destination Rule 等，同时也介绍了网格的概念（Service Mesh，资源被 Istio 注入，在 Pod 中创建并运行了一个 Istio-proxy 容器，该容器内部运行 Envoy  代理）。在本小节将轻松完爆 Istio 网关（gateway）。</p><p>​    Istio  使用网关来管理网格边缘流量（即：入站和出站流量），明确地说是 istio-ingressgateway  管理网格的入口流量，istio-egressgateway 管理网格的出口流量。在以前的章节中，我们了解网格的流量只所以可被管理，是因为资源被  istio 注入后在 Pod 中创建并运行了 istio-proxy 容器的缘故。而网关流量管理的本质也基于同样道理，唯一不同的是  istio-ingressgateway 和 istio-egressgateway 运行时就是一个 istio-proxy 容器，即独立的  Envoy 代理，而不是与 pod 一起运行的 sidecar Envoy 代理。</p><p>​    与其他控制进入系统的流量机制（例如：K8S Ingress API ）不同，Istio 网关充分利用了 Istio 流量路由的功能和灵活性。因为 Istio 的网关资源仅配置 4-6  层负载平衡属性，例如要公开的 port 和 tls 设置等，而将 L7 层（即应用层）流量路由使用 Istio 虚拟服务（virtual  service）绑定网关来实现，这样的一番神操作就可以像管理 Istio 网格中的任何其他数据平面流量一样，来管理网关流量。</p><p>​    k8s ingress 资源如下图所示：</p><p><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio virtual servi_03"><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589788579365947.png" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio traffic manag_04"></p><p>​    由上图可知，在 Ingress 层直接就实现了流量管理。</p><p>​    istio gateway 资源如下图所示：</p><p><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio virtual servi_03"><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589788588283935.png" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio gateway_06"></p><p>​    由上图可知，istio gateway 并不像 k8s ingress 一样直接在网关层实现流量路由，而是通过 virtual service  绑定到网关的机制实现流量路由，这样的方式就像将 virtual service 跟 gateway 解耦一样，大家各司其职。gateway  的作用就是分流，而 virtual service 的作用就是将分流来的流量进行管理。</p><p>​    virtual service 资源如下图所示：</p><p><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio virtual servi_03"><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589788596424833.png" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio traffic manag_08"></p><hr><h1 id="4-Istio-网关实例资源"><a href="#4-Istio-网关实例资源" class="headerlink" title="4 Istio 网关实例资源"></a>4 Istio 网关实例资源</h1><p>​    该实例需要如下四个资源文件，前两个资源是 Istio 专有的，后两个是 k8s 层面的：</p><blockquote><p>jiuxi-gw.yaml        # 网关资源</p><p>jiuxi-vs.yaml        # 虚拟服务资源</p><p>jiuxi-svc.yaml        # k8s 服务资源</p><p>jiuxi-deploy.yaml    # k8s deployment 资源</p></blockquote><h2 id="4-1-k8s-服务资源"><a href="#4-1-k8s-服务资源" class="headerlink" title="4.1 k8s 服务资源"></a>4.1 k8s 服务资源</h2><p><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio virtual servi_03"><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589788605151298.png" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio traffic manag_10"></p><h2 id="4-2-k8s-deployment-资源"><a href="#4-2-k8s-deployment-资源" class="headerlink" title="4.2 k8s deployment 资源"></a>4.2 k8s deployment 资源</h2><p><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio virtual servi_03"><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589788613855533.png" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio traffic manag_12"></p><h2 id="4-3-Istio-virtual-service-资源"><a href="#4-3-Istio-virtual-service-资源" class="headerlink" title="4.3 Istio virtual service 资源"></a>4.3 Istio virtual service 资源</h2><p><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio virtual servi_03"><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589788623896776.png" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio 流量管理_14"></p><h2 id="4-4-Istio-gateway-资源"><a href="#4-4-Istio-gateway-资源" class="headerlink" title="4.4 Istio gateway 资源"></a>4.4 Istio gateway 资源</h2><p><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio virtual servi_03"><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589788633797421.png" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio traffic manag_16"></p><p>​    自此，整个网关运行需要的资源文件已经编写完毕。</p><hr><h1 id="5-istio-ingressgateway-配置"><a href="#5-istio-ingressgateway-配置" class="headerlink" title="5 istio-ingressgateway 配置"></a>5 istio-ingressgateway 配置</h1><h2 id="5-1-修改-istio-ingressgateway-服务类型"><a href="#5-1-修改-istio-ingressgateway-服务类型" class="headerlink" title="5.1 修改 istio-ingressgateway 服务类型"></a>5.1 修改 istio-ingressgateway 服务类型</h2><p>​    默认情况下，istio-ingressgateway 的 k8s 服务类型是 LoadBalancer，因为 LoadBalancer 服务类型一般针对的是云服务商，所以使用基于 NodePort 的 k8s 服务方式。</p><p>​    使用如下命令修改 istio-ingressgateway 服务类型：</p><blockquote><p>kubectl patch svc -n istio-system istio-ingressgateway -p ‘{“spec”: {“type”: “NodePort”}}’</p></blockquote><h2 id="5-2-修改-istio-ingressgateway-网络命名空间配置"><a href="#5-2-修改-istio-ingressgateway-网络命名空间配置" class="headerlink" title="5.2 修改 istio-ingressgateway 网络命名空间配置"></a>5.2 修改 istio-ingressgateway 网络命名空间配置</h2><h3 id="5-2-1-开启-istio-ingressgateway-容器-80、443-端口"><a href="#5-2-1-开启-istio-ingressgateway-容器-80、443-端口" class="headerlink" title="5.2.1 开启 istio-ingressgateway 容器 80、443 端口"></a>5.2.1 开启 istio-ingressgateway 容器 80、443 端口</h3><p>​    使用 kubectl edit deployment -n istio-system istio-ingressgateway 指令编辑资源配置，添加 istio-proxy 容器对外服务端口 80 和 443，截图如下所示：</p><p><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio virtual servi_03"><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589788649368734.png" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio 流量管理_18"></p><h3 id="5-2-2-将容器网络空间绑定宿主机网络空间"><a href="#5-2-2-将容器网络空间绑定宿主机网络空间" class="headerlink" title="5.2.2 将容器网络空间绑定宿主机网络空间"></a>5.2.2 将容器网络空间绑定宿主机网络空间</h3><p>​    执行此步是因为 istio gateway 资源指定名为 jiuxi-gw 的 host 端口为 80，而上面 istio-ingressgateway 的  NodePort 服务端口默认只能处于 30000 ~ 32767 之间，所以基于“jiuxi-gw：NodePort”方式是无法访问到  istio gateway 的。如果要直接通过 istio gateway 访问，需要开放 istio-ingressgateway pod 的 hostNetwork 配置项：</p><p>​    使用 kubectl edit deployment -n istio-system istio-ingressgateway 指令编辑资源配置：</p><p><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio virtual servi_03"><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589788660219227.png" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio gateway_20"></p><p>​    修改完毕后，执行如下命令查看 istio-ingressgateway pod 所在宿主机 IP：</p><p><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio virtual servi_03"><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589788676122086.png" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio virtual servi_22"></p><p>​    ssh 登录宿主机 IP（本人是 10.110.101.203），执行如下指令验证是否宿主机开启了 80 端口：</p><p><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio virtual servi_03"><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589788686108792.png" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio gateway_24"></p><hr><h1 id="6-部署-Istio-资源"><a href="#6-部署-Istio-资源" class="headerlink" title="6 部署 Istio 资源"></a>6 部署 Istio 资源</h1><p>​    执行如下语句部署前面创建的 4 个 Istio 资源：</p><blockquote><p>kubectl apply -f .</p></blockquote><p>​    执行结果如下图所示：</p><p><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio virtual servi_03"><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589788693327159.png" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_Docker_26"></p><hr><h1 id="7-访问-istio-网关"><a href="#7-访问-istio-网关" class="headerlink" title="7 访问 istio 网关"></a>7 访问 istio 网关</h1><p>​    随便找一台虚拟机，编辑 /etc/hosts 文件，添加 istio-ingressgateway pod 所在主机映射：</p><p><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio virtual servi_03"><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589788702452360.png" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio gateway_28"></p><p>​    映射内容如下：</p><blockquote><p>10.110.101.203 jiuxi.gw.org</p></blockquote><p>​    使用 curl 命令行访问 jiuxi.gw.org，发现基于 gateway 的流量管理已经生效（即：负载均衡权重为 50 - 50）。</p><hr><h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8 总结"></a>8 总结</h1><p>​    在 istio 中，有关 istio-ingressgateway、gateway、virtual service 和 destination rule 之间的关系很容易让大家引起混淆。其实你不妨这么来理解：</p><p>​    istio-ingressgateway 作用就像飞机场的出口，这里承载了所有的流量；gateway 作用就像旅行社，起到了分流的作用；virtual service  指旅行社的导游，起到了对分流后的流量进行管理和路由的作用；而 destination rule 就像导游指派的大巴一样，将 vs  的流量路由到真正的地方去。</p><p>​    自此，九析带你们轻松完爆了 Istio 的 gateway。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - 网络流向之 iptables chain</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-%E7%BD%91%E7%BB%9C%E6%B5%81%E5%90%91%E4%B9%8B-iptables-chain/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-%E7%BD%91%E7%BB%9C%E6%B5%81%E5%90%91%E4%B9%8B-iptables-chain/</url>
    
    <content type="html"><![CDATA[<p> 前言</p><p>2 邀约</p><p>3 正文</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>​    如果你对博客有任何疑问，请告诉我。<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587895000811110.png" srcset="/img/loading.gif" lazyload alt="第二十九章 九析带你轻松完爆 Istio - 网络流向之 iptables chain_istio 视频"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587895007995640.png" srcset="/img/loading.gif" lazyload alt="第二十九章 九析带你轻松完爆 Istio - 网络流向之 iptables chain_k8s 视频_02"></p><hr><h1 id="3-正文"><a href="#3-正文" class="headerlink" title="3 正文"></a>3 正文</h1><p>​    一切都是那么明亮，光线照在身上，暖暖的。</p><p>​    仰起头，依稀能听到风声。庭院里早春的鸟儿在围墙上啁啾，三五个下人在打扫着庭院，丫鬟婆子们在天井嗑着瓜子闲聊天，嬉笑声惊动了房脊上的信鸽，扑棱棱扇动双翅滑向远处湛蓝的天空……</p><p>​    我是刘全，和府的总管。外表虽然光鲜，实质却仍是一个仆人。我清楚知道自己的身份，每天小心谨慎、兢兢业业、如履薄冰般尽忠职守，日复一日、年复一年。</p><p>​    很多人背后指责我狐假虎威、狗仗人势，我不解释也不能解释。我明白很多脏活必须我来做，很多坏人必须我来当。我必须做到多面，这是我的工作，更是我的天职。我知道太多讳莫如深、彼此心知肚明、但又不能点破说破的潜规则，我只能自己默默消化。我不被人理解，我习惯了。很多时候我都必须像鹰一般敏锐注视整个府邸的动态，并时时保持警惕，我不能有一丝疏漏，我不能让大人为难。</p><p>​    一切波澜不惊之下往往隐藏着狂流暗涌。</p><p>​    庞大帝国的中枢体系并不在黄墙之内，而是尽在府邸之中。1300 万平方公里疆域的数据全部汇集于此，并在此处做流转、做分发。咫尺便是天涯、天涯又近在咫尺。</p><p>​    每天这里都在上演国泰民安、妻离子散；朔漠狼烟、塞外江南……</p><p>​    我观望、处理、不带感情。晨钟暮鼓、安之若素。</p><p>​    繁重的工作并没有将我压垮，因为我并不是一个人……</p><p>​    我的用人标准很简单：少而精、懂协作。基于此，经过层层筛选和选拔，最后我把目光锁定在五个人身上（扑入锐、英扑特、鳌扑特、佛卧德、剖思特），这五个人各司其职，协调和控制整个帝国信息流的脉络走向。</p><blockquote><p>扑入锐：奏折入口。核查奏折是否跟和府有关。如果跟和府有关则将奏折转给英扑特。</p><p>英扑特：接收来自扑入锐的奏折，并做规则检查，通过的奏折转给和府内部事务部门处理</p><p>熬扑特：接受和府内部事务部门写的奏折或者批示英扑特递交的折子，并做规则检查，检查并处理完毕后交给剖思特。</p><p>佛卧德：接受来自扑入锐的奏折，这些奏折表面跟和府无关，经过规则检查之后，直接转给剖思特。</p><p>剖思特：接受来自鳌扑特和佛卧德的奏折，并做规则检查。处理完把它们送到该送的地方去。</p></blockquote><p>​    整个数据信息流的处理极其缜密。我将他们紧紧编制在我设计的链条里。我观察着他们，规范着他们的一举一动。每天我都要把这一幕幕绘制成图，然后牢牢地印在我的脑海里。<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587894981198101.png" srcset="/img/loading.gif" lazyload alt="第二十九章 九析带你轻松完爆 Istio - 网络流向之 iptables chain_istio 视频_03"></p><p>============================================================================</p><p>​    数据在主机中的具体流向，一般会有三种路径：</p><blockquote><p>第一：数据报文通过网络、流经网卡、进入主机。经过检查，数据报文目标如果是本机，则将报文送到用户空间中的相关进程进行处理。</p><p>第二：数据报文通过网络、流经网卡、进入主机。经过检查，数据报文目标如果不是本机，则将报文直接通过网卡再发送到其他主机</p><p>第三：用户空间的进程产生数据报文，并将此报文通过内核空间的网络协议栈发送给网卡，再通过网卡把数据报文发送给其他主机</p></blockquote><p>​    如果数据只是在主机里流來流去，而不施加任何规则的话，世界就不会这么复杂。但是往往事与愿违，如果有人要恶意破坏系统怎么办呢？</p><p>​    就像刘全为了避免不利于和府的奏折流到皇上那里而设置五人关卡一样。linux 也采用了同样的机制来控制数据流，更为巧合地是，也是五道关卡。</p><blockquote><p>prerouting（扑入锐）</p><p>input（英扑特）</p><p>forward（佛卧德）</p><p>output（鳌扑特）</p><p>postrouting（剖思特）</p></blockquote><p>​    iptables 通过在上述五道关卡上设置更多的规则来对主机中流动的数据做流向控制。数据流向图如下所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587894989758506.png" srcset="/img/loading.gif" lazyload alt="第二十九章 九析带你轻松完爆 Istio - 网络流向之 iptables chain_istio 视频_04"></p><p>​    未完待续……</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - 网络包之 iptables netfilter 关系</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-%E7%BD%91%E7%BB%9C%E5%8C%85%E4%B9%8B-iptables-netfilter-%E5%85%B3%E7%B3%BB/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-%E7%BD%91%E7%BB%9C%E5%8C%85%E4%B9%8B-iptables-netfilter-%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 正文</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>​    如果你对博客有任何疑问，请告诉我。<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587698518570214.png" srcset="/img/loading.gif" lazyload alt="第二十八章 九析带你轻松完爆 Istio - 网络包之 iptables netfilter 关系_k8s iptables"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587698527213780.png" srcset="/img/loading.gif" lazyload alt="第二十八章 九析带你轻松完爆 Istio - 网络包之 iptables netfilter 关系_iptables_02"></p><hr><h1 id="3-正文"><a href="#3-正文" class="headerlink" title="3 正文"></a>3 正文</h1><p>​    淅淅沥沥的雨不像下在外面，而是下在心里。</p><p>​    清秀的男人推开重重的府门，外面的光线一点点透进去，就像蹑手蹑脚的小偷，悄无声息。空间中有潮湿木头腐朽的味道，男人微皱一下浓眉。</p><p>​    房间本是宽敞，却被大大小小的箱子叠床架屋，所以显得异常逼仄。箱子质地坚硬结实，仿佛从纹理就能看出里面的价值。有些锁已经有了锈的痕迹，但却依然古色古香。</p><p>​    雨声似乎大了些，淅淅沥沥打在青石板的门阶上。男人透过门缝瞥了瞥远方，挡住视线的是一幢一幢的深不可测的门房。</p><p>​    这里曾经风雨西窗，这里也曾衰草枯杨……</p><p>​    男人收回目光，垂下眼睑，沉浸在一片静穆之中。</p><p>​    远远的脚步声近了，门被打开又被迅速关上。一个俊俏的小厮满脸笑容又恭恭敬敬地靠近。</p><p>​    老爷，这是新纳贡的单子。</p><blockquote><p>山东府台跟我们素有不合，他上贡皇上的礼品我统一给挡了。</p><p>福建的礼品有些我觉得老佛爷不喜欢，就暂放在老爷的府上，其它我觉得合适的就送上去了。</p><p>两江总督的进献的礼品太过豪奢，恐圣上震怒伤了身子，我全部都先扣下来暂存在老爷府上等待发落。</p><p>……</p></blockquote><p>​    男人一言不发，似乎注意力全不在这里。他对小厮做事绝对是放心的。自从他当了总管之后，大大小小的规则都是他制定的。一次疏忽或纰漏都不曾有过。男人此刻心中所想到底是什么，恐怕只有他自己知道。</p><p>============================================================================</p><p>​    男人叫和珅、小厮叫刘全。</p><p>​    和珅是帝国的柱石，它是整个帝国系统的“安全框架”，他深不可测，位于整个系统的内核空间，不可直接触达，他掌握整个帝国的数据走向。</p><p>​    刘全是和珅的代理。他是和珅的心腹，为和珅出谋划策、制定一系列的事情处理规则。他不处于高墙之内，仅浮沉在市井的用户空间，却具有跟内核态打交道的能力。</p><p>============================================================================</p><p>​    和珅就像 linux 内核中的 netfilter 安全框架，而刘全就是 netfilter 的客户端代理工具 iptables。通过刘全，可以将相应的规则作用在和珅之上。</p><p>​    netfilter 是 linux 操作系统核心层的一个数据包处理模块，主要功能如下：</p><blockquote><p>数据包过滤功能</p><p>数据包内容修改</p><p>数据包网络地址转换（NAT，net address translate）</p></blockquote><p>​    iptables 则是一个客户端工具，可以通过 iptables 制定一系列的规则，最终作用在 netfilter 之上，起到发挥 netfilter 功能，控制数据包流向与控制的作用。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - k8s 流量进入集群之 Ingress</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-k8s-%E6%B5%81%E9%87%8F%E8%BF%9B%E5%85%A5%E9%9B%86%E7%BE%A4%E4%B9%8B-Ingress/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-k8s-%E6%B5%81%E9%87%8F%E8%BF%9B%E5%85%A5%E9%9B%86%E7%BE%A4%E4%B9%8B-Ingress/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 Ingress 介绍</p><p>4 ingress 实例</p><p>  4.1 ingress 资源文件</p><p>  4.2 service 资源文件</p><p>  4.3 pod 资源文件</p><p>5 访问 ingress</p><p>  5.1 获取 ingress HOST</p><p>  5.2 域名解析绑定</p><p>  5.3 访问 ingress</p><p>6 结论</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>​    如果你对博客有任何疑问，请告诉我。<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587613783382115.png" srcset="/img/loading.gif" lazyload alt="第二十七章 九析带你轻松完爆 Istio - k8s 流量进入集群之 Ingress_k8s 视频"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587613790304553.png" srcset="/img/loading.gif" lazyload alt="第二十七章 九析带你轻松完爆 Istio - k8s 流量进入集群之 Ingress_ingress-controller_02"></p><hr><h1 id="3-Ingress-介绍"><a href="#3-Ingress-介绍" class="headerlink" title="3 Ingress 介绍"></a>3 Ingress 介绍</h1><p>​    Ingress 中文含义就是“入口”，非常形象地定义了这种资源的本质：Ingress 就是 k8s 的门户。</p><p>​    就像一幢建筑物，比如酒店、商场等，不止一个入口，k8s 也可以定义多个入口放流量进来。</p><p>​    k8s 集群必须部署一个 Ingress 控制器（比如 nginx、traefik 等），Ingress 控制器的作用就是创建 Ingress  资源，好让其生效。Ingress 控制器跟 Ingress 的关系就像 nginx 跟 nginx.conf( nginx 配置文件) 一样。</p><p>​    Ingress 控制器容器内一般有两个关键的进程，分别是一个负载均衡器（比如 nginx、haproxy 等）和一个控制器守护进程。控制器守护进程会从 k8s 接收所需的 Ingress 创建需求，并将其生成一个 nginx 或 haproxy 的配置片段，并重新加载负载均衡器来使其生效。</p><p>​    就拿 nginx-ingress-controller 举例，nginx 是 nginx-ingress-controller 内部进程，也是其负载均衡器，而 nginx-ingress-controller 是 k8s 的负载均衡器。</p><p>nginx-ingress-controller 内部进程截图如下所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587613800164339.png" srcset="/img/loading.gif" lazyload alt="第二十七章 九析带你轻松完爆 Istio - k8s 流量进入集群之 Ingress_k8s 视频_03"></p><hr><h1 id="4-ingress-实例"><a href="#4-ingress-实例" class="headerlink" title="4 ingress 实例"></a>4 ingress 实例</h1><p>​    如果要展示 ingress 实例，需要三个资源文件：</p><blockquote><p>1 ingress 流量入口资源文件</p><p>2 service 流量从入口进入后的流向资源文件</p><p>3 pod 流量最终目的地资源文件</p></blockquote><h2 id="4-1-ingress-资源文件"><a href="#4-1-ingress-资源文件" class="headerlink" title="4.1 ingress 资源文件"></a>4.1 ingress 资源文件</h2><p><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第二十七章 九析带你轻松完爆 Istio - k8s 流量进入集群之 Ingress_k8s 视频_04"><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587613808888408.png" srcset="/img/loading.gif" lazyload alt="第二十七章 九析带你轻松完爆 Istio - k8s 流量进入集群之 Ingress_k8s 视频_05"></p><h2 id="4-2-service-资源文件"><a href="#4-2-service-资源文件" class="headerlink" title="4.2 service 资源文件"></a>4.2 service 资源文件</h2><p><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第二十七章 九析带你轻松完爆 Istio - k8s 流量进入集群之 Ingress_k8s 视频_04"><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587613813933169.png" srcset="/img/loading.gif" lazyload alt="第二十七章 九析带你轻松完爆 Istio - k8s 流量进入集群之 Ingress_ingress-controller_07"></p><h2 id="4-3-pod-资源文件"><a href="#4-3-pod-资源文件" class="headerlink" title="4.3 pod 资源文件"></a>4.3 pod 资源文件</h2><p><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第二十七章 九析带你轻松完爆 Istio - k8s 流量进入集群之 Ingress_k8s 视频_04"><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587613818578144.png" srcset="/img/loading.gif" lazyload alt="第二十七章 九析带你轻松完爆 Istio - k8s 流量进入集群之 Ingress_ingress-controller_09"></p><hr><h1 id="5-访问-ingress"><a href="#5-访问-ingress" class="headerlink" title="5 访问 ingress"></a>5 访问 ingress</h1><h2 id="5-1-获取-ingress-HOST"><a href="#5-1-获取-ingress-HOST" class="headerlink" title="5.1 获取 ingress HOST"></a>5.1 获取 ingress HOST</h2><p>​    上面介绍了 nginx-ingress-controller 其实就是 k8s 的负载均衡器，或者说 nginx-ingress-controller  就是 k8s 的 nginx。那么 nginx-ingress-controller pod 所在宿主机地址就是 k8s  的入口地址。如下截图所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587613823485947.png" srcset="/img/loading.gif" lazyload alt="第二十七章 九析带你轻松完爆 Istio - k8s 流量进入集群之 Ingress_k8s ingress_10"></p><p>​    因为我的 nginx-ingress-controller pod 直接采用的是 hostNetwork: true，也就是使用了宿主机的网络命名空间。因此这里的 Pod IP 就是宿主机的 IP，也就是说访问的时候可以直接使用此 IP。</p><h2 id="5-2-域名解析绑定"><a href="#5-2-域名解析绑定" class="headerlink" title="5.2 域名解析绑定"></a>5.2 域名解析绑定</h2><p>​    编辑 /etc/hosts（centos）文件，添加域名解析定义：</p><blockquote><p>10.110.101.100    ingress.jiuxi.org</p></blockquote><h2 id="5-3-访问-ingress"><a href="#5-3-访问-ingress" class="headerlink" title="5.3 访问 ingress"></a>5.3 访问 ingress</h2><p>​    执行如下命令访问 ingress：</p><blockquote><p>curl <a href="http://ingress.jiuxi.org/"> http://ingress.jiuxi.org</a></p></blockquote><p>​    命令执行结果如下所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587613831548777.png" srcset="/img/loading.gif" lazyload alt="第二十七章 九析带你轻松完爆 Istio - k8s 流量进入集群之 Ingress_nginx-ingress-contr_11"></p><hr><h1 id="6-结论"><a href="#6-结论" class="headerlink" title="6 结论"></a>6 结论</h1><p>​    使用 nodeport、loadbalancer 跟 ingress 在实现路由方式上有所不同。对于 loadbalancer 和  nodeport，都是将流量导入到节点上的 kube-proxy 进程，后者再将流量转发到后面的 pod。而 Ingress  负载均衡器则将流量直接转发到选定的 Pod，这样效率更高。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - k8s 流量进入集群之 NodePort</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-k8s-%E6%B5%81%E9%87%8F%E8%BF%9B%E5%85%A5%E9%9B%86%E7%BE%A4%E4%B9%8B-NodePort/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-k8s-%E6%B5%81%E9%87%8F%E8%BF%9B%E5%85%A5%E9%9B%86%E7%BE%A4%E4%B9%8B-NodePort/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 NodePort 样例</p><p>4 访问流程</p><p>5 实例演示</p><p>6 缺点</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>​    如果你对博客有任何疑问，请告诉我。<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587550119779184.png" srcset="/img/loading.gif" lazyload alt="第二十六章 九析带你轻松完爆 Istio - k8s 流量进入集群之 NodePort_k8s 视频"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587550126151290.png" srcset="/img/loading.gif" lazyload alt="第二十六章 九析带你轻松完爆 Istio - k8s 流量进入集群之 NodePort_k8s nodeport_02"></p><hr><h1 id="3-NodePort-样例"><a href="#3-NodePort-样例" class="headerlink" title="3 NodePort 样例"></a>3 NodePort 样例</h1><p>​    跟 hostNetwork 和 hostPort 不同，NodePort 属于 service 类型之一。hostPort 和 hostNetwork 作用对象是 Pod，而 NodePort 作用对象则是 service。</p><p>​    pod 文件如下所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587550204849539.png" srcset="/img/loading.gif" lazyload alt="第二十六章 九析带你轻松完爆 Istio - k8s 流量进入集群之 NodePort_istio 教程_03"></p><p>​    service 文件如下：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587550210984313.png" srcset="/img/loading.gif" lazyload alt="第二十六章 九析带你轻松完爆 Istio - k8s 流量进入集群之 NodePort_istio 教程_04"></p><p>​    创建 NodePort 服务时，用户可以在 30000 ~ 32767 范围内指定一个端口，也可以通过 patch 打补丁的方式修改 service 类型，这样 NodePort 端口将会在范围 30000 ~ 32767 之间自动分配。</p><blockquote><p>kubectl patch svc svc_name -n ns_name -p ‘{“type”: “NodePort”}’</p></blockquote><hr><h1 id="4-访问流程"><a href="#4-访问流程" class="headerlink" title="4 访问流程"></a>4 访问流程</h1><p>​    下图展示当 k8s svc 创建之后，k8s 集群内部都发生了哪些变化。<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587550218909632.png" srcset="/img/loading.gif" lazyload alt="第二十六章 九析带你轻松完爆 Istio - k8s 流量进入集群之 NodePort_istio 视频_05"></p><p>​    当 client 发送 kubectl apply 指令给 APIServer 后，会生成相关的 service 对象，k8s 集群内的所有节点（master 和 node）上都会运行 kube-proxy 进程，如下截图所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587550225387994.png" srcset="/img/loading.gif" lazyload alt="第二十六章 九析带你轻松完爆 Istio - k8s 流量进入集群之 NodePort_istio 视频_06"></p><p>​    该进程的作用就是负责跟 APIServer 进行通信并对 node 上的 pod 进行生命周期管理。如果创建了 k8s service ，那么 kube-proxy  会创建相应的 iptables 规则，并将发送到 service nodePort 的流量转发到 service 后端提供的 Pod  的相应端口上。</p><hr><h1 id="5-实例演示"><a href="#5-实例演示" class="headerlink" title="5 实例演示"></a>5 实例演示</h1><p>​    当执行 jiuxi-svc.yaml 资源文件后，如下截图所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587550231487434.png" srcset="/img/loading.gif" lazyload alt="第二十六章 九析带你轻松完爆 Istio - k8s 流量进入集群之 NodePort_k8s nodeport_07"></p><p>​    查看网络监控接口可知 30088 对应的服务进程就是 kube-proxy，如下图所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587550237774324.png" srcset="/img/loading.gif" lazyload alt="第二十六章 九析带你轻松完爆 Istio - k8s 流量进入集群之 NodePort_k8s nodeport_08"></p><p>​    当我们通过 curl 访问 hostIP:30088 时，数据包会通过 30088 端口送给 kube-proxy 进程，kube-proxy 进程会根据 k8s service 的 endpoint 将数据包路由到实际的 pod IP 和对应的端口去。如下截图查看 service 对应的  endpoints。<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587550245651146.png" srcset="/img/loading.gif" lazyload alt="第二十六章 九析带你轻松完爆 Istio - k8s 流量进入集群之 NodePort_istio 视频_09"></p><hr><h1 id="6-缺点"><a href="#6-缺点" class="headerlink" title="6 缺点"></a>6 缺点</h1><p>​    使用 NodePort 方式，在 k8s 集群内部，每个节点（master 或 node）上 kube-proxy 进程都会开启相关的端口。如果服务都采用这样的方式，端口就有冲突的可能。因此建议谨慎使用。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - k8s 流量进入集群之 hostPort</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-k8s-%E6%B5%81%E9%87%8F%E8%BF%9B%E5%85%A5%E9%9B%86%E7%BE%A4%E4%B9%8B-hostPort/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-k8s-%E6%B5%81%E9%87%8F%E8%BF%9B%E5%85%A5%E9%9B%86%E7%BE%A4%E4%B9%8B-hostPort/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 hostPort 样例</p><p>4 hostPort 与 hostNetwork 异同</p><p>  4.1 相同点</p><p>  4.2 不同点</p><p>5 hostPort 使用场景</p><p>6 注意</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>​    如果你对博客有任何疑问，请告诉我。<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587465765267666.png" srcset="/img/loading.gif" lazyload alt="第二十五章 九析带你轻松完爆 Istio - k8s 流量进入集群之 hostPort_istio 流量管理"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587465773277912.png" srcset="/img/loading.gif" lazyload alt="第二十五章 九析带你轻松完爆 Istio - k8s 流量进入集群之 hostPort_k8s 视频_02"></p><hr><h1 id="3-hostPort-样例"><a href="#3-hostPort-样例" class="headerlink" title="3 hostPort 样例"></a>3 hostPort 样例</h1><p>​    样例代码如下所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587465780365910.png" srcset="/img/loading.gif" lazyload alt="第二十五章 九析带你轻松完爆 Istio - k8s 流量进入集群之 hostPort_k8s hostPort_03"></p><p>​    pod 发布之后，便会将容器端口开放给了外部网络。外部可以通过 pod 所在宿主机和 hostPort 值访问到 Pod 内的容器提供的服务。</p><hr><h1 id="4-hostPort-与-hostNetwork-异同"><a href="#4-hostPort-与-hostNetwork-异同" class="headerlink" title="4 hostPort 与 hostNetwork 异同"></a>4 hostPort 与 hostNetwork 异同</h1><h2 id="4-1-相同点"><a href="#4-1-相同点" class="headerlink" title="4.1 相同点"></a>4.1 相同点</h2><p>​    hostPort 与 hostNetwork 本质上都是暴露 pod 宿主机 IP 给终端用户，因为 pod 生命周期并不固定，随时都有可能被完爆，故 IP  的不确定最终导致用户使用上的不方便；此外宿主机端口占用也导致不能在同一台机子上有多个程序使用同一端口。因此一般情况下，不要使用 hostPort 方式。</p><h2 id="4-2-不同点"><a href="#4-2-不同点" class="headerlink" title="4.2 不同点"></a>4.2 不同点</h2><p>​    使用 hostNetwork，pod 实际上用的是 pod 宿主机的网络地址空间：即 pod  IP 是宿主机 IP，而非 cni 分配的 pod IP，端口是宿主机网络监听接口。</p><p>使用 hostPort，pod IP 并非宿主机 IP，而是 cni 分配的 pod IP，跟其他普通的 pod 使用一样的 ip  分配方式，端口并非宿主机网络监听端口，只是使用了 DNAT 机制将 hostPort 指定的端口映射到了容器的端口之上（可以通过  iptables 命令进行查看）。外部访问此 pod 时，仍然使用宿主机和 hostPort 方式。pod ip 跟宿主机 ip 截图如下：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587465825662942.png" srcset="/img/loading.gif" lazyload alt="第二十五章 九析带你轻松完爆 Istio - k8s 流量进入集群之 hostPort_istio 流量管理_04"></p><p>​    有关端口 DNAT 通过 iptables 命令进行查看，如下截图所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587465835982578.png" srcset="/img/loading.gif" lazyload alt="第二十五章 九析带你轻松完爆 Istio - k8s 流量进入集群之 hostPort_istio 视频_05"></p><p>​    由上图可知，pod 所在宿主机上的 iptables nat 表流向如下：</p><blockquote><p>1 当客户端发起 pod 访问时，比如 curl <a href="http://pod_in_host:hostPort">http://pod_in_host:hostPort</a></p><p>2 网络包会流经 pod 宿主机的 prerouting chain，会命中 CNI-HOSTPORT-DNAT 链</p><p>3 网络包会流经 CNI-HOSTPORT_DNAT 链中的第 3 条规则，即 DNAT 目标，此时会将 9998 端口访问的流量路由到 80 端口去</p></blockquote><p>​    基于此，当客户端访问 pod 所在主机的 9998 端口时，流量会自动被路由到 IP 为 10.244.11.55（也就是 pod ip）的 80 端口上。</p><hr><h1 id="5-hostPort-使用场景"><a href="#5-hostPort-使用场景" class="headerlink" title="5 hostPort 使用场景"></a>5 hostPort 使用场景</h1><p>​    nginx-ingress-controller 就使用到了 hostPort 方式，同时开启了 80 和 443 端口，如下截图所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587465846114894.png" srcset="/img/loading.gif" lazyload alt="第二十五章 九析带你轻松完爆 Istio - k8s 流量进入集群之 hostPort_istio 视频_06"></p><hr><h1 id="6-注意"><a href="#6-注意" class="headerlink" title="6 注意"></a>6 注意</h1><p>​    当 pod 同时使用了 hostNetwork 和 hostPort，那么 hostNetwork 将会直接使用宿主机网络命名空间，hostPort 其实就形同虚设了。可以认为 hostNetwork 选项优先级要高于 hostPort。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - k8s 流量进入集群之 hostNetwork</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-k8s-%E6%B5%81%E9%87%8F%E8%BF%9B%E5%85%A5%E9%9B%86%E7%BE%A4%E4%B9%8B-hostNetwork/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-k8s-%E6%B5%81%E9%87%8F%E8%BF%9B%E5%85%A5%E9%9B%86%E7%BE%A4%E4%B9%8B-hostNetwork/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 k8s 流量进入集群方式</p><p>4 hostNetwork 样例</p><p>5 hostNetwork 影响</p><p>  5.1 Pod IP 和 Port</p><p>  5.2 node 个数跟 pod 副本数</p><p>6 hostNetwork 使用场景</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>​    如果你对博客有任何疑问，请告诉我。<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587352067700864.png" srcset="/img/loading.gif" lazyload alt="第二十四章 九析带你轻松完爆 Istio - k8s 流量进入集群之 hostNetwork_istio 视频"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587352077750654.png" srcset="/img/loading.gif" lazyload alt="第二十四章 九析带你轻松完爆 Istio - k8s 流量进入集群之 hostNetwork_k8s 视频_02"></p><hr><h1 id="3-k8s-流量进入集群方式"><a href="#3-k8s-流量进入集群方式" class="headerlink" title="3 k8s 流量进入集群方式"></a>3 k8s 流量进入集群方式</h1><p>​    k8s 集群外的流量如果要进入 k8s，通常有如下几种方式：</p><blockquote><p>hostNetwork</p><p>NodePort</p><p>ClusterIP</p><p>LoadBalancer</p><p>Ingress</p><p>hostPort</p></blockquote><p>​    本节重点介绍 hostNetwork 方式。</p><hr><h1 id="4-hostNetwork-样例"><a href="#4-hostNetwork-样例" class="headerlink" title="4 hostNetwork 样例"></a>4 hostNetwork 样例</h1><p>​    截图如下：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587352085511041.png" srcset="/img/loading.gif" lazyload alt="第二十四章 九析带你轻松完爆 Istio - k8s 流量进入集群之 hostNetwork_istio 网络_03"></p><p>​    hostNetwork 只能作用在 Pod 上。如果 Pod 开启了 hostNetwork: true，则该 Pod 直接使用当前宿主机的网络空间，如果 Pod  内的进程需要开启网络监听接口，就会直接在当前宿主机开启。如上图可知一个 Pod 内运行一个 busybox 的容器，该 busybox 容器内的 httpd 进程会开启 8888 网络监听端口，而该端口会直接开启在 Pod 所在宿主机上。</p><hr><h1 id="5-hostNetwork-影响"><a href="#5-hostNetwork-影响" class="headerlink" title="5 hostNetwork 影响"></a>5 hostNetwork 影响</h1><h2 id="5-1-Pod-IP-和-Port"><a href="#5-1-Pod-IP-和-Port" class="headerlink" title="5.1 Pod IP 和 Port"></a>5.1 Pod IP 和 Port</h2><p>​    如果 Pod 采用主机网络策略（hostNetwork：true），其 IP 就是宿主机的 IP，其 Port 就是宿主机的 Port。如下图所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587352096237988.png" srcset="/img/loading.gif" lazyload alt="第二十四章 九析带你轻松完爆 Istio - k8s 流量进入集群之 hostNetwork_k8s 网络_04"></p><h2 id="5-2-node-个数跟-pod-副本数"><a href="#5-2-node-个数跟-pod-副本数" class="headerlink" title="5.2 node 个数跟 pod 副本数"></a>5.2 node 个数跟 pod 副本数</h2><p>​    如果 Pod 采用主机网络策略（hostNetwork：true），Pod 副本数不能超过 node 数，因为 pod 最终会采用 node  的网络命名空间，如果 pod 副本数多于 node 数，则会有些 pod 不能创建成功。如下图所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587352103773057.png" srcset="/img/loading.gif" lazyload alt="第二十四章 九析带你轻松完爆 Istio - k8s 流量进入集群之 hostNetwork_istio 网络_05"></p><p>​    由上图可知，因为采用了 hostNetwork，所以在同一个 Node 节点（k8s-w-202）上就不能同时运行两个 pod，因为该 pod 都使用了同一个网络端口 8888。如下日志截图可知：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587352110241577.png" srcset="/img/loading.gif" lazyload alt="第二十四章 九析带你轻松完爆 Istio - k8s 流量进入集群之 hostNetwork_k8s 网络_06"></p><p>​    自此，我们可以得知，使用 hostNetwork 具有相当大的局限，首先 Pod 有可能被完爆，所以如果直接采用 IP 的方式跟 Pod  打交道会有不可预期的后果。此外，随着宿主机运行程序的增多，端口冲突的概率就会大大增加，因此 hostNetwork 的采用必须慎之又慎。</p><hr><h1 id="6-hostNetwork-使用场景"><a href="#6-hostNetwork-使用场景" class="headerlink" title="6 hostNetwork 使用场景"></a>6 hostNetwork 使用场景</h1><p>​    一般情况下使用 hostNetwork 的场景多用在操作或者管理宿主机的网络环境上，比如我们经常使用的网络插件，比如 flannel、canal  等。这些网络插件可以完全控制集群中每个节点上的网络，比如可以将其他 pod （hotNetwork：false）连接到 overlay  网络中。下图展示本人的 canal 网络插件 pod 的配置：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587352121991492.png" srcset="/img/loading.gif" lazyload alt="第二十四章 九析带你轻松完爆 Istio - k8s 流量进入集群之 hostNetwork_istio 视频_07"></p><p>​        </p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - destination rule 介绍</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-destination-rule-%E4%BB%8B%E7%BB%8D/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-destination-rule-%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 介绍</p><p>4 路由策略</p><p>5 样例说明</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>​    如果你对博客有任何疑问，请告诉我。<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586941964975167.png" srcset="/img/loading.gif" lazyload alt="第二十三章 九析带你轻松完爆 Istio - destination rule 介绍_Istio destination r"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586941972382785.png" srcset="/img/loading.gif" lazyload alt="第二十三章 九析带你轻松完爆 Istio - destination rule 介绍_Istio 视频_02"></p><hr><h1 id="3-介绍"><a href="#3-介绍" class="headerlink" title="3 介绍"></a>3 介绍</h1><p>​    上章展示了 destination rule 一个实例。</p><p>​    destination rules 是 Istio 流量路由的关键功能，它不能独自使用，必须跟 Virtual Service 共同发挥作用。当  destination rules 跟 virtual service 共同使用的时候，virtual service  决定将流量路由到逻辑地址，而 destination rules 则决定流量路由到物理地址。</p><p>​    virtual service 跟 destination rules 路由关系就像变量到内存的地址映射一样，destination 代表内存实际地址，而 virtual service 作用就像程序的指针。</p><p>​    destination rules 通常用在微服务的版本分组上（例如可以通过 version 标签将微服务进行分组）。通过 destination rules  的分组规则可以实现将流量路由到服务的不同版本中，进而实现类似灰度、金丝雀、蓝绿等版本分流的策略。</p><p>​    destination rules 不仅可以决定把流量路由到何处，还可以制定如何路由流量（比如是轮询路由流量，还是随机路由流量等等）。有关 destination rules 选项可以参考 <a href="https://istio.io/docs/reference/config/networking/destination-rule/"> Destination Rule 指南</a>。</p><hr><h1 id="4-路由策略"><a href="#4-路由策略" class="headerlink" title="4 路由策略"></a>4 路由策略</h1><p>​    默认情况下，Istio 使用轮询的负载均衡路由策略（round-robin），也就是说服务所有实例按顺序接收请求。当然 Istio 也支持如下的模型，这些模型都可以通过在 destination rule 中进行指定：</p><blockquote><p>Random：请求被随机分配给服务的实例</p><p>Weighted：请求基于权重被分配给服务的实例</p><p>Least requests：请求被分配给服务最少被访问的实例</p></blockquote><hr><h1 id="5-样例说明"><a href="#5-样例说明" class="headerlink" title="5 样例说明"></a>5 样例说明</h1><p>​    Istio 官方给出的 destination rule 样例如下：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586941984155387.png" srcset="/img/loading.gif" lazyload alt="第二十三章 九析带你轻松完爆 Istio - destination rule 介绍_Istio 流量管理_03"></p><p>​    上例 destination rule 中指定了 subsets，子集是根据 version 来定义。注意，这里 labels  内容可以自由定义，不一定非要是 version。其中的 trafficPolicy  就是流量路由到服务所有实例的策略（比如随机、轮询、按权重、最少访问等）。此外针对 v2 这个  subsets，它的路由策略比较特殊，它覆盖了默认的 RANDOM 方式，而是直接采用了 ROUND_ROBIN 方式。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - destination rule 实例</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-destination-rule-%E5%AE%9E%E4%BE%8B/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-destination-rule-%E5%AE%9E%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 介绍</p><p>4 灰度</p><p>5 destination rule 样例</p><p>  5.1 客户端资源文件</p><p>  5.2 deployment 资源文件</p><p>  5.3 service 资源文件</p><p>  5.4 Istio virtual service 资源文件</p><p>  5.5 Istio destination rule 资源文件</p><p>6 Istio 注入</p><p>7 验证 destination rule</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586921192580920.png" srcset="/img/loading.gif" lazyload alt="第二十二章 九析带你轻松完爆 Istio - destination rule 实例_Istio 流量管理"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586921199348308.png" srcset="/img/loading.gif" lazyload alt="第二十二章 九析带你轻松完爆 Istio - destination rule 实例_Istio destination r_02"></p><hr><h1 id="3-介绍"><a href="#3-介绍" class="headerlink" title="3 介绍"></a>3 介绍</h1><p>​    在上章节介绍了一个使用 Virtual Service 实现按权重（weight）分配流量的例子。整个过程如下架构图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586921280361186.png" srcset="/img/loading.gif" lazyload alt="第二十二章 九析带你轻松完爆 Istio - destination rule 实例_Istio 视频_03"></p><p>​    整个流控过程仅仅添加了一个 virtual service 就得以解决，有关 virtual service 的代码如下所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586921289867471.png" srcset="/img/loading.gif" lazyload alt="第二十二章 九析带你轻松完爆 Istio - destination rule 实例_Istio virtual servi_04"></p><p>​    但是上面这种方案在于调用方通过两层服务才能调用到最终的 Pod（比如：客户端需要通过 web-svc 和 nginx-svc 才能最终调用到 Nginx  Pod）。能不能仅仅只通过一层服务就能达到这样的效果呢？（即：只通过 web-svc）。答案是必须可以。</p><hr><h1 id="4-灰度"><a href="#4-灰度" class="headerlink" title="4 灰度"></a>4 灰度</h1><p>​    其实上面的样例非常山寨，导致根本就没有实际工作场景可以复制，仅仅只是为了展示独立 virtual service 功能。</p><p>​    但是按权重分配流量确是工作中常见的需求，比如灰度、金丝雀、蓝绿发布等。</p><p>​    灰度，意味着做事并没有那么敞亮，比如，你想跟一个心仪的女子上演一幕东京爱情故事，你的做法大概是跟她暧昧、爱抚、亲吻、最后进行爱的鼓掌。整个过程的本质就是完成一次状态转移，即从孤军奋战式撸管状态转移到团队协作式鼓掌状态。</p><p>​    灰度发布的过程跟上面的过程比较类似，都是亦步亦趋，循循善诱的过程。即：将版本 v1 的服务变更到版本 v2，但是却并不采用刚烈的极端做法。具体做法是先切 20% 流量给版本 v2，观察一阵子没啥异常事情发生，就再切  20% 流量，然后逐步切换剩下的其他流量，最终完成整个版本的替换以及所有用户流量的转移。</p><hr><h1 id="5-destination-rule-样例"><a href="#5-destination-rule-样例" class="headerlink" title="5 destination rule 样例"></a>5 destination rule 样例</h1><p>​    下面介绍使用 virtual service + destination rule 来实现灰度发布。有关 destination rule 的理论在下章节介绍。整个样例的架构图如下：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586921312295542.png" srcset="/img/loading.gif" lazyload alt="第二十二章 九析带你轻松完爆 Istio - destination rule 实例_Istio 流量管理_05"></p><p>​    样例所需要的资源文件介绍如下：</p><blockquote><p># 客户端，用来访问 httpd-v1 和 httpd-v2 的容器资源文件</p><p>jiuxi-client.yaml</p><p># deployment，声明并定义 httpd 的资源文件</p><p>jiuxi-deploy.yaml</p><p># service，关联 httpd pod 的资源文件</p><p>jiuxi-svc.yaml</p><p># Istio virtual service，声明流量路由和权重的资源文件</p><p>jiuxi-vs.yaml</p><p># Istio destination rule，定义流量路由的资源文件</p><p>jiuxi-dr.yaml</p></blockquote><h2 id="5-1-客户端资源文件"><a href="#5-1-客户端资源文件" class="headerlink" title="5.1 客户端资源文件"></a>5.1 客户端资源文件</h2><p>​    jiuxi-client.yaml:<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586921328294728.png" srcset="/img/loading.gif" lazyload alt="第二十二章 九析带你轻松完爆 Istio - destination rule 实例_Istio 教程_06"></p><h2 id="5-2-deployment-资源文件"><a href="#5-2-deployment-资源文件" class="headerlink" title="5.2 deployment 资源文件"></a>5.2 deployment 资源文件</h2><p>​    jiuxi-deploy.yaml：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586921339777599.png" srcset="/img/loading.gif" lazyload alt="第二十二章 九析带你轻松完爆 Istio - destination rule 实例_Istio 流量管理_07"></p><h2 id="5-3-service-资源文件"><a href="#5-3-service-资源文件" class="headerlink" title="5.3 service 资源文件"></a>5.3 service 资源文件</h2><p>​    jiuxi-svc.yaml：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586921348536422.png" srcset="/img/loading.gif" lazyload alt="第二十二章 九析带你轻松完爆 Istio - destination rule 实例_Istio 流量管理_08"></p><h2 id="5-4-Istio-virtual-service-资源文件"><a href="#5-4-Istio-virtual-service-资源文件" class="headerlink" title="5.4 Istio virtual service 资源文件"></a>5.4 Istio virtual service 资源文件</h2><p>​    jiuxi-vs.yaml:<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586921359681595.png" srcset="/img/loading.gif" lazyload alt="第二十二章 九析带你轻松完爆 Istio - destination rule 实例_Istio 教程_09"></p><h2 id="5-5-Istio-destination-rule-资源文件"><a href="#5-5-Istio-destination-rule-资源文件" class="headerlink" title="5.5 Istio destination rule 资源文件"></a>5.5 Istio destination rule 资源文件</h2><p>​    jiuxi-dr.yaml：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586921368116463.png" srcset="/img/loading.gif" lazyload alt="第二十二章 九析带你轻松完爆 Istio - destination rule 实例_Istio 教程_10"></p><hr><h1 id="6-Istio-注入"><a href="#6-Istio-注入" class="headerlink" title="6 Istio 注入"></a>6 Istio 注入</h1><p>​    要使得 virtual service 和 destination rule 生效，必须要保证通讯双方都处于 Istio 服务网格之内，即：必须经过 Istio 的注入，执行语句如下：</p><blockquote><p>istioctl kube-inject -f jiuxi-client.yaml | kubectl apply -f -</p><p>istioctl kube-inject -f jiuxi-deploy.yaml | kubectl apply -f -</p></blockquote><hr><h1 id="7-验证-destination-rule"><a href="#7-验证-destination-rule" class="headerlink" title="7 验证 destination rule"></a>7 验证 destination rule</h1><p>​    登入 busybox client 容器，访问 jiuxi-svc，发现 dr 已经生效，截图如下：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586921382193476.png" srcset="/img/loading.gif" lazyload alt="第二十二章 九析带你轻松完爆 Istio - destination rule 实例_Istio 教程_11"></p><p>​    自此，九析带你轻松完爆了 Istio destination rule 实例。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - Istio 路由规则</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-Istio-%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-Istio-%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 Routing Rule 语法</p><p>4 Routing Rule 优先级</p><p>5 Routing Rule 匹配规则/条件</p><p>  5.1 基于 HttpMatchRequest</p><p>  5.2 基于权重</p><p>6 流量操作（HTTPRoute）</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>​    如果你对博客有任何疑问，请告诉我。</p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586422323756366.png" srcset="/img/loading.gif" lazyload alt="第二十一章 九析带你轻松完爆 service mesh - Istio 路由规则_istio 视频"></p><hr><h1 id="3-Routing-Rule-语法"><a href="#3-Routing-Rule-语法" class="headerlink" title="3 Routing Rule 语法"></a>3 Routing Rule 语法</h1><p>​    在上节中介绍了 Virtual Service 的概念，并运行了一个简单的样例，大家应该对 Virtual Service 有了一个大致的了解。</p><p>​    Virutal Service 中最重要的概念就是路由规则（Routing Rule），注意跟 Istio traffic management 中的另外一个概念——目的地规则（Destination Rule）区分，前者是一个逻辑概念，而后者则跟 Virtual  Service 一样，是实际可以部署到 K8S 上的 Istio 资源。</p><p>​    在解释路由规则之前，这里先举一个例子：</p><p>​    又到了招聘的高峰期，HR 陆续招聘了一批校园毕业生。招聘结束后，这些毕业生要分配到具体的工作岗位。分配的规则如下：</p><blockquote><p>一、986 学校毕业的学生分配到基础平台组</p><p>二、普通学校毕业的学生分配到交易平台组</p><p>三、黑马程序员毕业的学生分配到运维平台组</p></blockquote><p>​    上面的例子提到了两个概念。一：匹配规则（或匹配条件）；二：路由目的地。这其实也就是这节介绍的主角 Routing Rule，Routing Rule 这两个单词就完美的包含了上面两个概念。</p><p>下面再接着看代码，加深一下理解：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586422367807809.png" srcset="/img/loading.gif" lazyload alt="第二十一章 九析带你轻松完爆 service mesh - Istio 路由规则_istio traffic manag_02"></p><p>​    语法简单解释如下，大意也就是匹配 XX 规则就路由到 OO，如果不匹配规则就路由到 SY（有点 if…else… 的味道）：</p><blockquote><p>match…route destination…/ route destination …</p></blockquote><p>​    当然这里有一点需要澄清，就是匹配条件并非强制，也就是说路由规则不一定非要有匹配项（match），仅有路由也是可以的。</p><p>​    翻看第二十章运行本人设计的用例，执行命令和执行结果如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586422376843726.png" srcset="/img/loading.gif" lazyload alt="第二十一章 九析带你轻松完爆 service mesh - Istio 路由规则_istio traffic manag_03"></p><hr><h1 id="4-Routing-Rule-优先级"><a href="#4-Routing-Rule-优先级" class="headerlink" title="4 Routing Rule 优先级"></a>4 Routing Rule 优先级</h1><p>​    路由规则从上到下按顺序进行评估，其中 Virtual Service  定义的第一个路由规则具有最高优先级。当然这里建议在每个虚拟服务中提供默认的“无条件”或者基于权重（weight）的规则来作为最后一个规则，以确保到虚拟服务的流量始终具有至少一条匹配的路由。</p><hr><h1 id="5-Routing-Rule-匹配规则-条件"><a href="#5-Routing-Rule-匹配规则-条件" class="headerlink" title="5 Routing Rule 匹配规则/条件"></a>5 Routing Rule 匹配规则/条件</h1><h2 id="5-1-基于-HttpMatchRequest"><a href="#5-1-基于-HttpMatchRequest" class="headerlink" title="5.1 基于 HttpMatchRequest"></a>5.1 基于 HttpMatchRequest</h2><p>​    匹配规则/条件从关键字 match 开始，针对某些匹配条件，可以选择使用精确值（exact），前缀（prefix）或正则表达式来选择它们。 有关匹配条件字段及其可能值的完整列表可在 <a href="https://istio.io/docs/reference/config/networking/virtual-service/#HTTPMatchRequest"> HTTPMatchRequest</a> 找到。</p><p>​    http 匹配条件样例资源文件如下，该样例中指明请求 uri 在忽略大小写的情况下，前缀如果是  /ratings/v2/，并且 http header 中 end-user 字段的值为 jason，就路由到命名空间为 prod 的名称为  ratings 的服务去：</p><blockquote><p>apiVersion: networking.istio.io/v1alpha3</p><p>kind: VirtualService</p><p>metadata:  </p><p>  name: ratings-route</p><p>spec:  </p><p>  hosts:  </p><p>  - ratings.prod.svc.cluster.local  </p><p>  http:  </p><p>  - match:   </p><p>​    - headers:     </p><p>​      end-user:      </p><p>​        exact: jason    </p><p>​     uri:     </p><p>​      prefix: “/ratings/v2/“    </p><p>​     ignoreUriCase: true   </p><p>​    route:   </p><p>​    - destination:     </p><p>​      host: ratings.prod.svc.cluster.local</p></blockquote><h2 id="5-2-基于权重"><a href="#5-2-基于权重" class="headerlink" title="5.2 基于权重"></a>5.2 基于权重</h2><p>​    路由规则除了基于 HTTPMatchRequest 匹配之外，还可以基于权重（weight），通过权重就可以轻松完爆 A/B 测试和金丝雀（Canary）发布了。权重设置如下所示：</p><blockquote><p>apiVersion: networking.istio.io/v1alpha3</p><p>kind: VirtualService</p><p>metadata:</p><p>  name: web-vs-svc</p><p>spec:</p><p>  hosts:</p><p>  - web-svc</p><p>  http:</p><p>  - route:</p><p>​    - destination:</p><p>​      host: httpd-svc</p><p>​      weight: 20</p><p>​    - destination:</p><p>​      host: tomcat-svc</p><p>​      weight: 80</p></blockquote><hr><h1 id="6-流量操作（HTTPRoute）"><a href="#6-流量操作（HTTPRoute）" class="headerlink" title="6 流量操作（HTTPRoute）"></a>6 流量操作（HTTPRoute）</h1><p>​    可以使用路由规则对流量做一些操作：</p><blockquote><p>附加或者删除标题</p><p>重写 URL</p><p>为路由目的地设置重试策略</p></blockquote><p>​    有关流量操作的例子如下：</p><blockquote><p>apiVersion: networking.istio.io/v1alpha3</p><p>kind: VirtualService</p><p>metadata:</p><p>  name: web-vs-svc</p><p>spec:</p><p>  hosts:</p><p>  - web-svc</p><p>  http:</p><p>  - match:</p><p>​    - uri:</p><p>​      prefix: /index.html</p><p>​     rewrite:</p><p>​      uri: /index.html</p><p>​     route:</p><p>​     - destination:</p><p>​        host: tomcat-svc</p></blockquote><p>​    有关流量操作的更多信息，可以参考 <a href="https://istio.io/docs/reference/config/networking/virtual-service/#HTTPRoute"> HTTPRoute</a>。</p><p>​    自此，九析带你轻松完爆 Istio 路由规则。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - virtual service 简述</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-virtual-service-%E7%AE%80%E8%BF%B0/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-virtual-service-%E7%AE%80%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 virtual service 简述</p><p>4 virtual service 样例</p><p>  4.1 jiuxi-busybox.yaml</p><p>  4.2 jiuxi-deployment.yaml</p><p>  4.3 jiuxi-svc.yaml</p><p>  4.4 jiuxi-vs.yaml</p><p>5 Istio 注入</p><p>6 登录客户端验证规则生效</p><p>7 总结</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586397634467970.png" srcset="/img/loading.gif" lazyload alt="第二十章 九析带你轻松完爆 Istio - virtual service 简述_istio 流量管理"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586397641993499.png" srcset="/img/loading.gif" lazyload alt="第二十章 九析带你轻松完爆 Istio - virtual service 简述_istio 教程_02"></p><hr><h1 id="3-virtual-service-简述"><a href="#3-virtual-service-简述" class="headerlink" title="3 virtual service 简述"></a>3 virtual service 简述</h1><p>​    在前面的章节中已经讲过了 virtual service 的概念和理论了。这里再做一个赘述，virtual service 是虚拟服务，它并非真正的 k8s  service，首先不能通过 kubectl get svc 的方式找到它，其次在服务调用的时候也不会直接调用它，它就像 k8s service 背后的女人一样，紧紧握着 k8s service 的老二，让它乖乖按照自己的旨意将请求流量路由到网格内的特定目标。</p><p>如下是经常困扰初学者的问题，下面一一做解答。</p><blockquote><p><strong>问题一：Virtual service 跟 k8s service 的关系是什么。属于强绑定吗？</strong></p><p>回答：不是强绑定。virtual service 可以帮助 k8s service 在路由控制上做到更细粒度，不必只是 Round-Robin 策略。</p><p><strong>问题二：Virtual service 必须要跟 Istio traffic management 的其他资源，比如 destination rule、gateway、service entries 捆绑使用吗？</strong></p><p>回答：否。Virtual service 自身就可以产生作用。当然它也可以跟网关，或者跟 destination rule 一起构造更加灵活、丰富的路由规则。</p><p><strong>问题三：路由规则（Routing rules）跟 Destination rule 是同样的东西吗？</strong></p><p>回答：否。路由规则是逻辑上的概念，而 Destination rule 是 Istio 的一种资源。你可以将 Destination rule 看做 Routing rules 的子集。</p><p><strong>问题四：Virtaul service 的 hosts 字段填写什么内容？</strong></p><p>回答：hosts 字段值是客户端向服务发送请求时使用的地址。这个地址可以是 IP 地址、DNS 名称、也可以是 k8s service  名称（短名词地址或者完整地址，比如  web-svc.default.cluster.local）,如果是短名称，要求可以隐式或者显式地解析为完全限定域名（FQDN）。当然也可以使用通配符（*）前缀，从而为所有匹配的服务创建一套路由规则。虚拟服务主机实际上不一定是 Istio 服务注册表的一部分，它们只是可以可寻址的虚拟目的地而已。这样，也就可以为网格内没有可路由条目的虚拟主机流量进行建模。</p></blockquote><hr><h1 id="4-virtual-service-样例"><a href="#4-virtual-service-样例" class="headerlink" title="4 virtual service 样例"></a>4 virtual service 样例</h1><p>​    下面介绍一个 virtual service 独立作用的例子，本例需要的资源如下：</p><blockquote><p># 调用服务的客户端</p><p>jiuxi-busybox.yaml</p></blockquote><blockquote><p># 两个 web 服务器: tomcat 和 httpd。模拟两个微服务，需要被 Istio 注入，注入后就变成服务网格中的服务</p><p>jiuxi-deployment.yaml</p><p># 定义 3 个服务：httpd-svc 指向 httpd，tomcat-svc 指向 tomcat。web-svc 同时指向 httpd 和 tomcat</p><p>jiuxi-svc.yaml</p><p># Istio virtual service：定义虚拟服务，该虚拟服务作用在 web-svc 服务上，并设置简单的路由规则（Routing rule，而非 Destination rule）</p><p>jiuxi-vs.yaml</p></blockquote><p>​    下面一一介绍各个资源文件明细。</p><h2 id="4-1-jiuxi-busybox-yaml"><a href="#4-1-jiuxi-busybox-yaml" class="headerlink" title="4.1 jiuxi-busybox.yaml"></a>4.1 jiuxi-busybox.yaml</h2><p>​    代码如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586397653621566.png" srcset="/img/loading.gif" lazyload alt="第二十章 九析带你轻松完爆 Istio - virtual service 简述_istio traffic manag_03"></p><h2 id="4-2-jiuxi-deployment-yaml"><a href="#4-2-jiuxi-deployment-yaml" class="headerlink" title="4.2 jiuxi-deployment.yaml"></a>4.2 jiuxi-deployment.yaml</h2><p>​    代码如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586397659465460.png" srcset="/img/loading.gif" lazyload alt="第二十章 九析带你轻松完爆 Istio - virtual service 简述_istio 流量管理_04"></p><h2 id="4-3-jiuxi-svc-yaml"><a href="#4-3-jiuxi-svc-yaml" class="headerlink" title="4.3 jiuxi-svc.yaml"></a>4.3 jiuxi-svc.yaml</h2><p>​    代码如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586397666911168.png" srcset="/img/loading.gif" lazyload alt="第二十章 九析带你轻松完爆 Istio - virtual service 简述_istio 视频_05"></p><h2 id="4-4-jiuxi-vs-yaml"><a href="#4-4-jiuxi-vs-yaml" class="headerlink" title="4.4 jiuxi-vs.yaml"></a>4.4 jiuxi-vs.yaml</h2><p>​    代码如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586397672550709.png" srcset="/img/loading.gif" lazyload alt="第二十章 九析带你轻松完爆 Istio - virtual service 简述_istio 流量管理_06"></p><hr><h1 id="5-Istio-注入"><a href="#5-Istio-注入" class="headerlink" title="5 Istio 注入"></a>5 Istio 注入</h1><p>​    针对客户端和 deployment 执行手工注入：</p><blockquote><p>istioctl kube-inject -f jiuxi-deploy.yaml jiuxi-busybox.yaml | kubectl apply -f -</p><p>istioctl kube-inject -f jiuxi-busybox.yaml | kubectl apply -f -</p></blockquote><hr><h1 id="6-登录客户端验证规则生效"><a href="#6-登录客户端验证规则生效" class="headerlink" title="6 登录客户端验证规则生效"></a>6 登录客户端验证规则生效</h1><p>​    登录到 busybox，然后通过如下命令均可以看到规则生效：</p><blockquote><p>wget -q -O - <a href="http://web-svc:8080/"> http://web-svc:8080</a>    # web-svc 是 k8s service。字母 O，非数字 0</p><p>wget -q -O - <a href="http://ip:8080/">http://IP:8080</a>        # IP 是 web-svc 的 ClusterIP。</p></blockquote><hr><h1 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h1><p>​    自此九析带你轻松完爆了 Istio traffic management 的 virtaul service。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - Istio virtual service</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-Istio-virtual-service/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-Istio-virtual-service/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 虚拟服务（Virtual Service）</p><p>4 虚拟服务跟 K8s 服务的关系</p><p>5 虚拟服务实例</p><p>  5.1 k8s 资源</p><p>  5.2 Istio 资源</p><p>  5.3 Istio 注入</p><p>  5.4 创建客户端和客户端 Istio 注入</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586269741539025.png" srcset="/img/loading.gif" lazyload alt="第十九章 九析带你轻松完爆 service mesh - Istio virtual service_istio virtual servi"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586269750697704.png" srcset="/img/loading.gif" lazyload alt="第十九章 九析带你轻松完爆 service mesh - Istio virtual service_istio virtual servi_02"></p><hr><h1 id="3-虚拟服务（Virtual-Service）"><a href="#3-虚拟服务（Virtual-Service）" class="headerlink" title="3 虚拟服务（Virtual Service）"></a>3 虚拟服务（Virtual Service）</h1><p>​    虚拟服务（Virtual Service）以及目标规则（Destination Rule）是 Istio 流量路由的两大基石。虚拟服务可以将流量路由到 Istio 服务网格中的服务。每个虚拟服务由一组路由规则组成，这些路由规则按顺序进行评估。</p><p>​    如果没有 Istio virtual service，仅仅使用 k8s service 的话，那么只能实现最基本的流量负载均衡转发，但是就不能实现类似按百分比来分配流量等更加复杂、丰富、细粒度的流量控制了。</p><hr><h1 id="4-虚拟服务跟-K8s-服务的关系"><a href="#4-虚拟服务跟-K8s-服务的关系" class="headerlink" title="4 虚拟服务跟 K8s 服务的关系"></a>4 虚拟服务跟 K8s 服务的关系</h1><p>​    虚拟服务相当于 K8s 服务的 sidecar，在原本 K8s 服务的功能之上，提供了更加丰富的路由控制。</p><hr><h1 id="5-虚拟服务实例"><a href="#5-虚拟服务实例" class="headerlink" title="5 虚拟服务实例"></a>5 虚拟服务实例</h1><p>​    以下介绍使用 “虚拟服务（virtual service）+目标规则（destination rule）” 实现一个流量分流的例子。本示例共需要四种资源，k8s 和 istio 各两种：</p><p>​    k8s 资源介绍如下：</p><blockquote><p>1 两个 deployment，一个 tomcat，一个 nginx</p><p>2 一个 service 关联上面这两个 deployment</p></blockquote><p>​    Istio 资源介绍如下：</p><blockquote><p>1 一个 destination rule，设置目标规则定义</p><p>2 一个 virtual service 关联上面的 service，用来设置分流权重（weight）和设置分流目标规则定义）</p></blockquote><h2 id="5-1-k8s-资源"><a href="#5-1-k8s-资源" class="headerlink" title="5.1 k8s 资源"></a>5.1 k8s 资源</h2><p>​    k8s 资源共有两类，分别为 deployment 和 service，其中 deployment 资源文件明细如下：</p><blockquote><p># jiuxi-deploy.yaml</p><p>apiVersion: apps/v1</p><p>kind: Deployment</p><p>metadata:</p><p>  name: nginx-deploy</p><p>spec:</p><p>  replicas: 1</p><p>  selector:</p><p>​    matchLabels:</p><p>​      type: web</p><p>​      app: nginx</p><p>  template:</p><p>​    metadata:</p><p>​    labels:</p><p>​      type: web</p><p>​      app: nginx</p><p>​    spec:</p><p>​      containers:</p><p>​      - image: nginx:1.14-alpine</p><p>​        imagePullPolicy: IfNotPresent</p><p>​        name: nginx</p><p>​        ports:</p><p>​        - containerPort: 80</p><p>​          name: port</p><p>​          protocol: TCP</p><p>-–</p><p>apiVersion: apps/v1</p><p>kind: Deployment</p><p>metadata:</p><p>  name: tomcat-deploy</p><p>spec:</p><p>  replicas: 1</p><p>  selector:</p><p>​    matchLabels:</p><p>​      type: web</p><p>​      app: tomcat</p><p>  template:</p><p>​    metadata:</p><p>​      labels:</p><p>​        type: web</p><p>​        app: tomcat</p><p>​    spec:</p><p>​      containers:</p><p>​      - image: docker.io/kubeguide/tomcat-app:v1</p><p>​        imagePullPolicy: IfNotPresent</p><p>​        name: tomcat</p><p>​        ports:</p><p>​        - containerPort: 8080</p><p>​          name: port</p><p>​          protocol: TCP</p></blockquote><p>​    部署上面的 jiuxi-deploy.yaml 文件，语句如下：</p><blockquote><p>kubectl apply -f jiuxi-deploy.yaml</p></blockquote><p>​    service 资源文件明细如下：</p><blockquote><p># jiuxi-svc.yaml</p><p>apiVersion: v1</p><p>kind: Service</p><p>metadata:</p><p>  name: web-svc</p><p>spec:</p><p>  ports:</p><p>  - name: port</p><p>​    port: 8080</p><p>​    protocol: TCP</p><p>​    targetPort: 8080</p><p>  selector:</p><p>​    type: web</p></blockquote><p>​    部署上面的 service 文件，语句如下：</p><blockquote><p>kubectl apply -f jiuxi-svc.yaml</p></blockquote><p>​    自此，k8s 层面的资源文件准备完毕，现在通过访问 service，可以发现自动实现了RoundBin的负载均衡策略，即分配到 tomcat 和 nginx 的流量各为 50%。</p><h2 id="5-2-Istio-资源"><a href="#5-2-Istio-资源" class="headerlink" title="5.2 Istio 资源"></a>5.2 Istio 资源</h2><p>​    Istio 资源共有两类，分别为虚拟服务（Virtual Service）和目的地规则（Destination Rule）。虚拟服务作用在 k8s 服务之上，并加强了原 k8s 服务的功能：</p><ul><li><ul><li>指定目的地（tomcat 或 nginx）</li><li>重新分配流量（即不再是 50% / 50%，而是 75% / 25%）</li></ul></li></ul><p>​    目的地规则文件 jiux-dr.yaml 如下：</p><blockquote><p># jiuxi-dr.yaml</p><p>apiVersion: networking.istio.io/v1alpha3</p><p>kind: DestinationRule</p><p>metadata:</p><p>  name: jiuxi-dr</p><p>spec:</p><p>  host: jiuxi-svc</p><p>  subsets:</p><p>  - name: tomcat</p><p>​    labels:</p><p>​      app: tomcat</p><p>  - name: nginx</p><p>​    labels:</p><p>​      app: nginx</p></blockquote><p>​    上面的目的地资源文件作用在 jiux-svc 这个 k8s 服务上，通过 labels 字段指定不同的 pod，然后通过 name 字段提供给下面的 virtual service，起到关联到具体 pod 的作用。</p><p>​    如果这里你不好理解，可以这么来理解。以前 k8s service 跟 pod 关联是一维坐标关联，从上面例子可知，nginx 跟 tomcat 对 svc  而言是没什么区别的，因为都是相同的 labels 指定。但是如果采用了 virtual service 和 destination 相当于对  service 后面的 pod 使用了二维坐标关联，这样就可以明确定义 service 后面的 pod 到底有哪些业务含义了（比如一个是  nginx，另外一个是 tomcat）。这里大家仔细琢磨一下。</p><p>​    虚拟服务文件 jiuxi-vs.yaml 如下：</p><blockquote><p># jiuxi-vs.yaml</p><p>apiVersion: networking.istio.io/v1alpha3</p><p>kind: VirtualService</p><p>metadata:</p><p>  name: jiuxi-virtual-svc</p><p>spec:</p><p>  hosts:</p><p>  - jiuxi-svc</p><p>  http:</p><p>  - route:</p><p>​    - destination:</p><p>​        host: jiuxi-svc</p><p>​        subset: nginx</p><p>​      weight: 25</p><p>​    - destination:</p><p>​        host: jiuxi-svc</p><p>​        subset: tomcat</p><p>​      weight: 75</p></blockquote><p>​    执行上面这两个资源文件：</p><blockquote><p>kubectl apply -f jiuxi-dr.yaml</p><p>kubectl apply -f jiuxi-vs.yaml</p></blockquote><p>​    命令执行后的结果如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586269805760280.png" srcset="/img/loading.gif" lazyload alt="第十九章 九析带你轻松完爆 service mesh - Istio virtual service_istio virtual servi_03"></p><h2 id="5-3-Istio-注入"><a href="#5-3-Istio-注入" class="headerlink" title="5.3 Istio 注入"></a>5.3 Istio 注入</h2><p>​    执行如下命令进行 Istio 注入：</p><blockquote><p>istioctl kube-inject -f jiuxi-deploy.yaml | kubectl apply -f -</p></blockquote><p>​    因为 nginx 默认启动是 80 端口，为了保持跟 tomcat 端口保持一致，这里需要登录到 pod 中修改 nginx 端口，操作方法如下：</p><blockquote><p># pod 后缀根据实际情况进行修改</p><p>kubectl exec -it nginx-deploy-957f689f5-7svdz – sh</p></blockquote><p>​    然后编辑 nginx 配置文件：</p><blockquote><p>vi /etc/nginx/conf.d/default.conf</p></blockquote><p>​    修改内容如下截图：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586269815956928.png" srcset="/img/loading.gif" lazyload alt="第十九章 九析带你轻松完爆 service mesh - Istio virtual service_istio 视频_04"></p><h2 id="5-4-创建客户端和客户端-Istio-注入"><a href="#5-4-创建客户端和客户端-Istio-注入" class="headerlink" title="5.4 创建客户端和客户端 Istio 注入"></a>5.4 创建客户端和客户端 Istio 注入</h2><p>​    创建客户端访问经过 Istio 流控过的 k8s 服务，客户端资源文件如下：</p><blockquote><p># jiuxi-busybox.yaml</p><p>apiVersion: v1</p><p>kind: Pod</p><p>metadata:</p><p>  name: busybox</p><p>spec:</p><p>  containers:</p><p>  - name: nginx</p><p>​    image: busybox</p><p>​    imagePullPolicy: IfNotPresent</p><p>​    command: [“/bin/sh”, “-c”, “sleep 3600” ]</p></blockquote><p>​    执行如下 Istio 注入命令：</p><blockquote><p>istioctl kube-inject -f jiuxi-busybox.yaml | kubectl apply -f -</p></blockquote><p>​    Istio 注入成功后，通过 kubectl exec 登录到 busybox 容器中，然后执行如下语句，验证 virtual service 和 destination rule 功能：</p><blockquote><p>curl <a href="http://jiuxi-svc:8080/"> http://jiuxi-svc:8080</a></p></blockquote><p>​    注意这里的客户端也必须经过 Istio 注入，因为只有客户端被 Istio 注入，客户端才可以接收到来自 Pilot server 端有关 virtual service 和 destination rule 的配置信息，才可以保证 Istio 的 traffic management 真正生效。</p><p>​    自此，九析带你轻松完爆 Istio virtual service + Destination Rule 功能。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - Istio traffic managem</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-Istio-traffic-managem/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-Istio-traffic-managem/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 流量管理概述</p><p>4 istio 流量管理 API 资源</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585811911387303.png" srcset="/img/loading.gif" lazyload alt="第十八章 九析带你轻松完爆 service mesh - Istio traffic managem_istio 流量管理"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585811940367841.png" srcset="/img/loading.gif" lazyload alt="第十八章 九析带你轻松完爆 service mesh - Istio traffic managem_istio traffic manag_02"></p><hr><h1 id="3-流量管理概述"><a href="#3-流量管理概述" class="headerlink" title="3 流量管理概述"></a>3 流量管理概述</h1><p>​    流量管理的本质就是采用策略控制流量的流向和大小。</p><p>​    Istio 流量管理模型依赖于随服务一起部署的 Envoy 代理，网格发送和接收的所有流量（数据平面流量）都通过 Envoy 进行代理。基于此模型可以轻松引导和控制网格周围的流量，而无需对服务进行任何更改。</p><hr><h1 id="4-istio-流量管理-API-资源"><a href="#4-istio-流量管理-API-资源" class="headerlink" title="4 istio 流量管理 API 资源"></a>4 istio 流量管理 API 资源</h1><p>​    为了在网格之间引导流量，Istio 需要知道执行端点在哪里（在 K8s 中就是 Pod），以及这些执行端点属于什么服务。而且 Istio 为了填充自己的服务注册表，会连接到  Istio 所安装平台上的服务发现系统。例如，如果 Istio 被安装到了 K8s 上，那么 Istio 就会自动发现集群中的服务和执行端点。</p><p>​    Istio 自身的服务注册表维护了一组服务以及这些服务背后真正的执行端点，Istio 使用服务注册表产生 Envoy 配置。Istio  本身并不提供服务发现功能，尽管大多数服务是由 Pilot 适配器自动添加到注册表中的，而这些 Pilot  适配器使用的是基础平台（K8s、Consul、纯 DNS）自身的发现服务。</p><p>​    使用此服务注册表，Envoy 代理就可以将流量定向到相关服务。大多数基于微服务的应用系统每个服务后面都会有多个实例处理服务流量。默认情况下，Envoy 代理使用 RoundBin 循环模型在每个服务实例之间平均分配流量。</p><p>​    虽然 Istio 的基本服务发现和负载均衡已经提供了一个有效的服务网格，但 Istio  提供的功能远不止这么多。在许多情况下，都希望对网格流量进行更加细粒度的控制。比如，可能希望将流量以百分比分配到不同的服务版本，作为 A/B  测试的一部分，或者将不同的负载均衡策略应用于特定服务实例版本，又或者你可能还想将特殊规则应用于进出网格的流量等等。以上这些都可以通过使用  Istio 流量管理 API 做到。</p><p>​    Istio 流量管理 API 资源如下：</p><blockquote><p>Virtual Service</p><p>Destination Rule</p><p>Gateway</p><p>Service entries</p><p>Sidecars</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - Istio 架构</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-Istio-%E6%9E%B6%E6%9E%84/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-Istio-%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 架构概述</p><p>4 流量概述</p><p>5 组件介绍</p><p>  5.1 Envoy</p><p>  5.2 Pilot</p><p>  5.3 Citadel</p><p>  5.4 Galley</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585732218872412.png" srcset="/img/loading.gif" lazyload alt="第十七章 九析带你轻松完爆 service mesh - Istio 架构_istio pilot"></p><hr><h2 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h2><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585732227589604.png" srcset="/img/loading.gif" lazyload alt="第十七章 九析带你轻松完爆 service mesh - Istio 架构_istio galley_02"></p><hr><h2 id="3-架构概述"><a href="#3-架构概述" class="headerlink" title="3 架构概述"></a>3 架构概述</h2><p>​    istio 服务网格逻辑上分为数据和控制两大平面。</p><blockquote><p>数据平面：由一组智能代理（envoy）组成，这些代理不仅控制和协调微服务之间的所有网络通信，同时也负责收集和汇报网格的遥测。</p><p>控制平面：制定、应用策略控制网络流量的路由。</p></blockquote><p>​    下图展示 istio 架构：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585732235663897.png" srcset="/img/loading.gif" lazyload alt="第十七章 九析带你轻松完爆 service mesh - Istio 架构_istio pilot_03"></p><hr><h2 id="4-流量概述"><a href="#4-流量概述" class="headerlink" title="4 流量概述"></a>4 流量概述</h2><p>​    由上可知，Istio 架构由数据面和控制面构成，那么 Istio 的流量也可以分为数据面流量和控制面流量。数据面流量是指微服务之间业务调用的流量，控制面流量是指 Istio 各组件之间配置和控制网格行为的流量。</p><p>Istio 中 traffic management 专指数据平面流量。</p><hr><h2 id="5-组件介绍"><a href="#5-组件介绍" class="headerlink" title="5 组件介绍"></a>5 组件介绍</h2><p>​    Istio 1.5.0 取消了原有的 Mixer 组件，保留了 Envoy、Pilot、Citadel、Galley 这 4 个核心的组件，这 4 个组件除了 Envoy 属于 Istio 数据面，其他都属于控制面。下面分别介绍如下：</p><h2 id="5-1-Envoy"><a href="#5-1-Envoy" class="headerlink" title="5.1 Envoy"></a>5.1 Envoy</h2><p>​    Envoy 是使用 C++ 开发的高性能代理，Istio 使用的是经过扩展过的 Envoy，Istio 中的 Envoy 作用是调解所有服务网格单元的入口和出口流量。同时 Envoy 也是与数据平面流量交互的唯一 Istio 组件。</p><p>因为 Envoy 被部署作为微服务的 sidecar，从而与微服务构成了一个有机的整体，所以从功能上自然就具备了 Envoy 的功能：</p><ul><li>动态服务发现</li><li>负载均衡</li><li>TLS 终止</li><li>HTTP/2 和 gRPC 代理</li><li>断路器</li><li>健康检查</li><li>分阶段滚动更新和基于百分比分配流量</li><li>失败注入</li><li>丰富的指标</li></ul><p>​    这种 sidecar 代理方式使 Istio 可以收集网络流量中特定信息作为指标（比如 HTTP 协议头的某些字段、目标 IP 等等），Istio 可以利用这些指标来实施策略，并将其发送给监控系统以报告整个网格行为。</p><p>Sidecar 代理模式允许使用者将 Istio 功能添加到现有微服务中，而无需重新构造或重写代码。</p><p>​    Envoy proxy 启用了一些 Istio 功能和任务，其中包括：</p><ul><li>流量控制功能：使用丰富的路由规则对 HTTP、gRPC、WebSocket 和 TCP 流量实施细粒度的流控</li><li>弹性网络功能：设置重试、故障转移、断路器和故障注入</li><li>安全和身份验证：通过资源部署的方式来应用安全策略、访问控制以及速率限制等功能特性</li><li>基于 WebAssembly 可插拔扩展模型，允许制定自定义策略和网格遥测流量规则</li></ul><h3 id="5-2-Pilot"><a href="#5-2-Pilot" class="headerlink" title="5.2 Pilot"></a>5.2 Pilot</h3><p>​    Pilot 提供 Envoy 边车服务发现、智能路由（比如 A/B 测试、金丝雀发布等）的流量管理能力、网络弹性（超时、重试、断路器等等）。</p><p>​    Pilot 将控制流量行为的高级路由规则转换为 Envoy 特定的配置，并在运行时将其传播给 sidecar。Pilot 抽取特定于平台的服务发现机制，并将其合成为任何符合 Envoy API 的 sidecar 都可以使用的标准格式。</p><p>​    下图展示了平台适配器如何跟 Envoy 代理如何交互：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585732247617501.png" srcset="/img/loading.gif" lazyload alt="第十七章 九析带你轻松完爆 service mesh - Istio 架构_istio envoy_04"></p><blockquote><p>1 平台启动一个服务的新实例，该实例通知其平台适配器</p><p>2 平台适配器将实例注册到 Pilot 抽象模型</p><p>3 Pilot 将流量规则和配置分发给 Envoy 代理通知其更改</p></blockquote><p>​    Pilot 这种设计使得 Istio 可以在 K8s、Consul 和 Nomad 等多种环境中运行，同时保持用于流量管理的相同操作界面。</p><p>​    可以使用 Istio 流控 API 通知 Pilot 转换为 Envoy 配置以达到更新粒度操控服务网格中的流量。</p><h3 id="5-3-Citadel"><a href="#5-3-Citadel" class="headerlink" title="5.3 Citadel"></a>5.3 Citadel</h3><p>​    Citadel 通过内置的身份认证和凭证管理实现了强大的服务到服务、用户到端的身份认证。可以使用 Citadel 升级网格中未加密的流量。运维人员可以通过  Citadel 基于服务身份而不是相对不稳定的第 3 层或第 4 层网络标识符来实施策略。</p><h3 id="5-4-Galley"><a href="#5-4-Galley" class="headerlink" title="5.4 Galley"></a>5.4 Galley</h3><p>​    Galley 是 Istio 验证、提取、处理和分发配置的组件。它负责将其余 Istio 组件与底层平台（例：K8S）获取用户配置的细节隔离开。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - istio kiali jaeger 关联</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-kiali-jaeger-%E5%85%B3%E8%81%94/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-kiali-jaeger-%E5%85%B3%E8%81%94/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 jaeger 介绍</p><p>4 jaeger 安装</p><p>5 jaeger 配置</p><p>6 kiali 关联 jaeger</p><p>7 设置 kiali jaeger 外部链接地址</p><p>8 kiali jaeger 流量关联</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585214264302331.png" srcset="/img/loading.gif" lazyload alt="第十六章 九析带你轻松完爆 service mesh - istio kiali jaeger 关联_istio kiali"></p><hr><h2 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h2><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585214272975021.png" srcset="/img/loading.gif" lazyload alt="第十六章 九析带你轻松完爆 service mesh - istio kiali jaeger 关联_jaeger_02"></p><hr><h2 id="3-jaeger-介绍"><a href="#3-jaeger-介绍" class="headerlink" title="3 jaeger 介绍"></a>3 jaeger 介绍</h2><p>​    jaeger 官网请<a href="https://www.jaegertracing.io/"> 点击</a>。</p><p>​    jaeger 是 Uber 开源的分布式跟踪系统，用于微服务的监控和全链路跟踪，其设计思想来自于 Dapper 和 zipkin。jaeger 特征包括：</p><blockquote><p>分布式上下文传播</p><p>分布式事务监控</p><p>Root 原因分析</p><p>服务依赖性分析</p><p>性能/延迟优化</p></blockquote><p>​    本博客主要介绍将 istio、kiali、jaeger 关联在一起形成一个统一的整体。istio 版本采用的是 1.5.0。有关 istio 和 kiali 组件如何安装和使用，请参考本人的连载博客《<a href="https://blog.51cto.com/14625168/2474277"> 轻松完爆 istio 系列</a>》。如果你觉得不过瘾，也可以看我的免费视频，相信你会听得很开心。</p><hr><h2 id="4-jaeger-安装"><a href="#4-jaeger-安装" class="headerlink" title="4 jaeger 安装"></a>4 jaeger 安装</h2><p>​    如果你使用 istioctl profile demo 安装 istio 的话，jaeger 默认就是安装好的。你可以参考《<a href="https://blog.51cto.com/14625168/2474224"> 轻松完爆 istio 安装</a>》轻松完爆 jaeger 的安装。</p><p>​    安装后的截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585214282847517.png" srcset="/img/loading.gif" lazyload alt="第十六章 九析带你轻松完爆 service mesh - istio kiali jaeger 关联_istio 教程_03"></p><hr><h2 id="5-jaeger-配置"><a href="#5-jaeger-配置" class="headerlink" title="5 jaeger 配置"></a>5 jaeger 配置</h2><p>​    为了可以将 jaeger 暴露在 k8s 集群外访问，需要将 jaeger-query 的 ClusterIP 服务类型更改为 NodePort。执行语句如下，执行结果如上截图所示：</p><blockquote><p>kubectl patch svc -n istio-system jaeger-query -p ‘{“spec”:{“type”: “NodePort”}}’</p></blockquote><hr><p>6 kiali 关联 jaeger</p><p>​    kiali 是可视化服务网格组件，截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585214292159255.png" srcset="/img/loading.gif" lazyload alt="第十六章 九析带你轻松完爆 service mesh - istio kiali jaeger 关联_istio 视频_04"></p><p>​    点击上面箭头 Distributed Tracing 链接可以打开 jaeger。如果访问不到，说明你本地的浏览器并不能直接访问到 kiali 设置的 jaeger 外部链接。</p><hr><h2 id="7-设置-kiali-jaeger-外部链接地址"><a href="#7-设置-kiali-jaeger-外部链接地址" class="headerlink" title="7 设置 kiali jaeger 外部链接地址"></a>7 设置 kiali jaeger 外部链接地址</h2><p>​    编辑 kiali configmap：</p><blockquote><p>kubectl edit configmap -n istio-system kiali</p></blockquote><p>​    在 external_services.tracing.url 内容下添加 jaeger 外部链接，链接地址就是 istio-system 命名空间下 jaeger-query 服务的宿主机地址和 nodeport。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585214303810615.png" srcset="/img/loading.gif" lazyload alt="第十六章 九析带你轻松完爆 service mesh - istio kiali jaeger 关联_jaeger_05"></p><p>​    添加内容如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585214310647910.png" srcset="/img/loading.gif" lazyload alt="第十六章 九析带你轻松完爆 service mesh - istio kiali jaeger 关联_istio 教程_06"></p><p>​    编辑 kiali configmap 后，需要删除并重新生成 kiali pod，好让配置挂载生效，执行语句如下：</p><blockquote><p>kubectl delete pod -n istio-system $(kubectl get pod -n istio-system | grep -i kiali | awk ‘{print $1}’)</p></blockquote><p>​    执行完后，再次查看 kiali pod，发现 url 值已经生效：</p><blockquote><p># 注意 kiali pod 根据自己情况填写，不要直接照抄哥的</p><p>kubectl exec -it -n istio-system kiali-76f556db6d-88vtd – cat /kiali-configuration/config.yaml</p></blockquote><p>​    命令直接结果如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585214318470229.png" srcset="/img/loading.gif" lazyload alt="第十六章 九析带你轻松完爆 service mesh - istio kiali jaeger 关联_istio 视频_07"></p><p>​    再次访问 kiali，发现 Distributed Tracing 链接可以访问，并且可以打开 jaeger 页面，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585214326580895.png" srcset="/img/loading.gif" lazyload alt="第十六章 九析带你轻松完爆 service mesh - istio kiali jaeger 关联_istio kiali_08"></p><hr><h2 id="8-kiali-jaeger-流量关联"><a href="#8-kiali-jaeger-流量关联" class="headerlink" title="8 kiali jaeger 流量关联"></a>8 kiali jaeger 流量关联</h2><p>​    以上的操作中通过 kiali 可以打开 jaeger 了，还可以通过实际流量将 kiali 和 jaeger 关联起来，首先打入一些流量，这里采用的是 istio 的官方用例 bookinfo：【必须注意：一定要放入网格才可以看到流量】</p><blockquote><p>while true; do curl 10.98.126.37/productpage; done</p></blockquote><p>​    访问 kiali 的 service 菜单标签：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585214335780595.png" srcset="/img/loading.gif" lazyload alt="第十六章 九析带你轻松完爆 service mesh - istio kiali jaeger 关联_istio 教程_09"></p><p>​    双击 productpage 进入微服务，然后选择标签页 Traces，再点击蓝色圆圈（trace 点）后会显示该 tracing 的路径信息，然后再选择链接（View Trace in Tracing）：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585214344969895.png" srcset="/img/loading.gif" lazyload alt="第十六章 九析带你轻松完爆 service mesh - istio kiali jaeger 关联_jaeger_10"></p><p>​    点击后的 jaeger 截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585214352837969.png" srcset="/img/loading.gif" lazyload alt="第十六章 九析带你轻松完爆 service mesh - istio kiali jaeger 关联_jaeger_11"></p><p>​    自此，九析带你轻松完爆 istio、kiali、jaeger 的关联。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - istio kiali 亲和性调度</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-kiali-%E4%BA%B2%E5%92%8C%E6%80%A7%E8%B0%83%E5%BA%A6/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-kiali-%E4%BA%B2%E5%92%8C%E6%80%A7%E8%B0%83%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 节点调度</p><p>  3.1 节点打标</p><p>  3.2 编写 pod</p><p>4 kiali 亲和性调度</p><p>  4.1 举个例子</p><p>  4.2 节点亲和性调度（NodeAffinity）</p><p>  4.3 kiali 节点亲和性调度</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585126831588294.png" srcset="/img/loading.gif" lazyload alt="第十五章 九析带你轻松完爆 service mesh - istio kiali 亲和性调度_istio nodeaffinity"></p><hr><h2 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h2><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585126838978145.png" srcset="/img/loading.gif" lazyload alt="第十五章 九析带你轻松完爆 service mesh - istio kiali 亲和性调度_istio 教程_02"></p><hr><h2 id="3-节点调度"><a href="#3-节点调度" class="headerlink" title="3 节点调度"></a>3 节点调度</h2><p>​    在开始 kiali 亲和性调度之前，先演示一个简单的例子介绍 pod 选择调度到指定 node：</p><h3 id="3-1-节点打标"><a href="#3-1-节点打标" class="headerlink" title="3.1 节点打标"></a>3.1 节点打标</h3><p>​    使用命令查看当前所有 k8s 节点：</p><blockquote><p>kubectl get nodes</p></blockquote><p>​    命令截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585126886611373.png" srcset="/img/loading.gif" lazyload alt="第十五章 九析带你轻松完爆 service mesh - istio kiali 亲和性调度_istio 视频_03"></p><p>​    现在给 k8s-w-206 这个节点打上一个标签，标签内容为 name: jiuxi，命令如下：</p><blockquote><p>kubectl label node k8s-w-206 name=jiuxi</p></blockquote><h3 id="3-2-编写-pod"><a href="#3-2-编写-pod" class="headerlink" title="3.2 编写 pod"></a>3.2 编写 pod</h3><p>​    编写 pod 资源文件 jiuxi-pod.yaml，文件中使用 nodeSelector 指定该 pod 要调度到 k8s-w-206 节点之上：</p><blockquote><p>apiVersion: v1</p><p>kind: Pod</p><p>metadata:</p><p>  labels:</p><p>​    app: busybox</p><p>​    name: busybox</p><p>spec:</p><p>  containers:</p><p>  - name: busybox</p><p>​    image: busybox</p><p>​    imagePullPolicy: IfNotPresent</p><p>​    command: [ “/bin/sh”, “-c”, “sleep 3600” ]</p><p>​      <strong>nodeSelector:</strong></p><p>​       <strong>name: jiuxi</strong></p></blockquote><p>​    部署 jiuxi-pod.yaml，发现 pod 果然被调度到了 k8s-w-206 这个 node，截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585126896217808.png" srcset="/img/loading.gif" lazyload alt="第十五章 九析带你轻松完爆 service mesh - istio kiali 亲和性调度_istio jaeger_04"></p><hr><h2 id="4-kiali-亲和性调度"><a href="#4-kiali-亲和性调度" class="headerlink" title="4 kiali 亲和性调度"></a>4 kiali 亲和性调度</h2><p>​    上面举例 pod 使用 nodeSelector 选择 node，这就是最简单的 k8s 调度方式。而 kiali 调度方式复杂一些，使用的是节点亲和性调度策略，使用如下命令查看：</p><blockquote><p>kubectl get deployments.apps kiali -n istio-system -o yaml</p></blockquote><p>​    命令执行结果部分显示如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585126904929592.png" srcset="/img/loading.gif" lazyload alt="第十五章 九析带你轻松完爆 service mesh - istio kiali 亲和性调度_istio 视频_05"></p><h3 id="4-1-举个例子"><a href="#4-1-举个例子" class="headerlink" title="4.1 举个例子"></a>4.1 举个例子</h3><p>​    举一个生活的例子，以前去医院看病，病人（pod）不能挑医生（node），排队叫到谁就是谁，冷冰冰完全没有亲和性而言；如今可以网上挂号了，病人也可以挑选中意的医生，这样就有了亲和性，说明社会进步了。</p><p>​    当然病人在挑选医生的过程中也会有两种情况：一种是硬性（required），比如非要某医生，即使他忙，也愿意一直等下去；还有一种是软性（prefered），比如优先选择某医生，但是如果真不行，其他医生也未尝不可。</p><h3 id="4-2-节点亲和性调度（NodeAffinity）"><a href="#4-2-节点亲和性调度（NodeAffinity）" class="headerlink" title="4.2 节点亲和性调度（NodeAffinity）"></a>4.2 节点亲和性调度（NodeAffinity）</h3><p>​    下面的理论可以对照上面的例子。</p><p>​    节点亲和性，也就是 NodeAffinity，用来控制 pod 部署或者不能部署在哪台机器上。</p><p>​    节点亲和性调度策略分为硬策略分为软策略和硬策略两种方式。硬策略是如果没有满足条件的节点，就会不断重试直到条件满足了为止；软策略是如果没有满足条件的节点，pod 就会忽略这条规则，继续完成调度过程。</p><p>​    节点亲和性软硬策略的语法分别介绍如下。</p><ul><li><ul><li>硬策略（关键字 require）：</li></ul></li></ul><blockquote><p>requiredDuringSchedulingIgnoredDuringExecution：</p><p>pod 必须部署到满足条件的节点上，如果节点不满足条件，就不停重试。IgnoreDuringExecution 表示 pod 部署成功后，如果节点标签发生了变化，不再满足 pod 指定的条件，pod 仍会在此节点继续运行</p></blockquote><ul><li><ul><li>软策略（关键字 prefer）：</li></ul></li></ul><blockquote><p>preferredDuringSchedulingIgnoredDuringExecution：</p><p>pod 优先部署到满足条件的节点，如果节点不满足条件，就忽略这些条件，调度到其他节点。</p><p>IgnoredDuringExecution 表示 pod 部署成功后，如果节点标签发生变化，不再满足 pod 指定条件，pod 仍会在此节点继续运行</p></blockquote><h3 id="4-3-kiali-节点亲和性调度"><a href="#4-3-kiali-节点亲和性调度" class="headerlink" title="4.3 kiali 节点亲和性调度"></a>4.3 kiali 节点亲和性调度</h3><p>​    kiali 节点亲和性调度如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585126913155121.png" srcset="/img/loading.gif" lazyload alt="第十五章 九析带你轻松完爆 service mesh - istio kiali 亲和性调度_istio 视频_06"></p><p>​    由图可知，kiali pod 有两个节点亲和性调度策略，一个软策略，一个硬策略。硬策略要求节点  beta.kubernetes.io/arch 标签值必须是  amd64, ppc64le，s390x 三个值之一，如果节点不满足此硬策略，pod 就会一直处于 pending  状态；当满足了此硬策略之后，pod 调度还要经过软策略调度，即：软策略要求节点 beta.kubernetes.io/arch 标签值为  amd64，ppc64le 和 s390x，并且不偏不倚，权重都是 2。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - istio kiali 内部介绍</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-kiali-%E5%86%85%E9%83%A8%E4%BB%8B%E7%BB%8D/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-kiali-%E5%86%85%E9%83%A8%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 预备知识</p><p>4 kiali 组件分析</p><p>5 config.yaml 文件</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585037381430496.png" srcset="/img/loading.gif" lazyload alt="第十四章 九析带你轻松完爆 service mesh - istio kiali 内部介绍_istio jaeger"></p><hr><h2 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h2><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585037389192861.png" srcset="/img/loading.gif" lazyload alt="第十四章 九析带你轻松完爆 service mesh - istio kiali 内部介绍_istio kiali_02"></p><hr><h2 id="3-预备知识"><a href="#3-预备知识" class="headerlink" title="3 预备知识"></a>3 预备知识</h2><p>​    有关 kiali 介绍、安装和使用请参考本人上三篇博客《<a href="https://blog.51cto.com/14625168/2474277"> 九析带你轻松完爆 istio 服务网格系列教程</a>》。这里介绍 istio 1.5.0 kiali 组件。</p><hr><h2 id="4-kiali-组件分析"><a href="#4-kiali-组件分析" class="headerlink" title="4 kiali 组件分析"></a>4 kiali 组件分析</h2><p>​    使用如下命令查看 kiali pod 详情：</p><blockquote><p>kubectl edit pod -n istio-system $(kubectl get pods -n istio-system | grep -i kiali | awk ‘{print $1}’)</p></blockquote><p>​    kiali pod 内只有一个容器，名称为 kiali。该容器在启动的过程中会运行容器内 kiali 进程，该进程会加载  /kiali-configuration/config.yaml 配置文件，该 config.yaml 文件定义了 kiali  进程运行时行为。pod 详情截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585037398490557.png" srcset="/img/loading.gif" lazyload alt="第十四章 九析带你轻松完爆 service mesh - istio kiali 内部介绍_istio jaeger_03"></p><p>​    kiali pod 内 /kiali-configuration/config.yaml 配置文件是通过挂载 configmap 获取到的，如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585037408977832.png" srcset="/img/loading.gif" lazyload alt="第十四章 九析带你轻松完爆 service mesh - istio kiali 内部介绍_istio prometheus_04"></p><p>​    configmap 信息如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585037415874758.png" srcset="/img/loading.gif" lazyload alt="第十四章 九析带你轻松完爆 service mesh - istio kiali 内部介绍_istio jaeger_05"></p><p>​    可以通过语句查看 kiali configmap 内容：</p><blockquote><p>kubectl edit configmap -n istio-system kiali</p></blockquote><p>​    kiali configmap 内容截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585037422449402.png" srcset="/img/loading.gif" lazyload alt="第十四章 九析带你轻松完爆 service mesh - istio kiali 内部介绍_istio 视频_06"></p><p>​    由上图可知，configmap 最终会以 config.yaml 文件的形式挂载到 kiali pod 中的 /kiali-configuration 目录下，登录 kiali pod 查看，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585037430405547.png" srcset="/img/loading.gif" lazyload alt="第十四章 九析带你轻松完爆 service mesh - istio kiali 内部介绍_istio kiali_07"></p><hr><h2 id="5-config-yaml-文件"><a href="#5-config-yaml-文件" class="headerlink" title="5 config.yaml 文件"></a>5 config.yaml 文件</h2><p>​    config.yaml 内容截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585037437643708.png" srcset="/img/loading.gif" lazyload alt="第十四章 九析带你轻松完爆 service mesh - istio kiali 内部介绍_istio jaeger_08"></p><p>​    该配置文件定义了 kiali 行为，下面分别介绍如下：</p><p>​    首先声明 istio 自身以及 istio 插件在 k8s 哪个命名空间下：</p><blockquote><p># istio 插件 grafana、tracing、pilot、prometheus</p><p>grafana: istio-system</p><p>tracing: istio-system</p><p>pilot: istio-system</p><p>prometheus: istio-system</p><p># istio 自身</p><p>istio_namespace: istio-system</p></blockquote><p>​    其次介绍 kiali 鉴权方式：</p><blockquote><p>auth:</p><p>  strategy: login  # 通过 login 方式进行鉴权</p></blockquote><p>​    再次介绍 kiali deployment 可以访问的 k8s 命名空间：</p><blockquote><p>deployment:</p><p>  accessible_namespaces: [‘**’]        # 没有限制，可访问任何命名空间</p></blockquote><p>​    接着介绍 kiali 对外服务的端口号和访问路径：</p><blockquote><p>server:</p><p>  port: 20001</p><p>  web_root: /kiali</p></blockquote><p>​    最后介绍 kiali 访问 istio、istio 插件（tracing、grafana、promethues）的 url 地址。注意该 url 必须是可以直接访问到的真实地址。</p><blockquote><p>external_services:</p><p>  istio:</p><p>​    url_service_version: <a href="http://istio-pilot.istio-system:8080/version">http://istio-pilot.istio-system:8080/version</a></p><p>  tracing:</p><p>​    url:</p><p>​    in_cluster_url: <a href="http://tracing/jaeger">http://tracing/jaeger</a></p><p>  grafana:</p><p>​    url:</p><p>​    in_cluster_url: <a href="http://grafana:3000/">http://grafana:3000</a></p><p>  prometheus:</p><p>​    url: <a href="http://prometheus.istio-system:9090/">http://prometheus.istio-system:9090</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - istio kiali bookinfo</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-kiali-bookinfo/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-kiali-bookinfo/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 安装 istio</p><p>4 安装 bookinfo 应用</p><p>5 设置 kiali</p><p>6 kiali 可视化 bookinfo</p><p>7 注入和观察流量</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584675889827788.png" srcset="/img/loading.gif" lazyload alt="第十三章 九析带你轻松完爆 service mesh - istio kiali bookinfo_istio 学习"></p><hr><h2 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h2><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584675897514592.png" srcset="/img/loading.gif" lazyload alt="第十三章 九析带你轻松完爆 service mesh - istio kiali bookinfo_istio kiali bookinf_02"></p><hr><h2 id="3-安装-istio"><a href="#3-安装-istio" class="headerlink" title="3 安装 istio"></a>3 安装 istio</h2><p>​    istio 安装教程请参考本人的博客《<a href="https://blog.51cto.com/14625168/2474224"> istio 安装</a>》。</p><hr><h2 id="4-安装-bookinfo-应用"><a href="#4-安装-bookinfo-应用" class="headerlink" title="4 安装 bookinfo 应用"></a>4 安装 bookinfo 应用</h2><p>​    bookinfo 是 istio 官方提供的样例程序。有关安装、istio 注入请参考本人的博客《<a href="https://blog.51cto.com/14625168/2474914"> istio bookinfo 应用</a>》。</p><hr><h2 id="5-设置-kiali"><a href="#5-设置-kiali" class="headerlink" title="5 设置 kiali"></a>5 设置 kiali</h2><p>​    kiali 是使用 istioctl 客户端工具安装 demo profile 时自动就会安装的组件，kiali 是一款 istio 服务网格可视化工具，提供了服务拓补图、全链路跟踪、指标遥测、配置校验、健康检查等功能。</p><p>​    有关 kiali 的配置和简单使用请参考本人的博客《<a href="https://blog.51cto.com/14625168/2479715"> kiali 安装</a>》和《<a href="https://blog.51cto.com/14625168/2479767"> kiali 使用</a>》。</p><hr><h2 id="6-kiali-可视化-bookinfo"><a href="#6-kiali-可视化-bookinfo" class="headerlink" title="6 kiali 可视化 bookinfo"></a>6 kiali 可视化 bookinfo</h2><p>​    登录 kiali，进入 overview 菜单，选中 bookinfo 应用，如下图所示，本人布置在 jiuxi 命名空间：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584675907738139.png" srcset="/img/loading.gif" lazyload alt="第十三章 九析带你轻松完爆 service mesh - istio kiali bookinfo_istio 视频_03"></p><p>​    点击进入 jiuxi 命名空间下的 “4 Applications” ， 进入 “Applications” 视图，可见 bookinfo 样例下的 4 个微服务，并且当前这 4 个微服务状态都健康（Health ✔）如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584675915689224.png" srcset="/img/loading.gif" lazyload alt="第十三章 九析带你轻松完爆 service mesh - istio kiali bookinfo_istio kiali_04"></p><p>​    最关键的可视化内容可以查看 “Graph” 菜单，如下所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584675923857146.png" srcset="/img/loading.gif" lazyload alt="第十三章 九析带你轻松完爆 service mesh - istio kiali bookinfo_kiali bookinfo_05"></p><p>​    下面重点介绍 “Graph” 视图下的功能：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584675930269547.png" srcset="/img/loading.gif" lazyload alt="第十三章 九析带你轻松完爆 service mesh - istio kiali bookinfo_istio 学习_06"></p><blockquote><p>1 命名空间</p><p>2 分类图展示：app（应用视角，label 名为 app，并且 app 值相同的资源算作一类  app）、service（k8s服务视角）、versioned app（标记版本应用视角）、workload（k8s工作负载视角，比如  deployment、job、statefulset、daemonset）</p><p>3 指标展示：Requests per second（每秒多少请求）、Requests percent（请求分布占比）、Response time（响应时间）</p><p>4 显示过滤器：各种显示开关，用复选框表示；可以选择 Traffic Animation，爽爽看</p><p>5 规格过滤显示：可以把它类比为 grep 命令，通过定义好的过滤规则，高亮图的某些组件或元素，比如在 find 字段输入 httpout &gt; 0.5 后回车，可看到如下截图所示</p><p>6 三角形表示 k8s 服务</p><p>7 圆形表示 k8s workload</p><p>8 时间间隔的流量选择器：比如 1m（分钟）、5m、10m、30m、1h（小时）、3h、6h</p><p>9 页面刷新频率：比如每 10 秒、每 15 秒、每 30 秒、每 1 分钟、每 5 分钟、每 15 分钟</p><p>10 命名空间</p><p>11 入口流量、出口流量和总流量显示</p><p>12 图例说明：解释图中各个形状各代表什么意思</p><p>13 layout：不同展示风格（共有三种，选择自己的喜好）</p></blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584675942103722.png" srcset="/img/loading.gif" lazyload alt="第十三章 九析带你轻松完爆 service mesh - istio kiali bookinfo_istio kiali bookinf_07"></p><hr><h2 id="7-注入和观察流量"><a href="#7-注入和观察流量" class="headerlink" title="7 注入和观察流量"></a>7 注入和观察流量</h2><p>​    选择 ingressgateway svc，通过如下指令：</p><blockquote><p>kubectl get svc -n istio-system -o wide    # jiuxi 是我自定义命名空间</p></blockquote><p>​    执行结果如下图：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584675950551018.png" srcset="/img/loading.gif" lazyload alt="第十三章 九析带你轻松完爆 service mesh - istio kiali bookinfo_kiali bookinfo_08"></p><p>​    因为服务类型是 NodePort，所以 ip 要选择宿主机 ip，而不是 svc cluster-ip 或者是 pod ip，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584675958536850.png" srcset="/img/loading.gif" lazyload alt="第十三章 九析带你轻松完爆 service mesh - istio kiali bookinfo_istio kiali_09"></p><p>​    通过 curl 命令打入流量：</p><blockquote><p>while true; do curl <a href="http://10.110.101.98:30100/productpage">http://10.110.101.98:30100/productpage</a>; done</p></blockquote><p>​    通过 kiali graph 视图:</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584675965312153.png" srcset="/img/loading.gif" lazyload alt="第十三章 九析带你轻松完爆 service mesh - istio kiali bookinfo_kiali bookinfo_10"></p><p>​    自此，九析带你轻松完爆 istio kiali bookinfo 应用。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - istio kiali 使用篇</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-kiali-%E4%BD%BF%E7%94%A8%E7%AF%87/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-kiali-%E4%BD%BF%E7%94%A8%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 kiali 控制台</p><p>  3.1 Overview（概观）</p><p>  3.2 Application（应用维度）</p><p>  3.3 workloads（负载维度）</p><p>  3.4 Services（服务维度）</p><p>  3.5 Istio Config（配置维度）</p><p>  3.6 Distributed Tracing（分布式追踪维度）</p><p>4 kiali 架构</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584520514843229.png" srcset="/img/loading.gif" lazyload alt="第十二章 九析带你轻松完爆 service mesh - istio kiali 使用篇_kiali"></p><hr><h2 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h2><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584520523824579.png" srcset="/img/loading.gif" lazyload alt="第十二章 九析带你轻松完爆 service mesh - istio kiali 使用篇_istio kiali_02"></p><hr><h2 id="3-kiali-控制台"><a href="#3-kiali-控制台" class="headerlink" title="3 kiali 控制台"></a>3 kiali 控制台</h2><p>​    kiali 控制台菜单截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584520596533648.png" srcset="/img/loading.gif" lazyload alt="第十二章 九析带你轻松完爆 service mesh - istio kiali 使用篇_istio kiali_03"></p><h3 id="3-1-Overview（概观）"><a href="#3-1-Overview（概观）" class="headerlink" title="3.1 Overview（概观）"></a>3.1 Overview（概观）</h3><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584520614680521.png" srcset="/img/loading.gif" lazyload alt="第十二章 九析带你轻松完爆 service mesh - istio kiali 使用篇_istio kiali_04"></p><p>​    该菜单全局性展示所有命名空间下服务的流量（traffic）、配置状态（config status）、健康状态（✔）、应用数量（Applications）等。</p><h3 id="3-2-Application（应用维度）"><a href="#3-2-Application（应用维度）" class="headerlink" title="3.2 Application（应用维度）"></a>3.2 Application（应用维度）</h3><p>​    applications 指运行中的应用，kiali 独有概念。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584520628534290.png" srcset="/img/loading.gif" lazyload alt="第十二章 九析带你轻松完爆 service mesh - istio kiali 使用篇_kiali 安装_05"></p><p>​    特别注意 kiali 只能识别设置了 app 标签的应用。如果一个应用有多个版本，需要将这几个版本的 app 标签设置为相同的值。</p><p>​    执行如下命令查看 default 命名空间的 deployment：</p><blockquote><p>kubectl get deployments.apps –show-labels</p></blockquote><p>​    命令结果如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911213848142.png" srcset="/img/loading.gif" lazyload alt="image-20210911213848142"></p><p>​    从执行结果来看，default 空间下有 2 个 deployment，但是只有一个 deployment 的标签具有 app 标识，因此在 kiali 中只显示出了 nfs-client-provisioner 应用。</p><h3 id="3-3-workloads（负载维度）"><a href="#3-3-workloads（负载维度）" class="headerlink" title="3.3 workloads（负载维度）"></a>3.3 workloads（负载维度）</h3><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584520645575695.png" srcset="/img/loading.gif" lazyload alt="第十二章 九析带你轻松完爆 service mesh - istio kiali 使用篇_kiali_07"></p><p>​    kiali 中的负载（workloads）跟 k8s 中的资源对应（比如 deployment、Job、Daemonset、Statefulset  等）。k8s 中的这些资源都可以在 kiali 中检测到，不管这些资源有没有加入到 istio 服务网格中。</p><h3 id="3-4-Services（服务维度）"><a href="#3-4-Services（服务维度）" class="headerlink" title="3.4 Services（服务维度）"></a>3.4 Services（服务维度）</h3><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584520655713870.png" srcset="/img/loading.gif" lazyload alt="第十二章 九析带你轻松完爆 service mesh - istio kiali 使用篇_kiali_08"></p><p>​    对应 k8s 的 service 资源类型。</p><h3 id="3-5-Istio-Config（配置维度）"><a href="#3-5-Istio-Config（配置维度）" class="headerlink" title="3.5 Istio Config（配置维度）"></a>3.5 Istio Config（配置维度）</h3><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584520663652461.png" srcset="/img/loading.gif" lazyload alt="第十二章 九析带你轻松完爆 service mesh - istio kiali 使用篇_kiali 安装_09"></p><p>​    istio 相关配置类信息。比如这里选择 istio type 类型，将显示有关 istio 服务网格下面的各个类型对应的配置信息状态（✔ 表示配置有效；！表示告警），如上图所示。</p><p>3.6 Distributed Tracing（分布式追踪维度）</p><h3 id="有关分布式追踪跟其他组件有关（jaeger），以后会详述。"><a href="#有关分布式追踪跟其他组件有关（jaeger），以后会详述。" class="headerlink" title="有关分布式追踪跟其他组件有关（jaeger），以后会详述。"></a>有关分布式追踪跟其他组件有关（jaeger），以后会详述。</h3><hr><h2 id="4-kiali-架构"><a href="#4-kiali-架构" class="headerlink" title="4 kiali 架构"></a>4 kiali 架构</h2><p>​    下图是 kiali 架构：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584520675671264.png" srcset="/img/loading.gif" lazyload alt="第十二章 九析带你轻松完爆 service mesh - istio kiali 使用篇_istio kiali 安装_10"></p><p>​    由架构图可知，kiali 架构还是比较简单的，属于单体应用。kiali 后台既可以跟外部服务 prometheus、cluster API 进行通信获取 istio  服务网格信息，也可以集成可选服务 jaeger 和 grafana做全链路跟踪和可视化指标度量。</p><p>​    自此，九析带你轻松完爆 istio kiali 使用。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - istio kiali 安装</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-kiali-%E5%AE%89%E8%A3%85/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-kiali-%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 kiali 简介</p><p>4 kiali 安装</p><p>5 kiali 访问</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584516653984882.png" srcset="/img/loading.gif" lazyload alt="第十一章 九析带你轻松完爆 service mesh - istio kiali 安装_kiali jaeger"></p><hr><h2 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h2><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584516661797993.png" srcset="/img/loading.gif" lazyload alt="第十一章 九析带你轻松完爆 service mesh - istio kiali 安装_kaili_02"></p><hr><h2 id="3-kiali-简介"><a href="#3-kiali-简介" class="headerlink" title="3 kiali 简介"></a>3 kiali 简介</h2><p>​    kiali 是一款 istio 服务网格可视化工具，提供了服务拓补图、全链路跟踪、指标遥测、配置校验、健康检查等功能。</p><hr><h2 id="4-kiali-安装"><a href="#4-kiali-安装" class="headerlink" title="4 kiali 安装"></a>4 kiali 安装</h2><p>​    如果使用 istioctl 安装 istio 时采用的 profile 是 demo 的话（有关 profile 介绍，请参照本人的《 <a href="https://blog.51cto.com/14625168/2479111"> istioctl profile 介绍</a>》），默认就会安装好 kiali。istio 安装请参照本人的《<a href="https://blog.51cto.com/14625168/2474224"> istio 安装</a>》博客分分钟轻松完爆。安装好后，直接执行如下命令查看 kiali 组件：</p><blockquote><p>kubectl get all -n istion-system</p></blockquote><p>​    执行结果如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584516715612147.png" srcset="/img/loading.gif" lazyload alt="第十一章 九析带你轻松完爆 service mesh - istio kiali 安装_istio 学习_03"></p><hr><h2 id="5-kiali-访问"><a href="#5-kiali-访问" class="headerlink" title="5 kiali 访问"></a>5 kiali 访问</h2><p>​    在集群内，通过 curl 命令行工具访问 kiali：</p><blockquote><p>curl <a href="http://10.101.30.105:20001/"> http://10.101.30.105:20001</a></p></blockquote><p>​    执行结果如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584516724636987.png" srcset="/img/loading.gif" lazyload alt="第十一章 九析带你轻松完爆 service mesh - istio kiali 安装_kiali jaeger_04"></p><p>​    上图所示 kiali 已经部署成功，服务处于就绪状态。下面改成外部浏览器可以直接访问，需要将 service 的服务类型设置为 nodeport，执行命令如下：</p><blockquote><p>kubectl patch svc -n istio-system kiali -p ‘{“spec”: {“type”: “NodePort”}}’</p></blockquote><p>​    执行结果如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584516731417402.png" srcset="/img/loading.gif" lazyload alt="第十一章 九析带你轻松完爆 service mesh - istio kiali 安装_istio 视频_05"></p><p>​    打开浏览器，访问 k8s 所在服务器 IP 和 NodePort 暴露出来的端口号（这里是 31479），如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584516740649530.png" srcset="/img/loading.gif" lazyload alt="第十一章 九析带你轻松完爆 service mesh - istio kiali 安装_istio kiali_06"></p><p>​    默认用户名密码是 admin/admin，输入后登录：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584516749156466.png" srcset="/img/loading.gif" lazyload alt="第十一章 九析带你轻松完爆 service mesh - istio kiali 安装_istio kiali_07"></p><p>​    自此，九析带你轻松完爆 istio kiali 安装。关于 kiali 说明和使用将在下章说明。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - istio profile 详述</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-profile-%E8%AF%A6%E8%BF%B0/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-profile-%E8%AF%A6%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 istio 之 profile</p><p>3 istioctl profile</p><p>  3.1 demo</p><p>  3.2 minimal</p><p>  3.3 default</p><p>  3.4 empty</p><p>  3.5 remote</p><p>  3.6 separate</p><p>4 总结</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584368141584701.jpeg" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 service mesh - istio profile 详述_istio 安装"></p><p>​    你可以从下面截图中获取免费的、更生动的视频资料：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584440587356556.png" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 service mesh - istio profile 详述_istio 视频_02"></p><hr><h2 id="2-istio-之-profile"><a href="#2-istio-之-profile" class="headerlink" title="2 istio 之 profile"></a>2 istio 之 profile</h2><p>​    在介绍 istio profile 之前，我们先介绍一下电信的套餐：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584368156493068.png" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 service mesh - istio profile 详述_istio 教程_03"></p><p>​    我们去电信开通手机业务时，一般都会选择手机套餐，不同的手机套餐会提供不同的增值服务。如上图所示，每个套餐就是一个 profile。istioctl 在安装 istio 时提供的 profile 概念与此类似，不同 profile 定义了不同的 istio  控制面行为。</p><hr><h2 id="3-istioctl-profile"><a href="#3-istioctl-profile" class="headerlink" title="3 istioctl profile"></a>3 istioctl profile</h2><p>​    使用如下命令查看 istioctl  profile：</p><blockquote><p>istioctl profile list</p></blockquote><p>​    执行结果如下图所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584368172412822.png" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 service mesh - istio profile 详述_istio profile_04"></p><h3 id="3-1-demo"><a href="#3-1-demo" class="headerlink" title="3.1 demo"></a>3.1 demo</h3><p>​    demo profile 仅供学习使用，并不合适作为生产环境。该 profile 会安装  ingressgateway、egressgateway、istio-pilot 等 istio 组件，同时会安装  grafana、istio-tracing、kiali、prometheus 等外部插件。使用如下命令查看 demo profile 的  istio 安装配置清单：</p><blockquote><p>istioctl profile dump demo</p></blockquote><p>​    从 dump 出的 profile 来看，最重要的是两块配置：插件和组件。插件是指外部第三方依赖，比如  grafana、kiali、prometheus、tracing；组件是指 istio 自身的组件，比如  citadel、egressgateway、ingressgateway、pilot、policy、sidecarInjector、telemetry 等。如下截图所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584368188341223.png" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 service mesh - istio profile 详述_istio profile_05"><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 service mesh - istio profile 详述_istio profile_06"></p><p>​    部分组件信息如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584368199256308.png" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 service mesh - istio profile 详述_istio 安装_07"></p><p>​    总结 demo profile 的组件、插件的开关情况信息如下截图所示，其中 X 代表开启组件或插件：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584368214844438.png" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 service mesh - istio profile 详述_istio profile_08"></p><h3 id="3-2-minimal"><a href="#3-2-minimal" class="headerlink" title="3.2 minimal"></a>3.2 minimal</h3><p>​    minimal profile 仅仅开启了 pilot 组件，其他的组件或者插件都是关闭的状态，可以通过如下命令查看明细：</p><blockquote><p>istioctl profile dump minimal &gt; minimal.yaml</p></blockquote><p>​    如下图所示，minimal 插件都是关闭的：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584368226455115.png" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 service mesh - istio profile 详述_istio 视频_09"></p><p>​    仅有 pilot 组件是开启状态：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584368242534892.png" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 service mesh - istio profile 详述_istio 安装_10"></p><p>​    符合官方描述，如下图所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584368252181812.png" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 service mesh - istio profile 详述_istio profile_11"></p><h3 id="3-3-default"><a href="#3-3-default" class="headerlink" title="3.3 default"></a>3.3 default</h3><p>​    default 是官方推荐的 istio 安装 profile。它在组件和插件的选择上做到了最合适，比如组件中它只开启了 ingressgateway、pilot，插件中只开启了 prometheus。如下图所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584368262600119.png" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 service mesh - istio profile 详述_istio profile_12"></p><h3 id="3-4-empty"><a href="#3-4-empty" class="headerlink" title="3.4 empty"></a>3.4 empty</h3><p>​    empty profile 不会开启任何组件或者插件。该 profile 的作用是提供一个干净的模板供有经验的 istio 使用者自定义配置。</p><h3 id="3-5-remote"><a href="#3-5-remote" class="headerlink" title="3.5 remote"></a>3.5 remote</h3><p>​    remote profile 在实际使用中情况并不多见。该 profile 提供共享控制面去操作多集群服务网格。remote profile 官方提供的组件、插件描述如下图所示，但是根据本人实际观察，发现并不准确，特别标注在下图中：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584368292162685.png" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 service mesh - istio profile 详述_istio 服务网格_13"></p><p>​    dump 出的 ingress-gateway 组件应该处于开启状态：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584368303338153.png" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 service mesh - istio profile 详述_istio profile_14"></p><p>​    dump 出来的 pilot 组件应该处于开启状态：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584368314215522.png" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 service mesh - istio profile 详述_istio 教程_15"></p><h3 id="3-6-separate"><a href="#3-6-separate" class="headerlink" title="3.6 separate"></a>3.6 separate</h3><p>​    官方宣称 separate profile 在未来的版本中将要被废弃掉了，所以就直接略过不提了吧。大家都生活得够艰难了，就不要给自己找麻烦了。</p><hr><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>​    本小节介绍了 istioctl 安装 istio 时提供的各个 profile，已经可以覆盖 90%  上的工作场景了。但是有些技术小骚仍然不会满足，那么后续哥将会继续提供自定义配置安装的方法，请继续跟随九析的脚步，我们一同轻松完爆 istio。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - istio upgrade 升级</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-upgrade-%E5%8D%87%E7%BA%A7/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-upgrade-%E5%8D%87%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 升级前的准备</p><p>3 升级步骤</p><p>  3.1 下载新版本的 istio</p><p>  3.2 解压缩 istio</p><p>  3.3 设置 istioctl 环境变量</p><p>  3.4 设置 istio 自动补全功能</p><p>  3.5 验证新版本 istio 是否兼容老版本</p><p>  3.6 创建升级配置文件</p><p>  3.7 升级 istio</p><p>​    3.7.1 资源等待错误</p><p>​    3.7.2 资源冲突错误</p><p>​    3.8 重设数据平面</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173739515.png" srcset="/img/loading.gif" lazyload alt="image-20210911173739515"></p><p>​    今天杭州阴天，哥的心情不怎么嗨！因为哥前期都在使用 1.4.5 版本，但是这周 istio 官方没经我允许就擅自升级到了 1.5 版本，打了我一个措手不及。但是互联网这十几年没少教育我，于是痛定思痛决定拥抱变化。</p><hr><h2 id="2-升级前的准备"><a href="#2-升级前的准备" class="headerlink" title="2 升级前的准备"></a>2 升级前的准备</h2><p>​    就像你撸管前要先把纸准备好一样，在升级 istio 前，要先做一些前期准备工作。</p><blockquote><p>1 检查 istio 版本是不是 1.4.4 或更高版本</p><p>2 确定 istio 安装采用的是 istioctl 安装</p></blockquote><p>​    使用如下命令查看当前 istio 安装版本：</p><blockquote><p>istioctl version</p></blockquote><p>​    命令截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173755955.png" srcset="/img/loading.gif" lazyload alt="image-20210911173755955"></p><p>​    由此可知，istio 当前的客户端、控制平面、数据平面的版本都是 1.4.5 版本。</p><p>​    通过查看 istio pod 的镜像也可以确认当前 istio 各组件的相关版本，如下图：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173809501.png" srcset="/img/loading.gif" lazyload alt="image-20210911173809501"></p><hr><h2 id="3-升级步骤"><a href="#3-升级步骤" class="headerlink" title="3 升级步骤"></a>3 升级步骤</h2><h3 id="3-1-下载新版本的-istio"><a href="#3-1-下载新版本的-istio" class="headerlink" title="3.1 下载新版本的 istio"></a>3.1 下载新版本的 istio</h3><p>​    执行如下命令下载最新版的 istio：</p><blockquote><p>curl -L <a href="https://istio.io/downloadIstio">https://istio.io/downloadIstio</a> | sh -</p></blockquote><p>​    也可以直接下载指定版本的 istio：</p><blockquote><p>curl -L <a href="https://istio.io/downloadIstio">https://istio.io/downloadIstio</a> | ISTIO_VERSION=1.5.0 sh -</p></blockquote><p>​    当然很多情况下，你都会遭遇网络情况，如下所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173821564.png" srcset="/img/loading.gif" lazyload alt="image-20210911173821564"></p><p>​    你能怎么办？你什么感觉？是不是就像大便找不到厕所？或者找到厕所却发现没坑？</p><p>​    实在下不到，你也不要悲愤，可以告诉哥，哥直接发给你，不用谢！</p><p>​    如下截图有没有看到，哥可以下，但是你们却下不到，你说气人不？</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173831924.png" srcset="/img/loading.gif" lazyload alt="image-20210911173831924"></p><h3 id="3-2-解压缩-istio"><a href="#3-2-解压缩-istio" class="headerlink" title="3.2 解压缩 istio"></a>3.2 解压缩 istio</h3><p>​    安装 istio 前，首先解压缩：</p><blockquote><p>tar -zxvf istio-1.5.0-linux.tar.gz</p></blockquote><p>​    解压缩后的目录结构截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173847127.png" srcset="/img/loading.gif" lazyload alt="image-20210911173847127"></p><p>​    关键目录、文件说明如下：</p><blockquote><p>1 bin/istioctl    # 客户端工具</p><p>2 install    # 底层支持平台的资源文件，istio 可支持 consul、gcp、k8s 平台</p><p>3 samples    # 学习样例</p></blockquote><h3 id="3-3-设置-istioctl-环境变量"><a href="#3-3-设置-istioctl-环境变量" class="headerlink" title="3.3 设置 istioctl 环境变量"></a>3.3 设置 istioctl 环境变量</h3><p>​    因为我曾经设置过老版本 istioctl 环境变量，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173859461.png" srcset="/img/loading.gif" lazyload alt="image-20210911173859461"></p><p>​    所以首先需要通过如下命令进行删除：</p><blockquote><p>export PATH=<code>echo $PATH | sed -e &#39;s/:\/root\/istio\/istio-1.4.5\/bin//g&#39;</code></p></blockquote><p>​    删除后截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173926207.png" srcset="/img/loading.gif" lazyload alt="image-20210911173926207"></p><p>​    将新版本 istioctl 路径添加到系统环境路径中：</p><blockquote><p>cd istio-1.5.0</p><p>export PATH=$PATH:$PWD/bin</p><p>istioctl version</p></blockquote><p>​    执行成功后，验证版本如下图所示，发现当前 istioctl 客户端版本已经更新为 1.5.0，但是控制面和数据面仍然是 1.4.5，这说明当前我们只是完成了 istio 客户端的改造，而控制面和数据面版本要升级完才会更改：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173939403.png" srcset="/img/loading.gif" lazyload alt="image-20210911173939403"></p><h3 id="3-4-设置-istio-自动补全功能"><a href="#3-4-设置-istio-自动补全功能" class="headerlink" title="3.4 设置 istio 自动补全功能"></a>3.4 设置 istio 自动补全功能</h3><p>​    将 istio 安装包 tools 目录下的 istioctl.bash 拷贝到用户根目录下：</p><blockquote><p>cp istio-1.5.0/tools/istioctl.bash ~</p></blockquote><p>​    编辑 ~/.bash_profile 文件，在文件末尾添加如下内容：</p><blockquote><p>PATH=$PATH:$HOME/bin</p><p>PATH=$PATH:/root/istio/istio-1.5.0/bin</p><p>export PATH</p><p>source /root/.istioctl.bash</p></blockquote><p>​    添加完毕后，加载配置使之生效：</p><blockquote><p>source ~/.bash_profile</p></blockquote><p>​    然后输入 istioctl 然后按两次 tab 键，发现自动补全功能已经生效：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173949422.png" srcset="/img/loading.gif" lazyload alt="image-20210911173949422"></p><h3 id="3-5-验证新版本-istio-是否兼容老版本"><a href="#3-5-验证新版本-istio-是否兼容老版本" class="headerlink" title="3.5 验证新版本 istio 是否兼容老版本"></a>3.5 验证新版本 istio 是否兼容老版本</h3><p>​    执行如下命令查看新版本 istio 可兼容的版本范围：</p><blockquote><p>istioctl manifest versions</p></blockquote><p>​    如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173959253.png" srcset="/img/loading.gif" lazyload alt="image-20210911173959253"></p><p>​    明确新版本 istio 可升级，则继续往下操作。</p><h3 id="3-6-创建升级配置文件"><a href="#3-6-创建升级配置文件" class="headerlink" title="3.6 创建升级配置文件"></a>3.6 创建升级配置文件</h3><p>​    我以前安装 istio 采用的 profile 是 demo：</p><blockquote><p>istioctl manifest apply –set profile=demo</p></blockquote><p>​    怎么理解 profile，你可以跟下图做类比：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911174010406.png" srcset="/img/loading.gif" lazyload alt="image-20210911174010406"></p><p>​    也就是同样型号比如 G 级别车，一共有三个版本，每个版本就是一个 profile，每个 profile 的参数或者配置都有区别。</p><p>​    你也可以通过如下命令查看你的 istio 1.5.0 版本共有几个 profile：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911174020192.png" srcset="/img/loading.gif" lazyload alt="image-20210911174020192"></p><p>​    但是可惜地是，istio 安装时支持 set 参数，比如你可以使用如下命令安装：</p><blockquote><p>istioctl manifest apply –set profile=demo</p></blockquote><p>​    但是 istioctl upgrade 命令不支持 –set 选项，因此，如果前期在安装的时候使用了 –set 选项，那么在升级时需要创建一个等效的配置选项文件。</p><p>​    使用如下命令创建 profile 为 demo 的等效配置文件：</p><blockquote><p>istioctl profile dump demo &gt; demo.yaml</p></blockquote><h3 id="3-7-升级-istio"><a href="#3-7-升级-istio" class="headerlink" title="3.7 升级 istio"></a>3.7 升级 istio</h3><p>​    执行如下命令来升级 istio：</p><blockquote><p>istioctl upgrade -f demo.yaml</p></blockquote><p>​    升级过程截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911174030581.png" srcset="/img/loading.gif" lazyload alt="image-20210911174030581"></p><p>​    如果升级过程很顺畅，就可以跳过此小节继续下面的内容；如果升级过程并不顺利，可以根据下面的介绍进行修改。</p><h4 id="3-7-1-资源等待错误"><a href="#3-7-1-资源等待错误" class="headerlink" title="3.7.1 资源等待错误"></a>3.7.1 资源等待错误</h4><p>​    如果在升级过程中遭遇如下日志信息：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911174040082.png" srcset="/img/loading.gif" lazyload alt="image-20210911174040082"></p><blockquote><p>error    installer    Failed to wait for resource: resources not ready after 10m0s: timed out waiting for the condition</p><p>Deployment/istio-system/istiod</p></blockquote><p>​    多半是因为镜像下载问题，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911174050011.png" srcset="/img/loading.gif" lazyload alt="image-20210911174050011"></p><p>​    可以指定 aliyun 作为镜像源：</p><blockquote><p>touch /etc/docker/daemon.json</p><p>vim /etc/docker/daemon.json</p></blockquote><p>​    添加如下内容：</p><blockquote><p>{</p><p>“registry-mirrors”: [“<a href="https://9cpn8tt6.mirror.aliyuncs.com&quot;]">https://9cpn8tt6.mirror.aliyuncs.com&quot;]</a></p><p>}</p></blockquote><p>​    添加完成后执行如下操作：</p><blockquote><p>systemctl daemon-reload</p><p>systemctl restart docker</p></blockquote><h4 id="3-7-2-资源冲突错误"><a href="#3-7-2-资源冲突错误" class="headerlink" title="3.7.2 资源冲突错误"></a>3.7.2 资源冲突错误</h4><p>​    如果在安装过程中出现如下错误：</p><blockquote><p>Error: failed to read the current Istio version, error: different versions of Istio components found</p></blockquote><p>​    错误截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911174102383.png" srcset="/img/loading.gif" lazyload alt="image-20210911174102383"></p><p>​    多半是因为镜像版本冲突，可以执行如下命令查看：</p><blockquote><p>istioctl version</p></blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911174112229.png" srcset="/img/loading.gif" lazyload alt="image-20210911174112229"></p><p>​    改正办法是删除错误版本的 deployment 后再升级（istioctl upgrade）：</p><blockquote><p>kubectl delete deployments.apps -n istio-system istio-egressgateway</p></blockquote><p>​    升级成功后的截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911174121033.png" srcset="/img/loading.gif" lazyload alt="image-20210911174121033"></p><p>​    再次执行 istioctl version，可以发现 istioctl 的客户端、数据面、控制面都从 1.4.5 变成了 1.5.0。如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911174133509.png" srcset="/img/loading.gif" lazyload alt="image-20210911174133509"></p><h3 id="3-8-重设数据平面"><a href="#3-8-重设数据平面" class="headerlink" title="3.8 重设数据平面"></a>3.8 重设数据平面</h3><p>​    从上面的截图中，其实可以发现一个端倪，就是 data plane version 有一个 proxy 仍是 1.4.5。产生这样的原因是我在升级 istio 版本前就已经手工注入了一个  deployment，现在需要重置原有数据平面。执行如下命令重置原有被注入的 nginx deployment：</p><blockquote><p>istioctl kube-inject -f nginx-deploy.yaml | kubectl apply -f -</p></blockquote><p>​    再次执行 istioctl version 命令发现客户端、数据面、控制面的版本都更新到了最新的状态，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911174144682.png" srcset="/img/loading.gif" lazyload alt="image-20210911174144682"></p><p>​    自此，九析带你轻松完爆 istio 的升级。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - istio 注入后网络流量流向</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-%E6%B3%A8%E5%85%A5%E5%90%8E%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%B5%81%E5%90%91/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-%E6%B3%A8%E5%85%A5%E5%90%8E%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%B5%81%E5%90%91/</url>
    
    <content type="html"><![CDATA[<p>目录</p><p>1 前言</p><p>2 查看 iptables 规则</p><p>  2.1 确定 pod 所在主机</p><p>  2.2 定位 istio-proxy 容器</p><p>  2.3 登录 istio-proxy 容器</p><p>  2.4 查看 iptables 规则</p><p>3 网络宏观流量流向介绍</p><p>4 网络微观流量流向介绍</p><p>5 istio 入口流量分析</p><p>6 istio 出口流量分析</p><p>7 小节</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911172944559.png" srcset="/img/loading.gif" lazyload alt="image-20210911172944559"></p><p>​    上节中我们举例介绍了执行 istio 注入操作后，对 nginx pod 所产生的影响，即在 pod 中会多创建两个容器：istio-init、istio-proxy，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911172956747.png" srcset="/img/loading.gif" lazyload alt="image-20210911172956747"></p><p>​    如果从进程角度来看 pod，则是下面这个样子：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173007202.png" srcset="/img/loading.gif" lazyload alt="image-20210911173007202"></p><p>​    从上图可知，nginx pod 内的三个容器共享同一个网络命名空间，该网络命名空间内的流量流向规则在初始化容器 istio-init 启动时完成的，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173017468.png" srcset="/img/loading.gif" lazyload alt="image-20210911173017468"></p><hr><h2 id="2-查看-iptables-规则"><a href="#2-查看-iptables-规则" class="headerlink" title="2 查看 iptables 规则"></a>2 查看 iptables 规则</h2><p>​    一般情况下，我们可以通过 kubectl exec 命令跟 pod 进行交互并获取到 pod 内信息，但这里我们不能此法获取到 pod 内的 iptables 信息。如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173028740.png" srcset="/img/loading.gif" lazyload alt="image-20210911173028740"></p><p>​    如果想获取到 iptables 信息，必须通过宿主机的 docker 才能获取到。</p><h3 id="2-1-确定-pod-所在主机"><a href="#2-1-确定-pod-所在主机" class="headerlink" title="2.1 确定 pod 所在主机"></a>2.1 确定 pod 所在主机</h3><p>​    使用如下命令获取运行 nginx pod 的宿主机地址：</p><blockquote><p>kubectl get pods -n jiuxi -o wide</p></blockquote><p>​    命令执行结果如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173039235.png" srcset="/img/loading.gif" lazyload alt="image-20210911173039235"></p><h3 id="2-2-定位-istio-proxy-容器"><a href="#2-2-定位-istio-proxy-容器" class="headerlink" title="2.2 定位 istio-proxy 容器"></a>2.2 定位 istio-proxy 容器</h3><p>​    ssh 命令登录到 10.244.10.80 宿主机，并执行如下命令定位 istio-proxy 容器：</p><blockquote><p>docker ps | grep -i istio-proxy</p></blockquote><p>​    执行结果如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173049597.png" srcset="/img/loading.gif" lazyload alt="image-20210911173049597"></p><h3 id="2-3-登录-istio-proxy-容器"><a href="#2-3-登录-istio-proxy-容器" class="headerlink" title="2.3 登录 istio-proxy 容器"></a>2.3 登录 istio-proxy 容器</h3><blockquote><p>docker exec -it –privileged $(docker ps | grep -i istio-proxy | awk ‘{print $(1)}’) bash</p></blockquote><h3 id="2-4-查看-iptables-规则"><a href="#2-4-查看-iptables-规则" class="headerlink" title="2.4 查看 iptables 规则"></a>2.4 查看 iptables 规则</h3><p>​    执行如下命令查看 iptables 规则：</p><blockquote><p>iptables -nvL -t nat</p></blockquote><p>​    执行结果会报如下错误：</p><blockquote><p>can’t initialize iptables table `nat’: Permission denied (you must be root)</p></blockquote><p>​    执行如下命令切换成 root 用户轻松完爆：</p><blockquote><p>sudo su root</p></blockquote><p>​    再次执行 iptables 即可，操作成功如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173100959.png" srcset="/img/loading.gif" lazyload alt="image-20210911173100959"></p><hr><h2 id="3-网络宏观流量流向介绍"><a href="#3-网络宏观流量流向介绍" class="headerlink" title="3 网络宏观流量流向介绍"></a>3 网络宏观流量流向介绍</h2><p>​    下面宏观介绍一下基本的网络流量流向知识，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173113518.png" srcset="/img/loading.gif" lazyload alt="image-20210911173113518"></p><p>​    用户从客户端发起一个 http  请求，该请求会通过互联网到达公司网络的外部边界（路由器），路由器会将网络流量送到交换机，因为反向代理服务器跟交换机联通，因此流量到达反向代理服务器（nginx），nginx 再将网络请求按照预先制定的分发策略转给后面真正处理请求的 web 服务器。</p><p>​    你可以通过 traceroute 命令定位一下外部网络流向。比如访问 <a href="http://www.baidu.com：">www.baidu.com：</a></p><blockquote><p>traceroute -I <a href="http://www.baidu.com/"> www.baidu.com</a></p></blockquote><p>​    访问截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173124326.png" srcset="/img/loading.gif" lazyload alt="image-20210911173124326"></p><p>​    通过上面的截图可知，本人访问 baidu.com 共经过了 13 个路由器。</p><p>​    当然也可以通过 traceroute 定位 k8s 中 pod 的网络流向，如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173134127.png" srcset="/img/loading.gif" lazyload alt="image-20210911173134127"></p><p>​    由上图可知：</p><blockquote><p>1 首先定位 nginx pod 的 ip 为 10.244.10.80</p><p>2 其次开始 traceroute 进行追踪，发现流量先经过 10.244.10.0，然后访问到 10.244.10.80</p><p>3 接着查看本地路由表得知访问 10.244.10.0 的流量是从网络设备 flannel.1 发出去的</p><p>4 最后查看了一下网络设备 flannel.1 的详细信息</p></blockquote><hr><h2 id="4-网络微观流量流向介绍"><a href="#4-网络微观流量流向介绍" class="headerlink" title="4 网络微观流量流向介绍"></a>4 网络微观流量流向介绍</h2><p>​    微观是指流量进入宿主机的情况分析，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173145054.png" srcset="/img/loading.gif" lazyload alt="image-20210911173145054"></p><p>​    由上图可知：</p><blockquote><p>1 入口流量经过服务器网卡进入服务器的网络协议栈</p><p>2 服务器网络协议栈会根据预先定制的网络规则(iptables/netfilter)对报文进行检查</p><p>3 协议栈规则检查后，符合要求的流量会从内核态进入到用户态，并进入指定监听端口的进程</p><p>4 处于用户态的用户进程接收到网络流量报文进行处理后，将处理后的结果再通过用户态返回给内核态的网络协议栈</p><p>5 网络协议栈检查报文，并将结果报文根据指定的网络策略通过网卡输送出去</p></blockquote><hr><h2 id="5-istio-入口流量分析"><a href="#5-istio-入口流量分析" class="headerlink" title="5 istio 入口流量分析"></a>5 istio 入口流量分析</h2><p>​    有了宏观和微观的网络流量流向分析之后，下一步就可以分析一下 istio 的入口流量了。因为涉及到 iptables 相关的知识，这里我仅仅把结论呈现给大家，具体 iptables 的使用如果大家有兴趣可以参考本人其他的博客轻松完爆。</p><p>​    在上面我们已经展示了 istio-init 容器在启动时就完成了网络空间协议栈规则的初始化，如下图：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173156740.png" srcset="/img/loading.gif" lazyload alt="image-20210911173156740"></p><p>​    现在可以通过 curl 访问 nginx pod。</p><blockquote><p>curl 10.244.10.80</p></blockquote><p>​    curl 后的入口流量进入 nginx pod 后的流转路径如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173207619.png" srcset="/img/loading.gif" lazyload alt="image-20210911173207619"></p><p>​    由上图可知，整个网络流向如下：</p><blockquote><p>1 因为匹配 iptables nat 表的 prerouting 链的第一条规则，因此网络流量被路由到 ISTIO_INBOUND 链</p><p>2 在 ISTIO_INBOUND 链一共有三条规则，因为访问的端口是 nginx 80，所以会匹配该链的第三条规则而将流量路由到 ISTIO_IN_REDIRECT 链</p><p>3 路由到 ISTIO_IN_REDIRECT 链的流量最终会从内核态打入到用户态监听端口为 15006 的进程</p></blockquote><p>​    端口 15006 的进程是什么呢？通过 netstat -ntlp 命令可知是 envoy 进程，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173220599.png" srcset="/img/loading.gif" lazyload alt="image-20210911173220599"></p><p>​    由此可知，当我们 curl nginx pod 时，虽然指定的目标访问端口为 80，但是网络协议栈规则仍然会将整个流量劫持送到 envoy 进程，由于  envoy 进程可以获取到入口流量，所以可以在此制定一系列的操作起到流控的目的。envoy 处理完后，流量会继续移动，流向路径如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173229115.png" srcset="/img/loading.gif" lazyload alt="image-20210911173229115"></p><p>​    由上图可知，整个网络流向如下：</p><blockquote><p>1 端口 15006 的进程处理完流量后，会将流量从用户态的进程传回内核态的网络协议栈，根据预先定义好的协议栈规则，流量会流经 output 链，output 链又会根据规则再把流量路由给 ISTIO_OUTPUT 链</p><p>2 因为 envoy 处理完流量最终要重新路由给 80 端口的 nginx 进程，因此处于 ISTIO_OUTPUT 链的第一条规则被匹配（因为  envoy 跟 nginx 在同一个网络命名空间，因此环回地址 lo 被匹配），此时流量会重新从内核态返回到用户态，并进入监听端口为 80 的  nginx 进程</p><p>3 nginx 处理完后，将结果通过 socket 连接返回给 envoy 进程（用户态）</p><p>4 envoy 再将流量通过 postrouting 链、网卡再将响应流量返回给用户</p></blockquote><hr><h2 id="6-istio-出口流量分析"><a href="#6-istio-出口流量分析" class="headerlink" title="6 istio 出口流量分析"></a>6 istio 出口流量分析</h2><p>​    上面介绍了 istio 入口请求流量流向分析，下面介绍一下 istio 出口流量流向分析，首先在 docker 容器内执行 curl 命令：</p><blockquote><p>curl <a href="http://www.baidu.com/">www.baidu.com</a></p></blockquote><p>​    下面截图展示出口流量的流向：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173241410.png" srcset="/img/loading.gif" lazyload alt="image-20210911173241410"></p><p>​    从图可知：</p><blockquote><p>1 出口流量首先会通过 iptables nat 表的 output 链进入到 istio_output 链</p><p>2 因为目的是 baidu，因此最终会匹配到 istio_redirect 链</p><p>3 istio_redirect 会将流量路由给端口 15001 的进程</p></blockquote><p>​    端口 15001 进程依旧是 envoy 进程，该端口处理的是 outbound 流量。如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173252400.png" srcset="/img/loading.gif" lazyload alt="image-20210911173252400"></p><p>​    由此可知，访问 baidu 前，流量依旧会被 envoy 劫持。处理完毕后，envoy 流量处理结果如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173302757.png" srcset="/img/loading.gif" lazyload alt="image-20210911173302757"></p><blockquote><p>1 envoy 将处理后的网络流量重新通过用户态进入到内核态的网络协议栈，流量会首先经过 OUTPUT 链</p><p>2 流经 OUTPUT 链的流量会进入 ISTIO_OUTPUT 链</p><p>3 流入到 ISTIO_OUTPUT 链的流量会匹配 owner UID match 1337 规则</p><p>4 流量最终会通过 POSTROUTING 链进入到网卡</p><p>5 从网卡随风而出</p></blockquote><hr><h2 id="7-小节"><a href="#7-小节" class="headerlink" title="7 小节"></a>7 小节</h2><p>​    本小节九析带你轻松完爆了 istio 注入 pod 后所导致的网络流量流向的改变。大家可以自己操作进行验证。这里告诉大家一个小窍门，如果想定位网络流量流向匹配  iptables 的哪条规则，可以通过观察 iptables 规则的 pkts、bytes 变化来确定。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - istio 注入</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-%E6%B3%A8%E5%85%A5/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 istio 注入与平台生态影响</p><p>  2.1 环境准备</p><p>  2.2 istio 注入操作</p><p>  2.3 istio 注入本质</p><p>  2.4 istio 注入 pod 后各容器作用以及关系</p><p>  2.5 istio-proxy 和 envoy 关系</p><p>  2.6 istio-proxy 和 kube-proxy 关系</p><p>  2.7 envoy 进程服务端口</p><p>3 小节</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911171710644.png" srcset="/img/loading.gif" lazyload alt="image-20210911171710644"></p><hr><h2 id="2-istio-注入与平台生态影响"><a href="#2-istio-注入与平台生态影响" class="headerlink" title="2 istio 注入与平台生态影响"></a>2 istio 注入与平台生态影响</h2><p>​    虽然 istio 是平台间独立的，不仅支持 K8s、Consul，也同样支持虚拟机，但是本文部署平台环境还是聚焦在 k8s。</p><h3 id="2-1-环境准备"><a href="#2-1-环境准备" class="headerlink" title="2.1 环境准备"></a>2.1 环境准备</h3><p>​    在本系列文章的第二篇中提到过资源的 istio 注入，这里再做一个回顾。</p><p>​    新建 jiuxi 命名空间：</p><blockquote><p>kubectl create ns jiuxi</p></blockquote><p>​    编写 nginx deployment 资源文件 nginx-deploy.yaml：</p><blockquote><p>apiVersion: apps/v1</p><p>kind: Deployment</p><p>metadata:</p><p>  name: nginx</p><p>  namespace: jiuxi</p><p>  labels:</p><p>  app: nginx</p><p>spec:</p><p>  replicas: 1</p><p>  selector:</p><p>​    matchLabels:</p><p>​      app: nginx</p><p>  template:</p><p>​    metadata:</p><p>​      labels:</p><p>​        app: nginx</p><p>​    spec:</p><p>​      containers:</p><p>​      -  name: nginx</p><p>​        image: nginx:1.14-alpine</p><p>​        ports:</p><p>​        - containerPort: 80</p></blockquote><p>​    新建 nginx deployment 资源：</p><blockquote><p>kubectl apply -f nginx-deploy.yaml</p></blockquote><p>​    创建成功后的截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911171726710.png" srcset="/img/loading.gif" lazyload alt="image-20210911171726710"></p><h3 id="2-2-istio-注入操作"><a href="#2-2-istio-注入操作" class="headerlink" title="2.2 istio 注入操作"></a>2.2 istio 注入操作</h3><p>​    执行 istio 注入操作之前，须确保 istio 和 istioctl 都正确安装，安装操作请参阅《<a href="https://blog.51cto.com/14625168/2474224"> 第一章</a>》。</p><p>​    手动执行 istio 注入操作：</p><blockquote><p>istioctl kube-inject -f nginx-deploy.yaml | kubectl apply -f -</p></blockquote><p>​    执行成功之后截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911171737004.png" srcset="/img/loading.gif" lazyload alt="image-20210911171737004"></p><p>​    此时 nginx pod 内部容器从原来的 1 个变成了 2 个（严格意义上应该是 3 个，因为有个启动容器执行完就结束了，因此这里看不到，后面会细说）。</p><h3 id="2-3-istio-注入本质"><a href="#2-3-istio-注入本质" class="headerlink" title="2.3 istio 注入本质"></a>2.3 istio 注入本质</h3><p>​    我们再审视一下 istio 注入过程：</p><blockquote><p>istioctl kube-inject -f nginx-deploy.yaml | kubectl apply -f -</p></blockquote><p>​    该命令通过管道符 “|” 将两步操作合为一步，”|” 前在 nginx-deploy.yaml 资源文件注入 istio 内容，”|” 后部署经过 istio 注入的新的 nginx-deploy.yaml 文件。</p><p>​    那么 istio 到底注入了哪些内容呢？执行如下命令查看：</p><blockquote><p>kubectl edit deployment -n jiuxi nginx</p></blockquote><p>​    发现在原来基础上增加了一个初始化容器（initContainers）：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911171748249.png" srcset="/img/loading.gif" lazyload alt="image-20210911171748249"></p><p>​    <img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911171800364.png" srcset="/img/loading.gif" lazyload></p><p>又增加了一个 istio-proxy 容器：</p><p>还有一些环境变量信息，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911171857892.png" srcset="/img/loading.gif" lazyload alt="image-20210911171857892"></p><p>​    由此可知，istio 注入本质就是在宿主资源中添加 istio 特性，从而起到提高整个平台的能力。类似克拉克加了披风变成超人，布洛克吸附外星物质变成毒液一样的道理。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911171911243.png" srcset="/img/loading.gif" lazyload alt="image-20210911171911243"></p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911171923945.png" srcset="/img/loading.gif" lazyload alt="image-20210911171923945"></p><p>​    下图展示了 istio 在 nginx pod 中注入新容器 istio-init、istio-proxy：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911171936581.png" srcset="/img/loading.gif" lazyload alt="image-20210911171936581"></p><h3 id="2-4-istio-注入-pod-后各容器作用以及关系"><a href="#2-4-istio-注入-pod-后各容器作用以及关系" class="headerlink" title="2.4 istio 注入 pod 后各容器作用以及关系"></a>2.4 istio 注入 pod 后各容器作用以及关系</h3><p>​    上图演示了 pod 在 istio 注入后产生了 2 个新的容器，这样原来单容器的 pod 现在变成了 3 个容器共存同一个 pod 中，而且宿主容器（nginx）跟 istio-proxy 容器还处于同一网络空间。</p><blockquote><p>istio-init: 初始化容器。作用是初始化 pod 网络空间，创建 iptables 规则。</p><p>istio-proxy: sidecar 容器。作用是启动 pilot-agent 和 envoy 进程。</p></blockquote><p>​    可以通过 kubectl exec -it 命令进入 nginx pod 的 nginx 和 istio-proxy 容器，发现两个容器共享同一网络空间。如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911171953779.png" srcset="/img/loading.gif" lazyload alt="image-20210911171953779"></p><h3 id="2-5-istio-proxy-和-envoy-关系"><a href="#2-5-istio-proxy-和-envoy-关系" class="headerlink" title="2.5 istio-proxy 和 envoy 关系"></a>2.5 istio-proxy 和 envoy 关系</h3><p>​    envoy 其实本质与 nginx 和 haproxy 一样，都属于网络代理服务器，运行时则是一个进程。envoy 在架构设计上也采用了类似 nginx 的设计模式（多线程、非阻塞、异步IO），后面的课程我会详细讲解。</p><p>​    istio-proxy 是运行在 pod 中的一个容器。该容器运行时会启动两个关键的进程 pilot-agent 和 envoy。pilot-agent 进程会定时跟 istio 的 pilot 组件进行通信，envoy 进程会接收入口和出口网络流量。istio-proxy 容器内的进程如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911172004111.png" srcset="/img/loading.gif" lazyload alt="image-20210911172004111"></p><h3 id="2-6-istio-proxy-和-kube-proxy-关系"><a href="#2-6-istio-proxy-和-kube-proxy-关系" class="headerlink" title="2.6 istio-proxy 和 kube-proxy 关系"></a>2.6 istio-proxy 和 kube-proxy 关系</h3><p>​    从表现形式上说，istio-proxy 是容器(运行在 pod 内)，kube-proxy 是 pod (资源类型是 daemonset)。</p><p>​    从处理网络流量角度来说，istio-proxy 和 kube-proxy 本质上都是通过 iptables/netfilter 来处理网络流量。只不过 istio-proxy 和  kube-proxy 活动在不同的网络空间。istio-proxy 位于 pod 网络空间，处理的是 pod 内的网络流量，而  kube-proxy 位于宿主机网络空间，处理的是宿主机内网络流量（因为 kube-proxy 是 daemonset，因此它位于 k8s  集群的每个 node 节点上）。</p><h3 id="2-7-envoy-进程服务端口"><a href="#2-7-envoy-进程服务端口" class="headerlink" title="2.7 envoy 进程服务端口"></a>2.7 envoy 进程服务端口</h3><p>​    上面我们介绍了 envoy 是运行在 istio-proxy 容器内的一个进程，改进程的作用是管理网络流量（类比 nginx），下图展示 envoy  进程开启的网络端口，网络流量可以通过端口进入到 envoy 进程内部。网络流量、网络端口和 envoy  进程的关系就像风、窗户和房屋的关系一样，风（网络流量）通过窗口（网络端口）进入到房屋（envoy），一个房屋（envoy）可以不止一个窗户（网络端口）。</p><p>​    下图展示 envoy 进程监听的端口号：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911172014710.png" srcset="/img/loading.gif" lazyload alt="image-20210911172014710"></p><p>​    服务端口作用截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911172033996.png" srcset="/img/loading.gif" lazyload alt="image-20210911172033996"></p><hr><h2 id="3-小节"><a href="#3-小节" class="headerlink" title="3 小节"></a>3 小节</h2><p>​    自此，九析带你轻松完爆了 istio 的注入以及对平台生态的影响。下章节将继续介绍 istio 注入后对网络流量的流向的改变。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - istio 今生篇</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-%E4%BB%8A%E7%94%9F%E7%AF%87/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-%E4%BB%8A%E7%94%9F%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 何为服务网格（service mesh）</p><p>3 何为 istio</p><p>4 为什么使用 istio</p><p>5 istio 核心特征</p><p>  5.1 traffic management</p><p>  5.2 secure</p><p>  5.3 policies</p><p>  5.4 observability</p><p>6 多平台支持</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911171103398.png" srcset="/img/loading.gif" lazyload alt="image-20210911171103398"></p><p>​    上章介绍了 istio 前世，讲述了微服务架构模型的演变史，也讲了微服务今天所遭遇的问题和面临的尴尬窘境，这里我们再复习一下。</p><p>   目前微服务治理遭遇的问题：</p><blockquote><p><strong>服务治理方式不统一</strong>：不同服务治理的方式会引入不同的中间件，而这些中间件的技术标准和维护标准都不同。因此运维人员或者架构人员必须掌握每种中间件的使用方法，很多时候这对一个人力资源有限的科技公司并不现实。</p><p><strong>重复造轮子</strong>：微服务架构是允许多语言栈、多技术栈的，但不同的技术栈针对通信、支撑服务、服务安全、服务监控、熔断/降级/限流等通用技术问题却需要各自的解决方案，实在是成本的浪费。</p><p><strong>服务治理缺乏标准化</strong>：由于服务治理缺乏标准化，因此微服务治理的好坏全依靠技术人员个人的能力、经验和水平，这就有点像手工作坊时代，器物优质全靠工匠。但是无标准化显然不符合科技发展的轨迹。</p></blockquote><p>​    为了解决上面微服务治理中的痛点，大家普遍的诉求在于能不能有这么一个平台，既可以无侵入、透明、用户无感知的插入到现有的分布式微服务架构中，同时又可以解决一些通信所必须考虑的普遍问题（服务发现、负载均衡、超时重试、熔断/限流、监控、访问控制、认证授权等），将这些问题的解决方案统一下沉到平台层，而不再依靠引入第三方中间件（zookeeper、nginx、sentinal、hystrix、pinpoint/zipkin、spring security），并且所有的维护方式统一且标准化。</p><p>​    于是服务网格出现了，istio 也出现了，而且一切出现得都是这么自然。</p><blockquote><p>《圣经》旧约-创世纪篇：</p><p>原始太初，上帝创造了天地。地面一片空虚混沌，渊面黑暗，只有上帝的灵运行在水面上。上帝说：“要有光！”于是，就有了光。上帝把光和暗分开，把光称为白昼，把暗称为黑夜。夜晚过去后,清晨接着来临，这是第一天。</p><p>上帝说：“诸水之间要有穹苍，将水分为上下。”于是创造了穹苍，把水上下分开。他称穹苍为“天空”。夜晚过去，清晨接着来临，这是第二天。</p><p>……</p></blockquote><p>​    那么服务网格是什么？istio 又是什么呢？</p><hr><h2 id="2-何为服务网格（service-mesh）"><a href="#2-何为服务网格（service-mesh）" class="headerlink" title="2 何为服务网格（service mesh）"></a>2 何为服务网格（service mesh）</h2><p>​    下面看看 istio 是怎么描述服务网格的：</p><blockquote><p>The term service mesh is used to describe the network of microservices that make up such applications and the interactions between them. As a  service mesh grows in size and complexity, it can become harder to  understand and manage. Its requirements can include discovery, load  balancing, failure recovery, metrics, and monitoring. A service mesh  also often has more complex operational requirements, like A/B testing,  canary rollouts, rate limiting, access control, and end-to-end  authentication.</p></blockquote><p>​    个人翻译如下：</p><blockquote><p>服务网格是对微服务组成的一个可以互相通信的网络进行治理的规范。随着微服务的增长，服务网格也会变得越来越复杂和难以理解。服务网格治理的内容除了服务发现、负载均衡、失败恢复、指标收集、监控之外，还应该具有更复杂的运维要求，比如 A/B 测试、金丝雀发布、流量限制、访问控制和端到端认证。</p></blockquote><h2 id="3-何为-istio"><a href="#3-何为-istio" class="headerlink" title="3 何为 istio"></a>3 何为 istio</h2><p>​    上面介绍了服务网格，下面再来介绍一下 istio，仍然引用 istio 官网的定义：</p><blockquote><p>Cloud platforms provide a wealth of benefits for the organizations that use  them. However, there’s no denying that adopting the cloud can put  strains on DevOps teams. Developers must use microservices to architect  for portability, meanwhile operators are managing extremely large hybrid and multi-cloud deployments. Istio lets you connect, secure, control,  and observe services.</p><p>At a high level, Istio helps  reduce the complexity of these deployments, and eases the strain on your development teams. It is a completely open source service mesh that  layers transparently onto existing distributed applications. It is also a platform, including APIs that let it integrate into any logging  platform, or telemetry or policy system. Istio’s diverse feature set  lets you successfully, and efficiently, run a distributed microservice  architecture, and provides a uniform way to secure, connect, and monitor microservices.</p></blockquote><p>​    个人感觉介绍很啰嗦，建议你也别看了，我给你简单列举一下重点即可：</p><blockquote><p>istio 是 service mesh 的具体解决方案。她就像一个尤物，不仅能满足服务网格规定的一切苛刻要求之外，还贴心地为你准备了一整套标准化、规格化的豪华级国际服务，等待着你的抽插。更难能可贵地是，拥有这么多优秀品质的她，竟然还是免费的！爽不爽！</p></blockquote><h2 id="4-为什么使用-istio"><a href="#4-为什么使用-istio" class="headerlink" title="4 为什么使用 istio"></a>4 为什么使用 istio</h2><p>​    下面是你选择 istio 的一些理由：</p><blockquote><p>1 对 HTTP、gRPC、WebSocket 和 TCP 网络流量的自动负载均衡</p><p>2 通过丰富多样的路由规则、重试、故障转移和故障注入机制实现对流量行为进行细粒度控制</p><p>3 通过可插拔的策略层（联想成过滤器）和 API 实现对访问的控制、流量以及资源配额的限制</p><p>4 集群入口、集群内部、集群出口所有网络流量的全方位跟踪、记录和度量</p><p>5 保证服务之间通信的安全性</p></blockquote><h2 id="5-istio-核心特征"><a href="#5-istio-核心特征" class="headerlink" title="5 istio 核心特征"></a>5 istio 核心特征</h2><p>​    istio 官方宣扬的特性是 traffic management（流控）、secure（安全）、polices（策略）、observability（可观察）。个人感觉这样的叙述太佶屈聱牙，一点都不口语化。</p><h3 id="5-1-traffic-management"><a href="#5-1-traffic-management" class="headerlink" title="5.1 traffic management"></a>5.1 traffic management</h3><p>​    这个好理解，本质就是网络流量的管理。就像早晚高峰车辆限行，以及交警在发生交通事故疏导新路，这些都是在做流量的控制和路由。</p><p>​    其实流量管理并不是服务网格化才出现的，早期的微服务时代就已经有流量控制了，比如负载均衡、熔断、限流、降级等，只不过早期这些功能的实现依赖中间件（比如 nginx、hystrix），如今服务网格时代，这些功能统一下沉到基础平台 istio 去实现了。</p><p>​    istio 的流控主要是通过 Envoy 组件实现。有关技术细节，哥以后会专门告诉你。</p><h3 id="5-2-secure"><a href="#5-2-secure" class="headerlink" title="5.2 secure"></a>5.2 secure</h3><p>​    说到 istio 的 secure 其实是有个范围的。这里的 secure 并不是没有边界，它主要是指微服务之间通信的 secure，即 pod 对 pod、service 对 service 层面通信的 secure。众所周知，istio 是 google、ibm 以及 lyft 公司  3p 后的产物。而 istio 的 secure 正是脱胎于 google 的 ALTS（应用层传输安全）这项技术，该项技术用于验证  google 服务之间的通信，保证传输中数据的安全，即应用层服务到服务通信的防护方式。这些功能早先在微服务时代对标就是 jwt、oauth2  等技术规范。</p><p>​    istio secure 主要的功能有 ACLS（访问控制）、authentication（认证，即证明你是谁）、authorization（授权，即允许你干啥）。</p><p>​    istio secure 功能通过 Citadel 这个组件实现。有关技术细节，哥以后会专门告诉你。</p><h3 id="5-3-policies"><a href="#5-3-policies" class="headerlink" title="5.3 policies"></a>5.3 policies</h3><p>​    istio policies 职责如下：</p><blockquote><p>1 动态限制服务通信的网络速率</p><p>2 限制访问服务、设置黑、白名单</p><p>3 网络包头信息的重写或者重定向</p></blockquote><p>​    不仅如此，istio 也允许添加自定义策略，通过 istio 提供的 policy adapter 跟 istio 集成在一起。</p><p>​    注意不要将 policies 跟 secure 进行混淆，policies 更多是人为进行干预控制，而 secure 重点在于安全。</p><p>​    istio policies 功能实现是通过 mixer 组件实现的。有关技术细节，哥以后会专门告诉你。</p><h3 id="5-4-observability"><a href="#5-4-observability" class="headerlink" title="5.4 observability"></a>5.4 observability</h3><p>​    observability 特性是指提供给你多种工具实现全方位、立体式对集群入口、集群内部、集群出口的流量进行监控、跟踪和度量。微服务早期时代监控方式是 agent 或者中间件，比如：zabbix、pinpoint、zipkin 等。</p><p>​    istio observability 功能实现是通过 mixer 组件实现的。还是老样子，有关技术细节，哥以后会专门告诉你。</p><h2 id="6-多平台支持"><a href="#6-多平台支持" class="headerlink" title="6 多平台支持"></a>6 多平台支持</h2><p>​    istio 可以支持多平台，比如 k8s、Consul、Mesos 以及独立虚拟机。</p><p>​    以后哥都会实际为你展示，你唯一做的就是耐心等待和持续尖叫。</p><p>​    自此，九析带你轻松完爆 istio 的介绍。更多精彩，敬请期待。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - istio 前世</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-%E5%89%8D%E4%B8%96/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-%E5%89%8D%E4%B8%96/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 架构演变史</p><p>  2.1 单体架构</p><p>  2.2 垂直架构</p><p>  2.3 微服务架构</p><p>3 微服务架构模型演进史</p><p>  3.1 框架与通信</p><p>  3.2 运行时的支撑服务</p><p>  3.3 服务安全</p><p>  3.4 服务监控和告警</p><p>  3.5 服务部署</p><p>  3.6 底层服务</p><p>  3.7 服务防护</p><p>  3.8 全链路压测</p><p>4 微服务架构模型全景图</p><p>5 带来的问题</p><p>  5.1 服务治理方式不统一</p><p>  5.2 重复造轮子</p><p>  5.3 服务治理缺乏标准化</p><p>6 总结</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    介绍 istio 之前，要先讲微服务，因为 istio 是在微服务技术体系上发展起来的。当你对微服务的技术体系有了一定把握之后，回过头再来理解 istio，你就会感觉技术果然是一路传承向前发展的。</p><blockquote><p>历史总会反复，但科技永远向前。</p></blockquote><p>​    本文很多内容来自我在多个公司的技术分享后的 ppt 截图，如果你对此 ppt 感兴趣，可以向我索要。</p><hr><h2 id="2-架构演变史"><a href="#2-架构演变史" class="headerlink" title="2 架构演变史"></a>2 架构演变史</h2><h3 id="2-1-单体架构"><a href="#2-1-单体架构" class="headerlink" title="2.1 单体架构"></a>2.1 单体架构</h3><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911170031961.png" srcset="/img/loading.gif" lazyload alt="image-20210911170031961"></p><blockquote><p>特点：</p><p>1 所有功能集成在一个项目工程中</p><p>2 所有功能打包在一个 web 包部署到服务器</p><p>3 应用跟数据库分开部署</p><p>4 通过部署应用集群和数据库集群来提高系统性能</p><p>优点：</p><p>架构简单，前期开发成本低，周期短。小型项目首选。</p><p>缺点:</p><p>1 全部功能集成在一个工程中，对于大型项目不易开发、扩展和维护</p><p>2 系统性能扩展只能通过扩展集群，成本高</p><p>3 技术栈受限</p></blockquote><h3 id="2-2-垂直架构"><a href="#2-2-垂直架构" class="headerlink" title="2.2 垂直架构"></a>2.2 垂直架构</h3><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911170047249.png" srcset="/img/loading.gif" lazyload alt="image-20210911170047249"></p><blockquote><p>特点：</p><p>当访问量逐渐增大，单一应用增加机器带来的性价比越来越小，将应用拆成互不相关的几个应用，以提升效率。</p><p>优点：</p><p>1 相关架构简单，前期开发成本低，周期短，小型项目的首选</p><p>2 通过垂直拆分，原来的单体不至于无限扩大</p><p>3 不同的项目可采用不同的技术栈</p><p>缺点：</p><p>1 同业务域功能集成在一个工程中，对于大型项目不易开发、扩展和维护成本高</p><p>2 系统性能扩展只能通过扩展集群，成本高，有瓶颈</p><p>3 单体之间的函数调用过度到系统之间的 rpc 或者 http 调用，服务发现需要单独机制保证</p></blockquote><h3 id="2-3-微服务架构"><a href="#2-3-微服务架构" class="headerlink" title="2.3 微服务架构"></a>2.3 微服务架构</h3><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911170101322.png" srcset="/img/loading.gif" lazyload alt="image-20210911170101322"></p><blockquote><p>特点：</p><p>1 将系统服务层完全独立出来，并将服务层抽取为一个个微服务</p><p>2 微服务遵循单一原则</p><p>3 微服务之间采用 RESTful轻量级协议进行传输</p><p>优点：</p><p>1 服务拆分粒度更细，有利于资源重复利用，提高开发效率</p><p>2 可以更加精准指定每个服务的优化方案，提高系统的可维护性</p><p>3 微服务架构采用去中心化思想，服务之间采用 RESTful 等轻量级协议通信，相比 ESB 更轻</p><p>4 适合互联网产品，产品迭代更加快速和便捷</p><p>缺点：</p><p>1 微服务过多，服务治理成本高，不利于系统维护</p><p>2 分布式系统开发的技术成本高（容错、分布式事务等），对团队技术挑战大</p></blockquote><hr><h2 id="3-微服务架构模型演进史"><a href="#3-微服务架构模型演进史" class="headerlink" title="3 微服务架构模型演进史"></a>3 微服务架构模型演进史</h2><p>​    微服务架构的模型也是一个从简单到复杂的演进过程。</p><h3 id="3-1-框架与通信"><a href="#3-1-框架与通信" class="headerlink" title="3.1 框架与通信"></a>3.1 框架与通信</h3><p>​    微服务架构初期，主要的技术诉求是寻找更简单和轻量的开发框架，不同的开发框架意味着采用不同的通信协议。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911170123931.png" srcset="/img/loading.gif" lazyload alt="image-20210911170123931"></p><h3 id="3-2-运行时的支撑服务"><a href="#3-2-运行时的支撑服务" class="headerlink" title="3.2 运行时的支撑服务"></a>3.2 运行时的支撑服务</h3><p>​    当服务的编写和通信解决了之后，接下来就要考虑一些运行时的支撑服务了。这些服务跟业务去耦，属于基础层的支撑服务，比如网关、负载均衡、服务注册与发现、配置中心等。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911170145110.png" srcset="/img/loading.gif" lazyload alt="image-20210911170145110"></p><h3 id="3-3-服务安全"><a href="#3-3-服务安全" class="headerlink" title="3.3 服务安全"></a>3.3 服务安全</h3><p>​    解决了服务的通信以及基础支撑后，大体上业务就可以开展了。但是这样裸奔的服务是有很大安全风险的，很多敏感的信息在不经过认证和授权就可以轻易获取到，因此服务安全就加入到了微服务的模型体系中。服务安全主要有两种，分别是 jwt 和 oauth2。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911170159703.png" srcset="/img/loading.gif" lazyload alt="image-20210911170159704"></p><h3 id="3-4-服务监控和告警"><a href="#3-4-服务监控和告警" class="headerlink" title="3.4 服务监控和告警"></a>3.4 服务监控和告警</h3><p>​    服务在解决了通信、支撑和安全之后，就可以愉快地展开工作了。但就跟判断健康需要做体检一样，判断在线服务是否健康就需要监控和遥测，当工作负载超过了阈值就要告警通知人为介入。服务的监控有很多的维度，常见地有系统指标监控、业务指标监控、服务健康检查、调用链监控、日志监控等。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911170231781.png" srcset="/img/loading.gif" lazyload alt="image-20210911170231781"></p><h3 id="3-5-服务部署"><a href="#3-5-服务部署" class="headerlink" title="3.5 服务部署"></a>3.5 服务部署</h3><p>​    容器化时代带来了新的运维思路，原有基于虚拟机、物理机的重运维开始向基于容器以及容器编排的轻运维转换，这种转换也带来了服务部署方式的改变。更快、更好、更有效的部署成为微服务架构模型新的挑战。</p><p>​    服务部署需要解决的问题有发布机制的引入、镜像治理、容器治理、卷管理、CI/CD 等方面。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911170305561.png" srcset="/img/loading.gif" lazyload alt="image-20210911170305561"></p><h3 id="3-6-底层服务"><a href="#3-6-底层服务" class="headerlink" title="3.6 底层服务"></a>3.6 底层服务</h3><p>​    当业务范围越来越广，再大的公司也不可能解决任何技术问题，这时就需要引入一些业界优秀的第三方服务作为底层服务来解决特定问题。有时这些第三方服务并不可能完全适合自己的架构，因此就需要做适当的剪裁。尽管如此，这些第三方服务也构成了整个微服务架构模型中不可或缺的一部分。常用的第三方底层服务有分布式消息中间件、分布式数据访问、分布式任务调度和分布式缓存等。底层服务跟基础支撑服务的区别在于前者更多在业务问题域，而后者则主要是通用问题域。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911170327813.png" srcset="/img/loading.gif" lazyload alt="image-20210911170327813"></p><h3 id="3-7-服务防护"><a href="#3-7-服务防护" class="headerlink" title="3.7 服务防护"></a>3.7 服务防护</h3><p>​    就像胃口再好的人也不可能一次吃下整头大象一样，编写再好的服务也不可能支持无限的请求。技术人员在处理无限、不可期技术场景的技术方案时，经常的策略是以不变应万变：根据目前的服务负载设置峰值，超过峰值就进行熔断、限流等措施。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911170345259.png" srcset="/img/loading.gif" lazyload alt="image-20210911170345259"></p><p>​    熔断如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911170426093.png" srcset="/img/loading.gif" lazyload alt="image-20210911170426093"></p><p>​    降级如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911170435845.png" srcset="/img/loading.gif" lazyload alt="image-20210911170435845"></p><p>​    限流如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911170444859.png" srcset="/img/loading.gif" lazyload alt="image-20210911170444859"></p><h3 id="3-8-全链路压测"><a href="#3-8-全链路压测" class="headerlink" title="3.8 全链路压测"></a>3.8 全链路压测</h3><p>​    在上面的介绍中，我们介绍了微服务架构模型的各个维度。本来可以在这里结束，但是想想实在不妥，因为我们缺少了很关键的一环，那便是测试。</p><p>​    全链路压测是稍具规模的科技公司都必须要做的工作之一。它的重要性不言而喻，当业务发展超出预期，系统要具有先知先觉的能力以抵御洪灾。毕竟未雨绸缪总好过亡羊补牢。全链路压测是一个大的话题，因为这里介绍的是 istio，故这里一笔带过，有关 ppt 详情我也照顾篇幅不再赘述，如果有朋友对此感兴趣，可以向我索要。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911170456807.png" srcset="/img/loading.gif" lazyload alt="image-20210911170456807"></p><hr><h2 id="4-微服务架构模型全景图"><a href="#4-微服务架构模型全景图" class="headerlink" title="4 微服务架构模型全景图"></a>4 微服务架构模型全景图</h2><p>​    下图展示了整个微服务架构模型：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911170507833.png" srcset="/img/loading.gif" lazyload alt="image-20210911170507833"></p><hr><h2 id="5-带来的问题"><a href="#5-带来的问题" class="headerlink" title="5 带来的问题"></a>5 带来的问题</h2><p>​    微服务架构的引入带来了很多好处，但同时也带来了服务治理诸多的问题。核心问题如下：</p><h3 id="5-1-服务治理方式不统一"><a href="#5-1-服务治理方式不统一" class="headerlink" title="5.1 服务治理方式不统一"></a>5.1 服务治理方式不统一</h3><p>​    不同服务治理的方式会引入不同的中间件，而这些中间件的技术标准和维护标准都不同。因此运维人员或者架构人员必须掌握每种中间件的使用方法，很多时候这对一个人力资源有限的科技公司并不现实。</p><h3 id="5-2-重复造轮子"><a href="#5-2-重复造轮子" class="headerlink" title="5.2 重复造轮子"></a>5.2 重复造轮子</h3><p>​    微服务架构是允许多语言栈、多技术栈的，但不同的技术栈针对通信、支撑服务、服务安全、服务监控、熔断/降级/限流等通用技术问题却需要各自的解决方案，实在是成本的浪费。</p><h3 id="5-3-服务治理缺乏标准化"><a href="#5-3-服务治理缺乏标准化" class="headerlink" title="5.3 服务治理缺乏标准化"></a>5.3 服务治理缺乏标准化</h3><p>​    由于服务治理缺乏标准化，因此微服务治理的好坏全依靠技术人员个人的能力、经验和水平，这就有点像手工作坊时代，器物优质全靠工匠。但是无标准化显然不符合科技发展的轨迹。</p><hr><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h2><p>​    微服务发展目前已经趋于稳定，并成为了技术主流，但与此同时它的处境却越来越尴尬，暴露的问题也越来越尖锐。幸运的是，服务网格时代到来了，服务网格的领军 istio 正稳步进入历史舞台，并变得越来越炙手可热。下文九析将继续带你轻松完爆 istio。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - istio Gateway 设置路由</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-Gateway-%E8%AE%BE%E7%BD%AE%E8%B7%AF%E7%94%B1/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-Gateway-%E8%AE%BE%E7%BD%AE%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<p>1 流量管理</p><p>2 创建命名空间</p><p>3 资源文件准备</p><p>  3.1 创建网关文件</p><p>  3.2 创建虚拟服务文件</p><p>  3.3 创建 k8s service 文件</p><p>  3.4 创建 k8s deployment 文件：</p><p>  3.5 修改 istio-ingressgateway deployment</p><p>4 尝试网关路由功能</p><p>  4.1 确定 INGRESS_HOST</p><p>  4.2 编辑浏览器所在主机 hosts 文件</p><p>  4.3 访问 tomcat</p><p>5 小节</p><hr><h2 id="1-流量管理（traffic-management）"><a href="#1-流量管理（traffic-management）" class="headerlink" title="1 流量管理（traffic management）"></a>1 流量管理（traffic management）</h2><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911165314268.png" srcset="/img/loading.gif" lazyload alt="image-20210911165314268"></p><p>​    istio 四大特性是流量管理（traffic management）、安全（security）、策略（policies）和遥测（observability）。</p><p>​    本节重点介绍 istio 流量管理。流量管理的本质是对网络流量的路由和控制。生活中经常有这样的例子，比如下雨塌方，交警会疏导新的交通路线，这便是路由；比如景区周末实行单双号限行，这便是流量控制。</p><p>​    在介绍流量管理之前，首先介绍一下网络流向，介绍一个 http 请求在安装了 istio 的 k8s 中都经过哪些点，有了这个介绍之后，再谈流量管理将是水到渠成的事情。</p><p>​    下图便是网络流向图：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911165357073.png" srcset="/img/loading.gif" lazyload alt="image-20210911165357073"></p><p>​    当用户使用浏览器发起一个请求( <a href="http://jiuxi.com/xxx">http://jiuxi.com/xxx</a> )进入 k8s 中的 istio-ingressgateway，因为在  istio-ingressgateway 上设置了 istio 的 gateway，而且此 gateway 又绑定了 virtual  service，在 virtual service 设置了 2 条路由规则，分别指向 tomcat 和 nginx 这 2 个 k8s  service，而每个 service 又关联到各自的 pod，于是此请求最终可根据 url 触达到 pod 内的容器。</p><p>​    了解了请求流向的整个流程，下面介绍如何操作。前提是你已经安装好了 k8s 和 istio。关于如何安装和配置 istio，可以查看本人的系列文章第一章。</p><hr><h2 id="2-创建命名空间"><a href="#2-创建命名空间" class="headerlink" title="2 创建命名空间"></a>2 创建命名空间</h2><blockquote><p>kubectl create ns jiuxi</p></blockquote><p>​    istio 默认安装在 jiuxi 这个命名空间下，并且设置在 jiuxi 命名空间自动注入 sidecar。相关操作请参考本人系列文章的第一章。</p><hr><h2 id="3-资源文件准备"><a href="#3-资源文件准备" class="headerlink" title="3 资源文件准备"></a>3 资源文件准备</h2><p>​    从上图可知，共需要 4 个资源文件（yaml）：</p><blockquote><p>1 jiuxi-gateway.yaml</p><p>2 jiuxi-virtual-svc.yaml</p><p>3 jiuxi-svc.yaml( tomcat 和 nginx 的 service 写在一个文件）</p><p>4 jiuxi-deploy.yaml（tomcat 和 nginx 的 deployment 写在一个文件）</p></blockquote><h3 id="3-1-创建网关文件"><a href="#3-1-创建网关文件" class="headerlink" title="3.1 创建网关文件"></a>3.1 创建网关文件</h3><p>​    网关文件 jiuxi-gateway.yaml 文件内容如下：</p><blockquote><p>apiVersion: networking.istio.io/v1alpha3</p><p>kind: Gateway</p><p>metadata:</p><p>  name: jiuxi-gateway</p><p>  namespace: jiuxi</p><p>spec:</p><p>  selector:</p><p>​    istio: ingressgateway</p><p>servers:</p><p>- hosts:</p><p>  - jiuxi.com</p><p>  port:</p><p>​    number: 80</p><p>​    name: http</p><p>​    protocol: HTTP</p></blockquote><p>​    创建资源：</p><blockquote><p>kubectl apply -f jiuxi-gateway.yaml</p></blockquote><h3 id="3-2-创建虚拟服务文件"><a href="#3-2-创建虚拟服务文件" class="headerlink" title="3.2 创建虚拟服务文件"></a>3.2 创建虚拟服务文件</h3><p>​    虚拟服务文件 jiuxi-virtual-svc.yaml 文件内容如下：</p><blockquote><p>apiVersion: networking.istio.io/v1alpha3</p><p>kind: VirtualService</p><p>metadata:</p><p>  name: jiuxi-virtual-svc</p><p>  namespace: jiuxi</p><p>spec:</p><p>  gateways:</p><p>  - jiuxi-gateway</p><p>  hosts:</p><p>  - jiuxi.com</p><p>  http:</p><p>  - route:</p><p>​    - destination:</p><p>​       host: tomcat-svc</p><p>​       port:</p><p>​         number: 8080</p><p>​    weight: 50</p><p>​    - destination:</p><p>​       host: nginx-svc</p><p>​       port:</p><p>​         number: 80</p><p>​    weight: 50</p></blockquote><p>​    创建资源：</p><blockquote><p>kubectl apply -f jiuxi-virtual-svc.yaml</p></blockquote><h3 id="3-3-创建-k8s-service-文件"><a href="#3-3-创建-k8s-service-文件" class="headerlink" title="3.3 创建 k8s service 文件"></a>3.3 创建 k8s service 文件</h3><p>​    服务文件 jiuxi-svc.yaml 文件内容如下：</p><blockquote><p>apiVersion: v1</p><p>kind: Service</p><p>metadata:</p><p>  name: nginx-svc</p><p>  namespace: jiuxi</p><p>spec:</p><p>  ports:</p><p>  - name: port</p><p>​    port: 80</p><p>​    protocol: TCP</p><p>​    targetPort: 80</p><p>   selector:</p><p>​    app: nginx-pod</p><p>-–</p><p>apiVersion: v1</p><p>kind: Service</p><p>metadata:</p><p>  name: tomcat-svc</p><p>  namespace: jiuxi</p><p>spec:</p><p>  ports:</p><p>  - name: port</p><p>​    port: 8080</p><p>​    protocol: TCP</p><p>​    targetPort: 8080</p><p>  selector:</p><p>  app: tomcat-pod</p></blockquote><p>​    创建资源：</p><blockquote><p>kubectl apply -f jiuxi-svc.yaml</p></blockquote><h3 id="3-4-创建-k8s-deployment-文件"><a href="#3-4-创建-k8s-deployment-文件" class="headerlink" title="3.4 创建 k8s deployment 文件"></a>3.4 创建 k8s deployment 文件</h3><p>​    jiuxi-deploy 文件内容如下：</p><blockquote><p>apiVersion: apps/v1 </p><p>kind: Deployment </p><p>metadata: </p><p>  labels: </p><p>  app: nginx-deploy </p><p>  name: nginx-deploy </p><p>  namespace: jiuxi </p><p>spec: </p><p>  replicas: 1 </p><p>  selector: </p><p>​    matchLabels: </p><p>​      app: nginx-pod  </p><p>  template: </p><p>​    metadata: </p><p>​      labels: </p><p>​        app: nginx-pod  </p><p>​    spec: </p><p>​      containers:     </p><p>​      - image: nginx:1.14-alpine </p><p>​        imagePullPolicy: Always </p><p>​        name: nginx </p><p>​        ports: </p><p>​        - containerPort: 80 </p><p>​          name: port </p><p>​          protocol: TCP</p><p> —</p><p> apiVersion: apps/v1 </p><p>kind: Deployment</p><p>metadata: </p><p>  labels: </p><p>​    app: tomcat-deploy </p><p>  name: tomcat-deploy </p><p>  namespace: jiuxi </p><p>spec: </p><p>  replicas: 1 </p><p>  selector: </p><p>​    matchLabels: </p><p>​      app: tomcat-pod  </p><p>  template: </p><p>​    metadata: </p><p>​      labels: </p><p>​        app: tomcat-pod  </p><p>​    spec:</p><p>​      containers:</p><p>​      - image: docker.io/kubeguide/tomcat-app:v1</p><p>​        imagePullPolicy: Always</p><p>​        name: tomcat</p><p>​        ports:</p><p>​          - containerPort: 8080</p><p>​          name: port</p><p>​          protocol: TCP</p></blockquote><p>​    创建资源：</p><blockquote><p>kubectl apply -f jiuxi-deploy.yaml</p></blockquote><h3 id="3-5-修改-istio-ingressgateway-deployment"><a href="#3-5-修改-istio-ingressgateway-deployment" class="headerlink" title="3.5 修改 istio-ingressgateway deployment"></a>3.5 修改 istio-ingressgateway deployment</h3><p>​    这一步非常重要，因为默认情况下 istio-ingressgateway 对应的容器并没有暴露在服务网格之外，所以我们需要将其暴露出来。编辑 istio-system  命名空间下的 istio-ingressgateway deployment:</p><blockquote><p>kubectl edit deployment -n istio-system istio-ingressgateway</p></blockquote><p>​    修改内容如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911165456105.png" srcset="/img/loading.gif" lazyload alt="image-20210911165456105"></p><hr><h2 id="4-尝试网关路由功能"><a href="#4-尝试网关路由功能" class="headerlink" title="4 尝试网关路由功能"></a>4 尝试网关路由功能</h2><h3 id="4-1-确定-INGRESS-HOST"><a href="#4-1-确定-INGRESS-HOST" class="headerlink" title="4.1 确定 INGRESS_HOST"></a>4.1 确定 INGRESS_HOST</h3><blockquote><p>kubectl get pod -n istio-system -o wide</p></blockquote><p>​    执行结果如下图所示，本人的 INGRESS_HOST 就是 10.110.101.205。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911165522752.png" srcset="/img/loading.gif" lazyload alt="image-20210911165522752"></p><h3 id="4-2-编辑浏览器所在主机-hosts-文件"><a href="#4-2-编辑浏览器所在主机-hosts-文件" class="headerlink" title="4.2 编辑浏览器所在主机 hosts 文件"></a>4.2 编辑浏览器所在主机 hosts 文件</h3><blockquote><p>vim /etc/hosts    # linux</p><p>c:/windows/system32/drivers/etc/hosts    # windows</p></blockquote><p>​    添加 DNS 记录：</p><blockquote><p>10.110.101.205    jiuxi.com        # 根据个人实际情况改写</p></blockquote><h3 id="4-3-访问-tomcat"><a href="#4-3-访问-tomcat" class="headerlink" title="4.3 访问 tomcat"></a>4.3 访问 tomcat</h3><p>​    浏览器输入 <a href="http://jiuxi.com,帮尝试多刷新几次,你就会看到流量分别路由到/">http://jiuxi.com，帮尝试多刷新几次，你就会看到流量分别路由到</a> tomcat 和 nginx 服务去了，并且流量上基本达到了均分，各 50%。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911165604673.png" srcset="/img/loading.gif" lazyload alt="image-20210911165604673"></p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911165626103.png" srcset="/img/loading.gif" lazyload alt="image-20210911165626103"></p><hr><h2 id="5-小节"><a href="#5-小节" class="headerlink" title="5 小节"></a>5 小节</h2><p>​    自此我们使用了 istio 的 gateway 和 virtual service 实现了流量管理的功能。下面我们还会继续庖丁解牛 istio 其他强大的特性。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆服务网格 - istio Bookinfo 应用</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC-istio-Bookinfo-%E5%BA%94%E7%94%A8/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC-istio-Bookinfo-%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 bookinfo 架构介绍</p><p>3 bookinfo 配置与部署</p><p>  3.1 配置 istio 自动注入</p><p>  3.2 部署 bookinfo 应用</p><p>  3.3 验证 bookinfo 部署情况</p><p>4 设置 bookinfo 网关</p><p>  4.1 定义 bookinfo 入口网关</p><p>  4.2 确认网关已创建</p><p>5 访问 bookinfo 应用</p><p>  5.1 获取 INGRESS_HOST</p><p>  5.2 获取 INGRESS_PORT</p><p>  5.3 通过浏览器访问 bookinfo 应用</p><p>6 卸载 bookinfo 应用</p><p>  6.1 验证卸载</p><p>7 总结</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    如果你对博客有任何疑问或者想更深入学习 istio，请加微信群，我们一起进步：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164235979.png" srcset="/img/loading.gif" lazyload alt="image-20210911164235979"></p><hr><h2 id="2-bookinfo-架构介绍"><a href="#2-bookinfo-架构介绍" class="headerlink" title="2 bookinfo 架构介绍"></a>2 bookinfo 架构介绍</h2><p>​    bookinfo 是 istio 的学习样例，通过 bookinfo 你可以对 istio 提供的路由、遥测等功能有更加深入的理解。</p><p>​    下图是 bookinfo 在没有嵌入 istio 前的物理架构图：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164302523.png" srcset="/img/loading.gif" lazyload alt="image-20210911164302523"></p><p>​    bookinfo 是一个在线书店应用，该应用由 4 个微服务组成，分别为 Product page、Reviews、Details 和 Ratings。为了表现 istio 的无侵入性，这 4 个微服务分别由 python、java、ruby 和 node 开发。下面分别说明如下：</p><blockquote><p>Product page：聚合服务，内容由 Reviews 和 Details 内容聚合而成</p><p>Details：图书详情服务</p><p>Reviews：图书评价服务（多版本）。它也是一个聚合服务，聚合了 Ratings</p><p>Ratings：图书预订排名服务</p></blockquote><p>​    下图是 bookinfo 嵌入 istio 后的物理架构图：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164323375.png" srcset="/img/loading.gif" lazyload alt="image-20210911164323375"></p><p>​    该架构图演示了嵌入 istio 后 bookinfo 的每个微服务都会新增一个 Envoy，这个 Envoy 就是所谓的  sidecar，它会接管跟它配对的微服务的所有网络进、出口流量。其实  Envoy（sidecar）的作用就像你的手机，它正在逐渐把你变成哑巴、聋子和植物人，它承接了你所有的信息入口和出口，某些别有用心的人和组织通过对手机进行监控、遥测、路由等控制，起到控制你的思维、舆论导向、审美爱好等目的。</p><hr><h2 id="3-bookinfo-配置与部署"><a href="#3-bookinfo-配置与部署" class="headerlink" title="3 bookinfo 配置与部署"></a>3 bookinfo 配置与部署</h2><h3 id="3-1-配置-istio-自动注入"><a href="#3-1-配置-istio-自动注入" class="headerlink" title="3.1 配置 istio 自动注入"></a>3.1 配置 istio 自动注入</h3><p>​    因为 bookinfo 会启动多个 pod，每次手动注入 sidecar 会特别繁琐，因此我们使用批注入的方式。如果你对 sidecar 注入不了解，请参考本人的<a href="https://blog.51cto.com/14625168/2474271"> 上篇</a>博客。</p><blockquote><p>kubectl create ns jiuxi    # 创建 jiuxi 命名空间</p><p>kubectl label ns jiuxi istio-injection=enabled</p><p>kubectl get ns jiuxi –show-labels</p></blockquote><p>​    命令操作成功后截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164338022.png" srcset="/img/loading.gif" lazyload alt="image-20210911164338022"></p><h3 id="3-2-部署-bookinfo-应用"><a href="#3-2-部署-bookinfo-应用" class="headerlink" title="3.2 部署 bookinfo 应用"></a>3.2 部署 bookinfo 应用</h3><p>​    在命名空间 jiuxi 中部署了 bookinfo 应用：</p><blockquote><p>kubectl apply -f bookinfo/platform/kube/bookinfo.yaml -n jiuxi</p></blockquote><p>​    部署过程截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164350324.png" srcset="/img/loading.gif" lazyload alt="image-20210911164350324"></p><p>​    执行如下命令查看 bookinfo 的 service 列表：</p><blockquote><p>kubectl get svc -n jiuxi</p></blockquote><p>​    服务列表截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164402895.png" srcset="/img/loading.gif" lazyload alt="image-20210911164402895"></p><p>​    执行如下命令查看 bookinfo 的 pod 列表：</p><blockquote><p>kubectl get pod -n jiuxi</p></blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164416004.png" srcset="/img/loading.gif" lazyload alt="image-20210911164416004"></p><h3 id="3-3-验证-bookinfo-部署情况"><a href="#3-3-验证-bookinfo-部署情况" class="headerlink" title="3.3 验证 bookinfo 部署情况"></a>3.3 验证 bookinfo 部署情况</h3><p>​    在服务列表中寻找 productpage 服务，然后使用 curl 命令验证服务是否发布成功。</p><blockquote><p>kubectl get svc -n jiuxi</p><p>curl <a href="http://svc_cluster_ip:9080/">http://SVC_CLUSTER_IP:9080</a> | grep -o “<title>.*</title>“</p></blockquote><p>​    执行成功的结果如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164429965.png" srcset="/img/loading.gif" lazyload alt="image-20210911164429965"></p><p>​    自此，整个 bookinfo 应用就已经成功部署了。</p><hr><h2 id="4-设置-bookinfo-网关"><a href="#4-设置-bookinfo-网关" class="headerlink" title="4 设置 bookinfo 网关"></a>4 设置 bookinfo 网关</h2><p>​    上面的步骤已经可以让你访问到 bookinfo 应用了。但是我知道有些同学依旧觉得寒碜，因为很多人还是通过浏览器来看世界的。</p><p>​    网关就相当于你房子的大门，每当你饥肠辘辘回到家，你可以通过全开、半开、开一条缝等动作控制隔壁大妈家饭菜的饭菜香味。后续课程会专门介绍网关更深层次的原理和运用。这里你先有个粗浅的理解就可以了。</p><h3 id="4-1-定义-bookinfo-入口网关"><a href="#4-1-定义-bookinfo-入口网关" class="headerlink" title="4.1 定义 bookinfo 入口网关"></a>4.1 定义 bookinfo 入口网关</h3><blockquote><p>kubectl apply -f istio-1.4.5/samples/bookinfo/networking/bookinfo-gateway.yaml -n jiuxi</p></blockquote><h3 id="4-2-确认网关已创建"><a href="#4-2-确认网关已创建" class="headerlink" title="4.2 确认网关已创建"></a>4.2 确认网关已创建</h3><blockquote><p>kubectl get gateways.networking.istio.io -n jiuxi</p></blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164445960.png" srcset="/img/loading.gif" lazyload alt="image-20210911164445960"></p><hr><h2 id="5-访问-bookinfo-应用"><a href="#5-访问-bookinfo-应用" class="headerlink" title="5 访问 bookinfo 应用"></a>5 访问 bookinfo 应用</h2><h3 id="5-1-获取-INGRESS-HOST"><a href="#5-1-获取-INGRESS-HOST" class="headerlink" title="5.1 获取 INGRESS_HOST"></a>5.1 获取 INGRESS_HOST</h3><blockquote><p>kubectl get po -l istio=ingressgateway -n istio-system -o jsonpath=’{.items[0].status.hostIP}’</p></blockquote><h3 id="5-2-获取-INGRESS-PORT"><a href="#5-2-获取-INGRESS-PORT" class="headerlink" title="5.2 获取 INGRESS_PORT"></a>5.2 获取 INGRESS_PORT</h3><blockquote><p>kubectl -n istio-system get service istio-ingressgateway -o jsonpath=’{.spec.ports[?(@.name==”http2”)].nodePort}’</p></blockquote><h3 id="5-3-通过浏览器访问-bookinfo-应用"><a href="#5-3-通过浏览器访问-bookinfo-应用" class="headerlink" title="5.3 通过浏览器访问 bookinfo 应用"></a>5.3 通过浏览器访问 bookinfo 应用</h3><p>​    根据 5.1 和 5.2 获取到 host 和 port 信息，如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164506614.png" srcset="/img/loading.gif" lazyload alt="image-20210911164506614"></p><p>​    根据此 host 和 port，打开浏览器进行访问：</p><p>​    多刷新几次页面，你会发现 bookinfo 应用使用到的多个 reviews 版本，如下所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164538736.png" srcset="/img/loading.gif" lazyload alt="image-20210911164538736"></p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164551497.png" srcset="/img/loading.gif" lazyload alt="image-20210911164551497"></p><p>​    正好可以对应到 pod 信息：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164605008.png" srcset="/img/loading.gif" lazyload alt="image-20210911164605009"></p><hr><h2 id="6-卸载-bookinfo-应用"><a href="#6-卸载-bookinfo-应用" class="headerlink" title="6 卸载 bookinfo 应用"></a>6 卸载 bookinfo 应用</h2><p>​    你已经创建了 bookinfo，有了创建的快感。也许你有点怅然若失，因为你觉得你的技术人生不够圆满，你想亲身完爆你创建的一切，那么还等什么，执行下面的语句吧：</p><blockquote><p>./istio-1.4.5/samples/bookinfo/platform/kube/cleanup.sh</p></blockquote><p>​    命令执行成功后，会显示如下截图：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164619983.png" srcset="/img/loading.gif" lazyload alt="image-20210911164619983"></p><h3 id="6-1-验证卸载"><a href="#6-1-验证卸载" class="headerlink" title="6.1 验证卸载"></a>6.1 验证卸载</h3><p>​    执行如下命令验证你是否成功卸载：</p><blockquote><p>kubectl get virtualservices.networking.istio.io -n jiuxi</p><p>kubectl get destinationrules.networking.istio.io -n jiuxi</p><p>kubectl get gateways.networking.istio.io -n jiuxi</p><p>kubectl get pod -n jiuxi</p></blockquote><p>​    但是假如你觉得破坏的感觉很爽，就像嚼了炫迈一下停不下来，你可以执行如下作死命令：</p><blockquote><p>rm -rf /   # 你要是真敢这么做，我就崇拜你</p></blockquote><hr><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h2><p>​    自此，九析已经带你轻松完爆了 Bookinfo 应用。相信在操作的过程中，你还有很多不理解的地方，但是没关系，后续九析会为你庖丁解牛的。你需要做的，就是跟着九析操作一遍，熟悉一下整个流程，后续某天你一定会在某个瞬间大声尖叫：“我得到了”。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆服务网格 - istio 初探</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC-istio-%E5%88%9D%E6%8E%A2/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC-istio-%E5%88%9D%E6%8E%A2/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 istio 初探</p><p>  2.1 手动注入 sidecar</p><p>  2.2 自动注入 sidecar</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    如果你对博客有任何疑问，请加微信沟通：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584496625204864.png" srcset="/img/loading.gif" lazyload alt="第二章 九析带你轻松完爆服务网格 - istio 初探_服务网格"></p><p>​    你可以从下面截图中获取免费的、更生动的视频资料，在 b 站搜索“九析”：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584496646484217.png" srcset="/img/loading.gif" lazyload alt="第二章 九析带你轻松完爆服务网格 - istio 初探_服务网格_02"></p><hr><h2 id="2-istio-初探"><a href="#2-istio-初探" class="headerlink" title="2 istio 初探"></a>2 istio 初探</h2><p>​    上节九析带你轻松完爆了 istio 的安装。但是我相信安装成功的小伙伴依然云里雾里，因为看着一大坨 pod 在那里 running  着，似乎并没有产生任何作用。这节，九析就带你“莫畏浮云遮望眼，守得云开见月明”。为了预期效果，我们不妨先建立一个  deployment，内容如下：</p><blockquote><p>apiVersion: apps/v1</p><p>kind: Deployment</p><p>metadata:</p><p>  name: nginx</p><p>  labels:</p><p>​    app: nginx</p><p>spec:</p><p>  replicas: 1</p><p>  selector:</p><p>​    matchLabels:</p><p>​      app: nginx</p><p>  template:</p><p>​    metadata:</p><p>​      labels:</p><p>​        app: nginx</p><p>​    spec:</p><p>​      containers:</p><p>​      - name: nginx</p><p>​        image: nginx:1.14-alpine</p><p>​        ports:</p><p>​        - containerPort: 80</p></blockquote><p>​    创建 deployment，当然为了让你能更深刻地记住哥，把哥印在灵魂深处，你需要首先创建一个命名空间：</p><blockquote><p>kubectl create ns jiuxi</p><p>kubectl apply -f nginx-deployment.yaml -n jiuxi</p></blockquote><p>​    命令执行成功后，查询 nginx pod 状态：</p><blockquote><p>kubectl get pods -n jiuxi</p></blockquote><p>​    截图如下：需要注意 ready 这一列，内容为 1/1，表示的含义是 pod 内有一个容器，且该容器运行成功并处于就绪状态。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911163851179.png" srcset="/img/loading.gif" lazyload alt="image-20210911163851179"></p><p>​    下面到了激动人心的时刻了，因为 istio 即将闪亮登场。</p><h3 id="2-1-手动注入-sidecar"><a href="#2-1-手动注入-sidecar" class="headerlink" title="2.1 手动注入 sidecar"></a>2.1 手动注入 sidecar</h3><p>​    执行如下语句：</p><blockquote><p>kube-inject -f nginx-deployment.yaml | kubectl apply  -n jiuxi -f -</p></blockquote><p>​    命令执行结果如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911163908323.png" srcset="/img/loading.gif" lazyload alt="image-20210911163908323"></p><p>​    此时你会发现一个奇怪的现象，nginx-deployment.yaml 并没修改，但是 ready 状态却变成了 2/2。根据上面的解释可知，现在 pod 内有两个容器，且这两个容器都运行成功并处于就绪状态。为什么多了一个容器呢？</p><p>​    查看 pod 的详细信息：</p><blockquote><p>kubectl get pod -n jiuxi nginx-xxxx -o yaml # xxxx 根据自己实际情况填写</p></blockquote><p>​    如果你有类似 rancher 这样的 web 控制台，可以看得更仔细些，如下图所示。如果你还没有安装和配置 rancher，你可以参考哥的轻松完爆 rancher 系列进行安装，放心，容易到爆，容易到你尖叫。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911163928463.png" srcset="/img/loading.gif" lazyload alt="image-20210911163928463"></p><p>​    从上图可知。此时 nginx pod 内部一共有 3 个容器，一个初始化容器 istio-init 已经运行成功并结束了，一个就是 nginx  本尊，另外一个就是本文的主角 istio-proxy 了，它就是 sidecar，作用跟鸡你太美的经纪人的作用差不多，负责跟外部打交道用的。</p><p>​    此时此刻，你已经为 pod 手工织入了 istio。但是这样似乎有点不够爽。因为每建立一个 pod 都撸这么一管，感觉有点累，有没有批量或者更自然的方式呢？</p><h3 id="2-2-命名空间注入-sidecar"><a href="#2-2-命名空间注入-sidecar" class="headerlink" title="2.2 命名空间注入 sidecar"></a>2.2 命名空间注入 sidecar</h3><p>​    现在我们删除掉刚才创建的 nginx：</p><blockquote><p>kubectl delete deployments.apps nginx -n jiuxi</p></blockquote><p>​    执行如下命令在命名空间内实现自动注入 sidecar：</p><blockquote><p>kubectl label namespaces jiuxi istio-injection=enabled</p><p>kubectl get ns jiuxi –show-labels # 查看 label 是否成功创建</p></blockquote><p>​    再次根据 nginx-deployment.yaml 文件创建 nginx deployment：</p><blockquote><p>kubectl apply -f nginx-deployment.yaml -n jiuxi</p></blockquote><p>​    创建成功后查看 pod 信息，发现已经自动织入了 sidecar。</p><p>​    自此，本节九析带你轻松完爆了 istio 的手动和自动织入功能。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆服务网格 - istio 安装</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC-istio-%E5%AE%89%E8%A3%85/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC-istio-%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 微服务的历史</p><p>3 istio</p><p>4 istio 使用</p><p>  4.1 下载 istio</p><p>  4.2 安装 istio</p><p>  4.3 配置 istioctl 工具路径</p><p>  4.4 实现 istioctl 自动补全功能</p><p>  4.5 安装学习版 istio</p><p>  4.6 卸载 istio</p><p>5 总结</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    如果你对博客有任何疑问，请加微信沟通：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584453790467569.jpg" srcset="/img/loading.gif" lazyload alt="第一章 九析带你轻松完爆服务网格 - istio 安装_k8s istio"></p><p>​    你可以从下面截图中获取免费的、更生动的视频资料，在 b 站搜索“九析”：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584453854320948.png" srcset="/img/loading.gif" lazyload alt="第一章 九析带你轻松完爆服务网格 - istio 安装_service mesh_02"></p><hr><h2 id="2-微服务的历史"><a href="#2-微服务的历史" class="headerlink" title="2 微服务的历史"></a>2 微服务的历史</h2><p>​    微服务从马丁提出到今天为止，大体上经过了四代。</p><p>​    第一代（1.0  时代）：服务发现阶段。单体服务发展到微服务后，原先的通信方式从进程内函数调用发展到了不同服务器上的不同服务之间的进程调用，这样的架构变化，首先要解决的关键问题就是服务的注册与发现。代表技术便是 dubbo 和 grpc、brpc 框架之争。</p><p>​    第二代（2.0 时代）：当服务发现问题解决了之后，紧接着带来的挑战便是服务治理。何为服务治理，就是除了服务之间通讯之外，还需要更深层次考虑到服务之间调用的失败重试、容错、降级、监控、安全、灰度、流控能问题。</p><p>​    第三代（3.0 时代）：微服务 2.0  时代带来了解决方案的百花齐放，各方你方唱罢，我方登场，相同问题的不同解决方案纷纷亮相，一时间风云际会，好不热闹。比如网关解决方案就有  zuul、gateway；全链路监控就有 pinpoint、zipkin、jaeger  等。各种服务治理的解决方案层出不穷带来了很多的积极作用，但负面影响也随之而来，那便是标准的不统一、维护方式各异。服务治理变成了各种中间件的相互嫁接，服务治理的好坏全靠工程师的技术水平高低。基于此，服务治理的标准化、一致化需求越来越强烈，于是服务网格便应运而生。服务网格的思想便是将服务治理标准化，并统一下沉到基础设施层。就像 50、60  年代的美国，当时帮派林立，不同地盘治理的好坏主要依靠各个帮派屌不屌，但是到了后来政府能力逐渐强大和稳定，很多地下秩序不再依靠黑帮，而统一让政府规则化一样的道理。</p><p>​    第四代（4.0 时代）：无服务时代，即 serveless 时代，说的时髦点就是去中心化时代。这个目前还并不成熟，本文先略去不谈。</p><hr><h2 id="3-istio"><a href="#3-istio" class="headerlink" title="3 istio"></a>3 istio</h2><p>​    istio 就是微服务 3.0 时代的产物，是 service mesh 的代表性产品。由谷歌和 IBM 联手打造。借助谷歌的拳头产品  k8s，顷刻完爆众神。istio 跟 k8s 之间到底什么关系？你可以这么来理解，k8s 相当于王健林，istio  相当于王思聪。怎么说呢？k8s 负责打地基，打造基础设施，istio  负责在地基之上整合各种服务模式。大家都知道有个女的去万达影院看电影抱怨爆米花少，结果王思聪承诺给她终生免费提供爆米花的事吧。这就相当于请求失败并重试成功的典型服务治理案例。</p><p>​    istio 包括如下特性：</p><blockquote><p>1 http, gRPC, WebSocket 和 TCP 通信的自动负载均衡</p><p>2 通过丰富的路有规则、重试、故障转移和故障注入对流量行为进行细粒度控制</p><p>3 可插拔的策略层和配置 API，支持访问控制，速率限制和配额</p><p>4 集群内所有流量的自动度量，日志和跟踪，包括集群的入口和出口</p><p>5 通过强大的基于身份和身份验证和授权，在集群中实现安全的服务间通信</p></blockquote><p>​    简单总结便是：istio 负责网络数据包的流量管理（traffic management）、服务的安全保护（secure）、策略（policy，比如黑白名单制定）和可观察（observability，比如监控）。</p><hr><h2 id="4-istio-使用"><a href="#4-istio-使用" class="headerlink" title="4 istio 使用"></a>4 istio 使用</h2><p>​    逼逼完了理论后（其实我最不喜欢就是扯理论），开始进入完爆 istio 环节。</p><h3 id="4-1-下载-istio"><a href="#4-1-下载-istio" class="headerlink" title="4.1 下载 istio"></a>4.1 下载 istio</h3><p>​    在玩 istio 之前，必须要有前置条件，那就是你要先把 k8s 完爆了，你需要首先搭建 k8s 环境。怎么搭建 k8s，你可以参考本人的《<a href="https://blog.51cto.com/14625168/2453827"> 一分钟搭建 k8s 教程</a>》，不用谢。</p><p>​    使用如下语句下载 istio，下载速度会有点慢。至于有多慢？谁试谁知道。而且时不时会断，所以你要时刻关注，如果失败了，需要重新执行。这种感觉就好像你在小便，后面总是有人推你，让你整个过程非常不顺畅，非常不爽。</p><blockquote><p>curl -L <a href="https://istio.io/downloadIstio">https://istio.io/downloadIstio</a> | sh -</p></blockquote><p>​    在下载过程中，如果你遭遇如下错误：</p><blockquote><p>Unable to get latest Istio version. Set ISTIO_VERSION env var and re-run. For example: export ISTIO_VERSION=1.0.4</p></blockquote><p>​    你需要设置一下你要下载的 istio 版本，语句如下：</p><blockquote><p>export ISTIO_VERSION=1.4.5</p></blockquote><p>​    下载成功后的截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911163236926.png" srcset="/img/loading.gif" lazyload alt="image-20210911163236926"></p><h3 id="4-2-安装-istio"><a href="#4-2-安装-istio" class="headerlink" title="4.2 安装 istio"></a>4.2 安装 istio</h3><p>​    安装 istio 前，首先解压缩：</p><blockquote><p>tar -zxvf istio-1.4.5-linux.tar.gz</p></blockquote><p>​    解压缩后的目录结构截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911163255978.png" srcset="/img/loading.gif" lazyload alt="image-20210911163255978"></p><p>​    关键目录说明如下：</p><blockquote><p>install/kubernetes    # istio 资源文件</p><p>samples            # istio 样例</p><p>bin/istioctl        # istio 客户端工具，用来手动注入 envoy</p></blockquote><h3 id="4-3-配置-istioctl-工具路径"><a href="#4-3-配置-istioctl-工具路径" class="headerlink" title="4.3 配置 istioctl 工具路径"></a>4.3 配置 istioctl 工具路径</h3><p>​    istioctl 是 istio 的客户端工具，其作用是手动注入 envoy 作为容器的 sidecar（边车）。什么是 sidecar？你就把它当成鸡你太美的经纪人，懂了没？就是负责跟外界打交道的。配置方式如下：</p><blockquote><p>cd istio-1.4.5</p><p>export PATH=$PATH:$PWD/bin</p></blockquote><p>​    配置完，在 bash 中就可以通过 Tab 键自动补全 istioctl 命令了。但是这样够吗？完美吗？当然不。我们还有更高的要求。</p><p>​    因为 istioctl 有很多配置项，仅仅使用 tab 键只能自动补全 istioctl，但是无法自动补全 istioctl manifest 类似这样的子命令。因此我们需要设置增强自动补全功能。</p><h3 id="4-4-实现-istioctl-自动补全功能"><a href="#4-4-实现-istioctl-自动补全功能" class="headerlink" title="4.4 实现 istioctl 自动补全功能"></a>4.4 实现 istioctl 自动补全功能</h3><p>​    将 istio 安装包内 tools 目录下的 istioctl.bash 文件拷贝到用户根目录下：</p><blockquote><p>cp istio/istio-1.4.5/tools/istioctl.bash ~</p></blockquote><p>​    编辑 ~/.bash_profile 文件，在文件末尾添加如下内容：</p><blockquote><p>source ~/istioctl.bash</p></blockquote><p>​    添加完毕后，加载配置使配置生效：</p><blockquote><p>source ~/.bash_profile</p></blockquote><p>​    然后输入 istioctl 然后按两次 tab 键，发现增强自动补全功能已经生效：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911163319451.png" srcset="/img/loading.gif" lazyload alt="image-20210911163319451"></p><h3 id="4-5-安装学习版-istio"><a href="#4-5-安装学习版-istio" class="headerlink" title="4.5 安装学习版 istio"></a>4.5 安装学习版 istio</h3><p>​    为了降低学习成本，我们选择安装学习版本的 istio。如果你想直接在生产环境安装 istio，可以参考我后续的章节。</p><p>​    执行如下语句安装 istio 学习版：</p><blockquote><p>istioctl manifest apply –set profile=demo</p></blockquote><p>​    安装后的截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911163332691.png" srcset="/img/loading.gif" lazyload alt="image-20210911163332691"></p><p>​    不要一看到 Installation complete 就高兴到尖叫！因为安装完毕不报错并不意味着你就成功了，就像你看到一个美丽、性感、火辣、清纯、高贵、华丽集一身的女人向你走过来时就以为人家觉得你长得帅想泡你一样的道理。</p><p>​    使用如下命令查看一下 istio 的服务状态：</p><blockquote><p>kubectl get svc -n istio-system</p></blockquote><p>​    执行结果如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911163351397.png" srcset="/img/loading.gif" lazyload alt="image-20210911163351397"></p><p>​    服务使用 LoadBalancer 类型一般是在第三方云厂商支持下才有用。如果你是在自己搭建的 k8s 集群环境下一般使用 NodePort 类型。执行如下语句完爆：</p><blockquote><p>kubectl patch svc -n istio-system istio-ingressgateway -p ‘{“spec”: {“type”: “NodePort”}}’</p></blockquote><p>​    执行完毕后，再次查看 svc，发现原来的 LoadBalancer 类型已经被修改为 NodePort 类型，此外 external-ip 也从 pending 状态变成了 <none>(即：不需要)状态。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911163422494.png" srcset="/img/loading.gif" lazyload alt="image-20210911163422494"></p><p>​    查看 istio 的 pod 运行状态：</p><blockquote><p>kubectl get pod -n istio-system</p></blockquote><p>​    运行状态截图如下，所有 pod 状态都是 running 状态：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911163442809.png" srcset="/img/loading.gif" lazyload alt="image-20210911163442809"></p><p>​    自此，整个 istio 环境就被你轻松完爆了。现在你可以停下来，上厕所，喝水和尖叫了。</p><h3 id="4-6-卸载-istio"><a href="#4-6-卸载-istio" class="headerlink" title="4.6 卸载 istio"></a>4.6 卸载 istio</h3><p>​    但是假如你觉得不够爽，光有建立的快感，没有破坏的快感总是觉得技术人生不够圆满的话，你可以执行如下语句轻松完爆 istio。</p><blockquote><p>istioctl manifest generate –set profile=demo | kubectl delete -f -</p></blockquote><hr><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>​    好了，一切都回到了原点。这种感觉像极了你拥有了一个女人，然后蹂躏了一番后，又抛弃她的感觉。但是望着消失了一切后的黑乎乎的屏幕后，你或许点燃了一颗烟，问问自己，抛弃的感觉是否真的快乐？如果没有，你就把文章拉倒起点，再来一遍吧。也许当你操作完后，你会重新追回你深爱的她。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux 系列之一《升级内核》</title>
    <link href="/2021/09/11/linux%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E3%80%8A%E5%86%85%E6%A0%B8%E5%8D%87%E7%BA%A7%E3%80%8B/"/>
    <url>/2021/09/11/linux%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E3%80%8A%E5%86%85%E6%A0%B8%E5%8D%87%E7%BA%A7%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-操作系统的内核与发行版"><a href="#1-操作系统的内核与发行版" class="headerlink" title="1 操作系统的内核与发行版"></a>1 操作系统的内核与发行版</h1><p>&emsp;&emsp;首先简单解释一下操作系统的内核和发行版。</p><p>&emsp;&emsp;内核是管理 CPU、内存、磁盘、进程、中断、文件系统和网络协议栈的程序。</p><p>&emsp;&emsp;用户对内核感知度不高，因为用户只需要应用程序。比如某人迷恋日本电影，ta 并不在乎内核，ta 需要的只是一个播放器，这怎么办呢？于是就有好事者在内核之外预安装了一个播放器给 ta 使用，随着类似的需求不断增多，预安装的程序也越来越多，逐渐就发展成了内核和应用程序集的”结合体”，这个”结合体”我们就称之为操作系统的发行版，比如我们耳熟能详的 Red Hat、CentOS、Ubuntu 都属于操作系统的发行版。</p><p>&emsp;&emsp;本节我们将讨论如何升级 linux 内核，常见内核升级方式有如下三种，读者可根据喜好自由选择：</p><ul><li>在线升级</li><li>离线升级</li><li>定制升级 </li></ul><h1 id="2-查看内核版本"><a href="#2-查看内核版本" class="headerlink" title="2 查看内核版本"></a>2 查看内核版本</h1><p>&emsp;&emsp;使用如下命令查看当前内核版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> uname -r</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;命令执行结果如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# uname -r<br>3.10.0-327.el7.x86_64<br></code></pre></td></tr></table></figure><h1 id="3-在线升级"><a href="#3-在线升级" class="headerlink" title="3 在线升级"></a>3 在线升级</h1><p>&emsp;&emsp;使用 yum 在线升级是最安全的升级方式，因为使用该方式升级的版本是经过厂商验证过的版本，虽然它并不是最新的，但却是最稳定的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> yum install -y kernel</span><br></code></pre></td></tr></table></figure><h1 id="4-手动升级"><a href="#4-手动升级" class="headerlink" title="4 手动升级"></a>4 手动升级</h1><p>&emsp;&emsp;手动升级是一件比较刺激的事情，升级前需要到 <a href="https://www.kernel.org/">linux 内核网站</a> 下载指定版本的内核包：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911153728956.png" srcset="/img/loading.gif" lazyload alt="linux 内核网站"></p><h2 id="4-1-下载安装包"><a href="#4-1-下载安装包" class="headerlink" title="4.1 下载安装包"></a>4.1 下载安装包</h2><p>&emsp;&emsp;手动升级采用 4.x 版本，下载网址请<a href="https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/">点击</a>。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911153808360.png" srcset="/img/loading.gif" lazyload alt="linux 4.x 内核版本网址"></p><h2 id="4-2-解压缩安装包"><a href="#4-2-解压缩安装包" class="headerlink" title="4.2 解压缩安装包"></a>4.2 解压缩安装包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> tar -zxvf linux-4.14.tar.gz</span><br></code></pre></td></tr></table></figure><h2 id="4-3-编译安装步骤"><a href="#4-3-编译安装步骤" class="headerlink" title="4.3 编译安装步骤"></a>4.3 编译安装步骤</h2><p>&emsp;&emsp;编译安装步骤如下，只需一步一步执行即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> yum install -y gcc bc openssl-devel perl</span> <br><span class="hljs-meta">#</span><span class="bash"> make mrproper  <span class="hljs-comment"># 删除编译生成的文件，包括内核配置文件和各种配置文件，一般只在第一次执行内核编译前才使用此命令</span></span><br><span class="hljs-meta">#</span><span class="bash"> make oldconfig <span class="hljs-comment"># 使用原有的内核配置。执行过程中需要交互，一路回车即可</span></span><br><span class="hljs-meta">#</span><span class="bash"> make  <span class="hljs-comment"># 编译源码。所有执行操作中最耗时的部分。你可以睡个午觉</span></span><br><span class="hljs-meta">#</span><span class="bash"> make modules_install<span class="hljs-comment"># 将编译出的内核模块复制到 /lib/modules</span></span><br><span class="hljs-meta">#</span><span class="bash"> make install<span class="hljs-comment"># make是编译；make install 安装到指定位置(/boot)</span></span><br></code></pre></td></tr></table></figure><h2 id="4-4-重启"><a href="#4-4-重启" class="headerlink" title="4.4 重启"></a>4.4 重启</h2><p>&emsp;&emsp;编译安装后重启系统，发现 4.14 版本已经成功安装，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911153835264.png" srcset="/img/loading.gif" lazyload alt="grub 版本信息"></p><h1 id="5-定制升级"><a href="#5-定制升级" class="headerlink" title="5 定制升级"></a>5 定制升级</h1><p>&emsp;&emsp;上面在线升级方式升级的版本一般较老，如果既想在线安装，又想指定版本，可采用定制升级。</p><h2 id="5-1-安装-elrepo-yum-源"><a href="#5-1-安装-elrepo-yum-源" class="headerlink" title="5.1 安装 elrepo yum 源"></a>5.1 安装 elrepo yum 源</h2><p>&emsp;&emsp;elrepo 是 CentOS 稳定的软件源，通过它可以很容易将内核升级到指定版本，elrepo 网址请<a href="https://elrepo.org/tiki/tiki-index.php">点击</a>：</p><blockquote><p>yum install -y <a href="https://www.elrepo.org/elrepo-release-7.0-4.el7.elrepo.noarch.rpm"> https://www.elrepo.org/elrepo-release-7.0-4.el7.elrepo.noarch.rpm</a></p></blockquote><h2 id="5-2-查看内核包"><a href="#5-2-查看内核包" class="headerlink" title="5.2 查看内核包"></a>5.2 查看内核包</h2><blockquote><p>yum –disablerepo=”*” –enablerepo=”elrepo-kernel” list available</p></blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911153911399.png" srcset="/img/loading.gif" lazyload alt="image-20210911153911399"></p><h2 id="5-3-升级内核"><a href="#5-3-升级内核" class="headerlink" title="5.3 升级内核"></a>5.3 升级内核</h2><p>&emsp;&emsp;在 elrepo 源中有 ml 和 lt 两种内核。ml（mainline）为最新版本的内核，lt 为长期支持的内核。这里选择 ml 内核。</p><blockquote><p>yum –enablerepo=elrepo-kernel -y install kernel-ml</p></blockquote><h2 id="5-4-修改内核启动顺序"><a href="#5-4-修改内核启动顺序" class="headerlink" title="5.4 修改内核启动顺序"></a>5.4 修改内核启动顺序</h2><p>&emsp;&emsp;修改 /etc/default/grub 文件，将 GRUB_DEFAULT 改为 0：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911153928164.png" srcset="/img/loading.gif" lazyload alt="image-20210911153928164"></p><p>&emsp;&emsp;编辑完后，执行如下命令让配置生效：</p><blockquote><p>grub2-mkconfig -o /boot/grub2/grub.cfg</p></blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911153942984.png" srcset="/img/loading.gif" lazyload alt="image-20210911153942984"></p><h2 id="5-5-重启系统"><a href="#5-5-重启系统" class="headerlink" title="5.5 重启系统"></a>5.5 重启系统</h2><blockquote><p>reboot</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>client-go 系列之三《go k8s 访问》</title>
    <link href="/2021/09/06/k8s%E5%BC%80%E5%8F%91%E4%B9%8Bclient-go%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%89%E3%80%8AGO-K8S-%E8%AE%BF%E9%97%AE%E3%80%8B/"/>
    <url>/2021/09/06/k8s%E5%BC%80%E5%8F%91%E4%B9%8Bclient-go%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%89%E3%80%8AGO-K8S-%E8%AE%BF%E9%97%AE%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>&emsp;&emsp;上节介绍了 GO 项目开发的配置，本小节会利用 client-go 库实际编写一个访问 K8S 的样例。</p><h1 id="2-运行环境"><a href="#2-运行环境" class="headerlink" title="2 运行环境"></a>2 运行环境</h1><p>&emsp;&emsp;本系列文章使用的环境配置如下（不要求读者完全匹配，可根据自己实际情况酌情处理）：</p><ul><li>K8s        版本 :  <strong>1.19.0</strong></li><li>Docker  版本：<strong>20.10.8</strong></li><li>CentOS 版本：<strong>7.7.1908</strong></li><li>Go SDK 版本：<strong>go1.16.6 linux/amd64</strong></li></ul><h1 id="3-项目代码"><a href="#3-项目代码" class="headerlink" title="3 项目代码"></a>3 项目代码</h1><p>&emsp;&emsp;进入 GO 项目的根目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">cd</span> <span class="hljs-variable">$GOPATH</span>/src</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;新建 k8s-visitor 项目目录，并在该目录下创建 main.go 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> mkdir k8s-visitor</span><br><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">cd</span> k8s-visitor</span><br><span class="hljs-meta">#</span><span class="bash"> touch main.go</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;编辑 main.go 文件，添加如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;io/ioutil&quot;</span><br><br>    core_v1 <span class="hljs-string">&quot;k8s.io/api/core/v1&quot;</span><br>    meta_v1 <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/client-go/kubernetes&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/client-go/rest&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/client-go/tools/clientcmd&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> (<br>        err          error<br>        kubeconfig   []<span class="hljs-keyword">byte</span><br>        clientconfig *rest.Config<br>        clientset    *kubernetes.Clientset<br>        pods       *core_v1.PodList<br>    )   <br><br>    <span class="hljs-keyword">if</span> kubeconfig, err = ioutil.ReadFile(<span class="hljs-string">&quot;/root/.kube/config&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;   <br><br>    <span class="hljs-keyword">if</span> clientconfig, err = clientcmd.RESTConfigFromKubeConfig(kubeconfig); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;   <br><br>    <span class="hljs-keyword">if</span> clientset, err = kubernetes.NewForConfig(clientconfig); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;   <br><br>    <span class="hljs-keyword">if</span> pods, err = clientset.CoreV1().Pods(<span class="hljs-string">&quot;default&quot;</span>).List(context.TODO(), meta_v1.ListOptions&#123;&#125;); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br><br>    fmt.Println(pods)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-运行项目"><a href="#4-运行项目" class="headerlink" title="4 运行项目"></a>4 运行项目</h1><p>&emsp;&emsp;如果想运行成功上面的代码样例，需执行如下两个步骤：</p><ul><li>创建 go.mod</li><li>运行 main.go</li></ul><h2 id="4-1-创建-go-mod"><a href="#4-1-创建-go-mod" class="headerlink" title="4.1 创建 go.mod"></a>4.1 创建 go.mod</h2><p>&emsp;&emsp;go mod 在 GO v1.11 版本引入，在 v1.12 版本基本稳定，到 v1.13 版本的时候默认是打开的，可以使用如下命令查看：        </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@k8s-master-1 k8s-visitor]# go env | grep -i GO111MODULE<br>GO111MODULE=&quot;on&quot;<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;执行下列命令创建 go.mod 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@k8s-master-1 k8s-visitor]# go mod init<br>go: creating new go.mod: module k8s-visitor<br>go: to add module requirements and sums:<br>go mod tidy<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;如果执行结果如上所示，继续执行下面指令（备注，如果指令执行失败，很大概率是依赖包下不到，可参考本系列第一篇文章配置好下载包代理）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@k8s-master-1 k8s-visitor]# go mod tidy<br>go: finding module for package k8s.io/client-go/tools/clientcmd<br>go: finding module for package k8s.io/client-go/kubernetes<br>go: finding module for package k8s.io/client-go/rest<br>go: finding module for package k8s.io/api/core/v1<br>go: finding module for package k8s.io/apimachinery/pkg/apis/meta/v1<br>go: found k8s.io/api/core/v1 in k8s.io/api v0.22.1<br>go: found k8s.io/apimachinery/pkg/apis/meta/v1 in k8s.io/apimachinery v0.22.1<br>go: found k8s.io/client-go/kubernetes in k8s.io/client-go v0.22.1<br>go: found k8s.io/client-go/rest in k8s.io/client-go v0.22.1<br>go: found k8s.io/client-go/tools/clientcmd in k8s.io/client-go v0.22.1<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;执行完毕后， $GOPATH/src/k8s-visitor 目录结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@k8s-master-1 k8s-visitor]# tree<br>.<br>├── go.mod<br>├── go.sum<br>└── main.go<br><br>0 directories, 3 files<br></code></pre></td></tr></table></figure><h2 id="4-2-运行-main-go"><a href="#4-2-运行-main-go" class="headerlink" title="4.2 运行 main.go"></a>4.2 运行 main.go</h2><p>&emsp;&emsp;运行 main.go：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">[root@k8s-master<span class="hljs-number">-1</span> k8s-visitor]# <span class="hljs-keyword">go</span> run main.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;如果读者输出的结果是 k8s default 命名空间下的 pod 列表信息则表示程序执行成功。下图是笔者的运行结果，仅供参考：</p><p><img src="/img/20210907213207.jpg" srcset="/img/loading.gif" lazyload alt="K8S POD 列表明细"></p><p>&emsp;&emsp;自此，第一个 client-go 程序编写完毕并运行成功。</p><h2 id="4-3-源码解释"><a href="#4-3-源码解释" class="headerlink" title="4.3 源码解释"></a>4.3 源码解释</h2><p>&emsp;&emsp;下面简单介绍程序代码逻辑。</p><h3 id="4-3-1-读取-K8S-配置"><a href="#4-3-1-读取-K8S-配置" class="headerlink" title="4.3.1 读取 K8S 配置"></a>4.3.1 读取 K8S 配置</h3><p>&emsp;&emsp;client-go 需要连接配置才可以访问到 K8S，比如 IP、Port、CA 或 token 等。K8S 默认将连接配置存放在 master 节点的 ~/.kube/config 文件中，比如笔者配置如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell">apiVersion: v1<br>clusters:<br>- cluster:<br>    certificate-authority: /etc/kubernetes/pki/ca.crt<br>    server: https://10.110.101.109:6443<br>  name: default<br>- cluster:<br>    certificate-authority: /etc/kubernetes/pki/ca.crt<br>    server: https://10.110.101.109:6443<br>  name: k8s-cluster<br>contexts:<br>- context:<br>    cluster: default<br>    user: admin<br>  name: default<br>- context:<br>    cluster: k8s-cluster<br>    namespace: jiuxi<br>    user: admin<br>  name: k8s-context<br>current-context: default<br>kind: Config<br>preferences: &#123;&#125;<br>users:<br>- name: admin<br>  user:<br>    client-certificate: /etc/kubernetes/pki/client.crt<br>    client-key: /etc/kubernetes/pki/client.key<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;下列代码读取上面 config 配置文件，保存在 kubeconfig 切片中，如果读者 K8S 默认配置文件地址（/root/.kube/config）与笔者不同，请根据实际情况进行修改。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> kubeconfig, err = ioutil.ReadFile(<span class="hljs-string">&quot;/root/.kube/config&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-built_in">panic</span>(err)<br>&#125;  <br></code></pre></td></tr></table></figure><h2 id="4-3-2-创建客户端配置对象"><a href="#4-3-2-创建客户端配置对象" class="headerlink" title="4.3.2 创建客户端配置对象"></a>4.3.2 创建客户端配置对象</h2><p>&emsp;&emsp;下列代码将上面创建的 kubeconfig 切片转化为客户端配置对象，读者如果觉得费解，可以简单理解为单纯的数据类型转换，即：从切片转化为对象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> clientconfig, err = clientcmd.RESTConfigFromKubeConfig(kubeconfig); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-built_in">panic</span>(err)<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="4-3-3-创建客户端访问对象"><a href="#4-3-3-创建客户端访问对象" class="headerlink" title="4.3.3 创建客户端访问对象"></a>4.3.3 创建客户端访问对象</h2><p>&emsp;&emsp;下列代码根据上面创建的配置对象（clientconfig）生成客户端访问对象（clientset），clientset 是 client-go 针对 K8S 每种内置资源（比如：Pod，Deployment）封装的客户端访问对象，该对象内部封装资源操作的 API（比如 delete、create、apply），读者可直接拿来使用，不用自己创造轮子。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> clientset, err = kubernetes.NewForConfig(clientconfig); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-built_in">panic</span>(err)<br>&#125;   <br></code></pre></td></tr></table></figure><h2 id="4-3-4-访问-K8S-获取-Pod-列表"><a href="#4-3-4-访问-K8S-获取-Pod-列表" class="headerlink" title="4.3.4 访问 K8S 获取 Pod 列表"></a>4.3.4 访问 K8S 获取 Pod 列表</h2><p>&emsp;&emsp;下列代码利用 clientset API 获取 K8S default 命名空间下的 Pod 列表。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> pods, err = clientset.CoreV1().Pods(<span class="hljs-string">&quot;default&quot;</span>).List(context.TODO(), meta_v1.ListOptions&#123;&#125;); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-built_in">panic</span>(err)<br>&#125; <br></code></pre></td></tr></table></figure><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h1><p>&emsp;&emsp;本节给出了一个实际样例介绍如何使用 client-go 连接 K8S，这是项目开发的基础，后续所有项目将基于此开发，请大家认真体会。</p>]]></content>
    
    
    <categories>
      
      <category>client-go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>client-go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>client-go 系列之二《go 项目设置》</title>
    <link href="/2021/08/28/k8s%E5%BC%80%E5%8F%91%E4%B9%8Bclient-go%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E3%80%8AGO-%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE%E3%80%8B/"/>
    <url>/2021/08/28/k8s%E5%BC%80%E5%8F%91%E4%B9%8Bclient-go%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E3%80%8AGO-%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>&emsp;&emsp;上节介绍了 client-go 和 GO SDK 安装，本小节将介绍 GO 项目配置，并给出一个 GO 项目实例。</p><h1 id="2-运行环境"><a href="#2-运行环境" class="headerlink" title="2 运行环境"></a>2 运行环境</h1><p>&emsp;&emsp;本系列文章使用的环境配置如下（不要求读者完全匹配，可根据自己实际情况酌情处理）：</p><ul><li>K8s        版本 :  <strong>1.19.0</strong></li><li>Docker  版本：<strong>20.10.8</strong></li><li>CentOS 版本：<strong>7.7.1908</strong></li><li>Go SDK 版本：<strong>go1.16.6 linux/amd64</strong></li></ul><h1 id="3-项目设置"><a href="#3-项目设置" class="headerlink" title="3 项目设置"></a>3 项目设置</h1><p>&emsp;&emsp;进行 GO 项目开发一般需要两个步骤：</p><ul><li><p>创建项目根目录</p></li><li><p>设置 GOPATH</p></li></ul><h2 id="3-1-创建项目根目录"><a href="#3-1-创建项目根目录" class="headerlink" title="3.1 创建项目根目录"></a>3.1 创建项目根目录</h2><p>&emsp;&emsp;好的目录结构往往是项目成功的开始，执行下列命令创建项目根目录，以后所有 GO 项目开发都统一在此根目录之下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> /root/go 是项目的根目录</span><br>[root@jiuxi ~]# mkdir -p /root/go<br>[root@jiuxi ~]# mkdir -p /root/go/bin /root/go/src /root/go/pkg<br>[root@jiuxi ~]# tree /root/go<br>/root/go<br>├── bin<br>├── pkg<br>└── src<br><br>3 directories, 0 files<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;目录结构说明如下：</p><blockquote><p>bin: go 二进制可执行程序的存放路径，比如通过 go install 生成的代码</p><p>pkg: 项目开发过程中，三方依赖库的存放路径</p><p>src: 项目源码存放路径，一般我们编写的项目代码都放在此处</p></blockquote><h2 id="3-2-设置-GOPATH"><a href="#3-2-设置-GOPATH" class="headerlink" title="3.2 设置 GOPATH"></a>3.2 设置 GOPATH</h2><p>&emsp;&emsp;GO SDK 需要设置 GOROOT 环境变量，用来存储 GO SDK 的安装路径。</p><p>&emsp;&emsp;GO 项目开发需要设置 GOPATH 环境变量，用来存储 GO 项目的根目录。</p><p>&emsp;&emsp;编辑 /etc/profile 文件，在文件末尾添加如下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export GOPATH=/root/go<br>export PATH=$PATH:$GOPATH/bin<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;保存文件，然后在命令行执行如下命令使配置生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@jiuxi go]# source /etc/profile<br>[root@jiuxi go]# echo $GOPATH<br>/root/go<br></code></pre></td></tr></table></figure><p>如果执行结果如上所示，说明 GOPATH 设置成功。</p><h1 id="4-项目样例"><a href="#4-项目样例" class="headerlink" title="4 项目样例"></a>4 项目样例</h1><p>&emsp;&emsp;一切都准备就绪，可以写个小项目练练手了。</p><h2 id="4-1-创建项目"><a href="#4-1-创建项目" class="headerlink" title="4.1 创建项目"></a>4.1 创建项目</h2><p>&emsp;&emsp;执行如下命令创建 client-go-quick-start  项目，注意一定要在 $GOPATH/src 路径下创建。        </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@jiuxi go]# cd $GOPATH/src<br>[root@jiuxi src]# mkdir client-go-quick-start<br>[root@jiuxi src]# tree $GOPATH/src<br>/root/go/src<br>└── client-go-quick-start<br><br>1 directory, 0 files<br></code></pre></td></tr></table></figure><h2 id="4-2-编写代码"><a href="#4-2-编写代码" class="headerlink" title="4.2 编写代码"></a>4.2 编写代码</h2><p>&emsp;&emsp;在 client-go-quick-start 目录下创建 main.go 文件，内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println( <span class="hljs-string">&quot;client-go quick start tutorial&quot;</span> )<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-3-运行代码"><a href="#4-3-运行代码" class="headerlink" title="4.3 运行代码"></a>4.3 运行代码</h2><p>&emsp;&emsp;执行下面命令运行 main.go 程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@jiuxi client-go-quick-start]# go run main.go <br>client-go quick start tutorial<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;如果执行结果如上所示，说明程序运行正常，此时读者可以暂时放松一下，泡杯咖啡犒劳一下自己，因为从下节开始我们将正式开启 client-go 操作 K8S 旅程，请调整一下坐姿，我们发车了。</p>]]></content>
    
    
    <categories>
      
      <category>client-go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>client-go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>client-go 系列之一《go sdk 配置》</title>
    <link href="/2021/08/24/k8s%E5%BC%80%E5%8F%91%E4%B9%8Bclient-go%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E3%80%8AGO-SDK-%E8%AE%BE%E7%BD%AE%E3%80%8B/"/>
    <url>/2021/08/24/k8s%E5%BC%80%E5%8F%91%E4%B9%8Bclient-go%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E3%80%8AGO-SDK-%E8%AE%BE%E7%BD%AE%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>&emsp;&emsp;client-go 是官方提供的 go 语言客户端库，可以跟 K8S API Server 进行交互。如果开发者想对 K8S 进行二次开发，可直接拿来使用，不必重复造轮子。</p><p>&emsp;&emsp;client-go 已集成进 K8S 源码，所以 K8S 组件之间也采用 client-go 进行通信（例如 kubectl 操作 API Server）。client-go 在 K8S 源码中存放的路径是 vendor/k8s.io/client-go，如下图所示：</p><p><img src="/img/20210824190058.jpg" srcset="/img/loading.gif" lazyload alt="client-go 在 K8S 源码中的存放路径"></p><p>&emsp;&emsp;本系列文章会全方面介绍 client-go，包括快速上手、架构设计和源码剖析，在源码剖析章节会重点介绍 Informer 机制（此机制是 K8S 组件之间相互通信的基石）。</p><p>&emsp;&emsp;如果想真正学好 K8S，仅仅会操作是远远不够地，只有真实地触摸到代码底层，并实际了解其内部数据结构和运行机制，才能有“不畏浮云遮望眼，自缘身在最高层”的体悟。</p><h1 id="2-前提"><a href="#2-前提" class="headerlink" title="2 前提"></a>2 前提</h1><p>&emsp;&emsp;本系列文章并不要求读者一定具备 go 语言背景，考虑到大多数人的认知习惯，所以笔者采用了一种先易后难、循序渐进、层层铺垫的编写方式，当然如果碰上喜欢挑战、勤于练胆、不撞南墙就浑身不舒坦的读者，本教程依旧适合，您只需要从后往前读即可。</p><p>&emsp;&emsp;尽管本系列文章对读者的水平做到了最大程度的宽容，但如果想真切感受到程序运行带来的快感，建议还是配置 go sdk、go 项目开发环境和 K8S 运行环境。正所谓“<em>九层之台，起于累土；千里之行，始于足下</em>”，个人认为老子的话还是要听一听的。</p><p><img src="/img/20210824.jpg" srcset="/img/loading.gif" lazyload alt="老子与道"></p><h1 id="3-运行环境"><a href="#3-运行环境" class="headerlink" title="3 运行环境"></a>3 运行环境</h1><p>&emsp;&emsp;本系列所采用的环境信息如下（不要求读者完全匹配，可根据实际情况酌情处理，但建议 go sdk 版本不要过低）：</p><ul><li>K8S        版本 :  <strong>1.19.0</strong></li><li>Docker  版本：<strong>20.10.8</strong></li><li>CentOS 版本：<strong>7.7.1908</strong></li><li>GO SDK 版本：<strong>go1.16.6 linux/amd64</strong></li></ul><h1 id="4-GO-SDK-安装"><a href="#4-GO-SDK-安装" class="headerlink" title="4 GO SDK 安装"></a>4 GO SDK 安装</h1><p>&emsp;&emsp;安装步骤如下，如果读者已经安装过，可直接跳到下一章节继续阅读：</p><ul><li><p>下载和解压缩</p></li><li><p>设置环境变量</p></li><li><p>验证是否安装成功</p></li><li><p>配置包下载代理（可选但推荐）</p></li></ul><h2 id="4-1-下载和解压缩"><a href="#4-1-下载和解压缩" class="headerlink" title="4.1 下载和解压缩"></a>4.1 下载和解压缩</h2><p>&emsp;&emsp;在命令行执行如下指令下载和解压缩 GO SDK：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">cd</span> /opt</span> <br><span class="hljs-meta">#</span><span class="bash"> yum install -y wget</span><br><span class="hljs-meta">#</span><span class="bash"> wget https://golang.google.cn/dl/go1.16.6.linux-amd64.tar.gz</span><br><span class="hljs-meta">#</span><span class="bash"> tar -zxvf go1.16.6.linux-amd64.tar.gz -C /usr/<span class="hljs-built_in">local</span></span><br></code></pre></td></tr></table></figure><h2 id="4-2-设置环境变量"><a href="#4-2-设置环境变量" class="headerlink" title="4.2 设置环境变量"></a>4.2 设置环境变量</h2><p>&emsp;&emsp;编辑 /etc/profile 文件，在文件末尾添加下面内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">export GO111MODULE=on<br>export GOROOT=/usr/local/go<br>export PATH=$PATH:$GOROOT/bin<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;编辑保存后，在命令行执行如下语句使上面的配置生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">source</span> /etc/profile</span><br></code></pre></td></tr></table></figure><h2 id="4-3-验证是否安装成功"><a href="#4-3-验证是否安装成功" class="headerlink" title="4.3 验证是否安装成功"></a>4.3 验证是否安装成功</h2><p>&emsp;&emsp;安装完毕并设置好环境变量后，在命令行执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> go version</span><br>go version go1.16.6 linux/amd64<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;如果能正确显示 GO SDK 的版本（如上所示），则说明 SDK 安装成功。</p><h2 id="4-4-配置下载代理（可选但推荐）"><a href="#4-4-配置下载代理（可选但推荐）" class="headerlink" title="4.4 配置下载代理（可选但推荐）"></a>4.4 配置下载代理（可选但推荐）</h2><p>&emsp;&emsp;首先声明该步骤是可选的，但笔者强烈建议执行此步骤，因为在后面开发中会下载很多依赖包，如果采用默认代理，要么可能下载不到（具体原因，你懂的），要么下载速度巨慢，所以建议在命令行执行下面命令修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># GOPROXY=&quot;https://proxy.golang.org,direct&quot;</span></span><br><span class="hljs-meta">#</span><span class="bash"> go env GOPROXY</span><br><span class="hljs-meta">#</span><span class="bash"> go env -w GOPROXY=<span class="hljs-string">&quot;https://goproxy.io,direct&quot;</span></span><br><span class="hljs-meta">#</span><span class="bash"> go env GOPROXY</span><br>https://goproxy.io,direct<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;如果命令执行结果如上所示，表示修改成功，新代理路径已经改成 <a href="https://goproxy.io./">https://goproxy.io。</a></p><p>&emsp;&emsp;自此，整个 GO SDK 设置结束，读者可以进入到后续 GO 开发了。</p><h1 id="5-参考文献"><a href="#5-参考文献" class="headerlink" title="5 参考文献"></a>5 参考文献</h1><p>1 <a href="https://github.com/kubernetes/client-go">client-go 仓库</a> <a href="https://github.com/kubernetes/client-go">https://github.com/kubernetes/client-go</a></p>]]></content>
    
    
    <categories>
      
      <category>client-go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>client-go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式事务系列之二《事务》</title>
    <link href="/2021/08/14/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E3%80%8A%E4%BA%8B%E5%8A%A1%E3%80%8B/"/>
    <url>/2021/08/14/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E3%80%8A%E4%BA%8B%E5%8A%A1%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;上节介绍了单体架构，单体架构是整个漫长软件架构演进过程中使用人数最多、应用范围最广、也相对最稳定的一种架构。但随着业务多变、逻辑复杂性增加、交付时间越来越短，单体架构逐渐显出疲态，慢慢被分布式微服务架构所代替。</p><p>&emsp;&emsp;早期单体架构解决的核心问题是信息化，信息化处理的对象是数据，数据的质量直接影响到信息化的好坏。数据质量的判断有很多维度，其中最重要维度之一便是数据一致性。</p><h1 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h1><p>&emsp;&emsp;单纯的说教容易让人云里雾里，不妨举一个生活的例子。</p><p>&emsp;&emsp;我成长的年代还比较单纯，父母起名一般不会想太多。我至今记得一对男女同桌，女的叫做张开凤，男的叫做王里岛。下面就是他们的故事：</p><blockquote><p><strong>张开凤银行账户有 1000 块， 王里岛银行账户也有 1000 块</strong></p><p><strong>张开凤和王里岛相约进行爱的鼓掌，完事后，王里岛付给张开凤 200 块</strong></p><p><strong>张开凤现在账户里有 1200 块，而王里岛账户有 800 块</strong></p></blockquote><p>&emsp;&emsp;银行交易系统会执行如下语句：</p><blockquote><p><em><strong>update table account set savings = savings - 200 where name = “王里岛”</strong></em></p><p><em><strong>update table account set savings = savings + 200 where name = “张开凤”</strong></em></p></blockquote><p>&emsp;&emsp;如果交易系统执行第一条语句成功了，但在执行第二条语句的时候却失败了，那么张开凤就被白嫖了（但是王里岛是不会承认的，你仔细品一下）。</p><p>&emsp;&emsp;这真是一个悲伤的故事，悲剧的核心就在于数据不一致，碰到这样的事，作为一个有责任心的工程师是绝对不能坐视不理的。经过思考，我们发现该技术场景的痛点在于，如何保证一个事件序列的执行是原子的，即：要么全部执行成功，要么全部失败。</p><p><img src="/img/2021081402.png" srcset="/img/loading.gif" lazyload alt="02"></p><h1 id="事务定义"><a href="#事务定义" class="headerlink" title="事务定义"></a>事务定义</h1><p>&emsp;&emsp;事务想解决的本质问题就是数据状态的一致，有关事务的非官方定义如下：</p><ul><li><p>事务是操作数据源的程序（比如：一个事务可以是一条 SQL 语句，一组 SQL 语句或高级语言写的程序）</p></li><li><p>事务是一个不可分割的工作单元，单元内的操作要么全部执行成功，要么全部执行失败</p></li><li><p>事务是恢复和并发控制的基本单元</p></li></ul><h1 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h1><p>&emsp;&emsp;事务具有四个特征，这是小白面试时常被考的问题，教科书教导的顺序是 ACID（acid 中文翻译：酸）。笔者是个极其蠢笨的人，总是记不住，于是改良成 ICDA（中文翻译：爱操洞啊），就再没忘记过，这里冒死提供给读者，你们不用谢我。</p><blockquote><ul><li>I : isolation      （隔离性）。指一个事务内的事件序列执行时，不能被另外的事务所干扰</li><li>C: consistency（一致性）。指数据状态转换过程中必须是一致性</li><li>D: durability   （持久性）。指一旦事务提交之后，对数据库的改变就是永久的</li><li>A: atomic        （原子性）。指事务内的事件序列执行时是不可分割的，要么全部执行，要么都不执行</li></ul></blockquote><p>&emsp;&emsp;如果上面的学术解释让你昏昏欲睡，你可以换下面一种记法，结合“爱操洞啊”来理解，还是那句话，不用谢。</p><blockquote><ul><li>I : isolation      （隔离性）。I  就是“我”，世界上只有一个我，独一无二。所以本身具备隔离性、排他性</li><li>C: consistency（一致性）。C 就是“操”，操的对象必须一致，否则容易得病（你懂的）</li><li>D: durability   （持久性）。D 就是“洞”，面对洞一定要持久，这样她才会永远记得你（即使分手）</li><li>A: atomic        （原子性）。A  就是”啊“，高潮后发出的满足声音。要做就一定要高潮，否则就别做</li></ul></blockquote><p><img src="/img/2021081403.png" srcset="/img/loading.gif" lazyload alt="03"></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/9744607?fr=aladdin">事务百科</a> <a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/9744607?fr=aladdin">https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/9744607?fr=aladdin</a></li><li><a href="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fhbimg.b0.upaiyun.com%2F5ee7d275ed5f6adea8af216f4ae194ad0da7aa2d1a520-6askWI_fw658&refer=http%3A%2F%2Fhbimg.b0.upaiyun.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1631530265&t=40527bb540fa342f3c6211e57782423c">杜蕾斯图片</a> <a href="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fhbimg.b0.upaiyun.com%2F5ee7d275ed5f6adea8af216f4ae194ad0da7aa2d1a520-6askWI_fw658&amp;refer=http%3A%2F%2Fhbimg.b0.upaiyun.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1631530265&amp;t=40527bb540fa342f3c6211e57782423c">https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fhbimg.b0.upaiyun.com%2F5ee7d275ed5f6adea8af216f4ae194ad0da7aa2d1a520-6askWI_fw658&amp;refer=http%3A%2F%2Fhbimg.b0.upaiyun.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1631530265&amp;t=40527bb540fa342f3c6211e57782423c</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式事务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式事务系列之一《单体架构》</title>
    <link href="/2021/08/14/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E3%80%8A%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E3%80%8B/"/>
    <url>/2021/08/14/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E3%80%8A%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;分布式事务目标是解决数据一致性问题。在整个波澜壮阔的计算机科技发展史上，分布式事务并非一开始就存在，它只是历史发展的产物，随着软、硬件架构的不断更迭和演进才逐步发展起来的。</p><p>&emsp;&emsp;我还记得那是一个夏天，窗外鸟语花香，空气中满是新鲜和幸福的味道。那时路上还没有那么多车，苏堤远没有现在人流如织。在那个还流淌着小资的年代，软件从业者是小众的文艺小清新，也就在那时，我怀揣着改造世界的憧憬，莽撞地踏进了计算机的世界。</p><p>&emsp;&emsp;那时，世界远没有现在复杂，人心还没有那么险恶。我们没有微信、没有抖音、没有996、更没有内卷。我们悠闲地带耳机听着音乐、喝着咖啡。我们充满希望，用代码编织着内心的向往和美丽的梦。</p><p>&emsp;&emsp;那时，我们没有微服务，没有分布式，更没有分布式事务。我们只写单体……</p><p><img src="/img/2021081401.png" srcset="/img/loading.gif" lazyload alt="致敬那消失不再有的文艺时代"></p><h1 id="单体架构定义"><a href="#单体架构定义" class="headerlink" title="单体架构定义"></a>单体架构定义</h1><p>&emsp;&emsp;在网上找了很多的资料，不知道是不是因为单体架构简单到让人忽略的缘故，竟然很难找到官方定义或词条解释。但或许人类的认知都是从定义事物开始，所以我们不得不把搜寻的目光从官方转回到民间找寻答案，于是便有了下面的蹩脚英文定义：</p><blockquote><p><strong>What is a Monolith i.e. a monolithic architecture ?</strong></p><p><em>A monolithic application</em>, let’s call it a <em>Monolith</em>, is an application delivered via a single deployment unit. Examples could be an application delivered as single WAR or a Node application with a single entrypoint.</p></blockquote><p>&emsp;&emsp;翻译过来就是：</p><blockquote><p><strong>什么是单体应用/架构 ？</strong></p><p><em>单体应用（俗称巨石系统），是整体交付、统一部署的一类应用。比如通过 War 或者 node 部署的具有单一访问入口的应用</em></p></blockquote><p>&emsp;&emsp;分析上面非官方的定义，我们可以得出单体架构的特点：原子性。基于单体架构的应用都是原子而不可再分的，无论是交付还是部署，都必须作为一个统一的整体。</p><h1 id="单体架构分层"><a href="#单体架构分层" class="headerlink" title="单体架构分层"></a>单体架构分层</h1><p>&emsp;&emsp;上面我们定义了单体架构，但是通过定义，很容易会让我们产生认知错误，即：单体架构应用是简单的、缺乏层次的、由数据结构和算法堆积起来的、架构不友好的应用。</p><p>&emsp;&emsp;我承认，单体架构早期阶段确实是用血泪书写的。那时项目缺乏规范，从业者缺少指导，开发者又生猛异常。技术处理，多的是血性，少的是敬畏。在那个没有 bug，只有事故的年代，只要你敢乱来，就没有攻不破的系统。在笔者的亲身经历中就有幸经历过几个“生死”瞬间，为了不招惹是非，特隐去公司名。</p><blockquote><p>事故一：因为不合理的修改导致股票系统出问题，结果开发被能征惯战的东北股民问候了家长</p><p>事故二：因为电信出账单计算错误，贵州某地电信用户直接在营业厅上演平民版导火线</p><p>事故三：国内某电商支付公司早期秒杀业务，因为并发控制没控制好，导致手机被疯抢</p></blockquote><p>&emsp;&emsp;即使不出事故和故障，单体架构系统体量也足可以庞大到惊人，从编译到运行往往持续几十分钟，加一个 print 调试逻辑，一根烟都抽完了，结果却跑不出来。写到这里，笔者不禁停下来莞尔，过往经历犹如走马灯般在回忆中被解放。真怀念那个没有流程图、没有章法、信马由缰、涂鸦般的编码年代，一切都是那么“云原生”。每当黑黢黢的控制台颤悠悠显示出 XXX successful 字样时，那种赌徒般、大难不死的幸福感油然而生。</p><p>&emsp;&emsp;历史总是反复，而科技永远向前。技术最不愿放过的就是“痛点”，伴随着解决一个痛点，又生出一堆新的痛点 :-)。</p><p>&emsp;&emsp;工程师们被随心所欲的开发模式搞得苦不堪言，软件大师也被腐败不堪的技术负债搞得斯文扫地。于是大家围炉而坐，痛定思痛反省解决方案。终于，一切尘埃落定，“分层”腾空出世。从业务或职能（视图、控制、模型）等维度对单体应用进行分层，分层后的系统焕然一新，可维护性大幅提高。</p><p>&emsp;&emsp;分层架构模式如下图所示：</p><p><img src="/img/20210823174649.jpg" srcset="/img/loading.gif" lazyload alt="分层架构"></p><p>&emsp;&emsp;这样的分层架构模式一直延续至今，大名鼎鼎的 MVC 架构模式就脱胎于此，即便已经步入微服务时代，它依旧经典，依旧璀璨。</p><h1 id="单体架构部署"><a href="#单体架构部署" class="headerlink" title="单体架构部署"></a>单体架构部署</h1><p>&emsp;&emsp;单体架构应用因为原子性，不得不在单一进程空间，所有模块以及方法调用都不用考虑远程调用和网络。这样的部署、运行和访问方式简单、高效，出错的几率小，但同时也带来了隔离难、内存泄漏以及升级/扩展困难等不足。</p><p>&emsp;&emsp;下图是经典单体架构应用部署图：</p><p><img src="/img/20210823174716.jpg" srcset="/img/loading.gif" lazyload alt="单体架构"></p><h1 id="单体架构优点"><a href="#单体架构优点" class="headerlink" title="单体架构优点"></a>单体架构优点</h1><p>&emsp;&emsp;单体架构应用有很多优点：</p><ul><li>易于开发和调试：IDE（无论是本地还是云端）都天然支持单体架构应用的开发和调试</li><li>易于部署和运行：只需要在支持的运行时（Runtime）上部署交付组件即可（比如 war 包）</li><li>易于横向扩缩容：只需要通过在负载均衡器（比如 Nginx）后增加单体架构应用的多个副本即可</li></ul><h1 id="单体架构不足"><a href="#单体架构不足" class="headerlink" title="单体架构不足"></a>单体架构不足</h1><p>&emsp;&emsp;单体架构应用也有很多不足：</p><ul><li>复杂性高：所有代码在同一代码空间，即使分层，随着时间推移也会变得越来越庞大和复杂</li><li>全量部署：每次功能迭代或缺陷修复都需要部署整个应用。全量部署耗时长、影响范围广、风险高</li><li>隔离性差：整个单体架构应用依赖于相同运行环境。一旦某个模块出错，可能导致整个系统崩溃</li><li>垂直扩缩容成本高：遵从木桶理论。即使只有一个模块性能出现短板，也要求全量扩容</li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://programmerfriend.com/monolith-vs-microservices/">单体和微服务</a> <a href="https://programmerfriend.com/monolith-vs-microservices/">https://programmerfriend.com/monolith-vs-microservices/</a></li><li><a href="http://icyfenix.cn/architecture/architect-history/monolithic.html">凤凰架构</a> <a href="http://icyfenix.cn/architecture/architect-history/monolithic.html">http://icyfenix.cn/architecture/architect-history/monolithic.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式事务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
