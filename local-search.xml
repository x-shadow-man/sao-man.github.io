<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - 网关 gateway 实例</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-%E7%BD%91%E5%85%B3-gateway-%E5%AE%9E%E4%BE%8B/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-%E7%BD%91%E5%85%B3-gateway-%E5%AE%9E%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 Istio 网关介绍</p><p>4 Istio 网关实例资源</p><p>  4.1 k8s 服务资源</p><p>  4.2 k8s deployment 资源</p><p>  4.3 Istio virtual service 资源</p><p>  4.4 Istio gateway 资源</p><p>5 istio-ingressgateway 配置</p><p>  5.1 修改 istio-ingressgateway 服务类型</p><p>  5.2 修改 istio-ingressgateway 网络命名空间配置</p><p>​    5.2.1 开启 istio-ingressgateway 容器 80、443 端口</p><p>​    5.2.2 将容器网络空间绑定宿主机网络空间</p><p>6 部署 Istio 资源</p><p>7 访问 istio 网关</p><p>8 总结</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589788560717573.png" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_Docker"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589788568456395.png" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio virtual servi_02"></p><hr><h1 id="3-Istio-网关介绍"><a href="#3-Istio-网关介绍" class="headerlink" title="3 Istio 网关介绍"></a>3 Istio 网关介绍</h1><p>​    在前面的 Istio 系列文章中轻松完爆了 Virtual Service、Destination Rule 等，同时也介绍了网格的概念（Service Mesh，资源被 Istio 注入，在 Pod 中创建并运行了一个 Istio-proxy 容器，该容器内部运行 Envoy  代理）。在本小节将轻松完爆 Istio 网关（gateway）。</p><p>​    Istio  使用网关来管理网格边缘流量（即：入站和出站流量），明确地说是 istio-ingressgateway  管理网格的入口流量，istio-egressgateway 管理网格的出口流量。在以前的章节中，我们了解网格的流量只所以可被管理，是因为资源被  istio 注入后在 Pod 中创建并运行了 istio-proxy 容器的缘故。而网关流量管理的本质也基于同样道理，唯一不同的是  istio-ingressgateway 和 istio-egressgateway 运行时就是一个 istio-proxy 容器，即独立的  Envoy 代理，而不是与 pod 一起运行的 sidecar Envoy 代理。</p><p>​    与其他控制进入系统的流量机制（例如：K8S Ingress API ）不同，Istio 网关充分利用了 Istio 流量路由的功能和灵活性。因为 Istio 的网关资源仅配置 4-6  层负载平衡属性，例如要公开的 port 和 tls 设置等，而将 L7 层（即应用层）流量路由使用 Istio 虚拟服务（virtual  service）绑定网关来实现，这样的一番神操作就可以像管理 Istio 网格中的任何其他数据平面流量一样，来管理网关流量。</p><p>​    k8s ingress 资源如下图所示：</p><p><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio virtual servi_03"><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589788579365947.png" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio traffic manag_04"></p><p>​    由上图可知，在 Ingress 层直接就实现了流量管理。</p><p>​    istio gateway 资源如下图所示：</p><p><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio virtual servi_03"><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589788588283935.png" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio gateway_06"></p><p>​    由上图可知，istio gateway 并不像 k8s ingress 一样直接在网关层实现流量路由，而是通过 virtual service  绑定到网关的机制实现流量路由，这样的方式就像将 virtual service 跟 gateway 解耦一样，大家各司其职。gateway  的作用就是分流，而 virtual service 的作用就是将分流来的流量进行管理。</p><p>​    virtual service 资源如下图所示：</p><p><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio virtual servi_03"><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589788596424833.png" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio traffic manag_08"></p><hr><h1 id="4-Istio-网关实例资源"><a href="#4-Istio-网关实例资源" class="headerlink" title="4 Istio 网关实例资源"></a>4 Istio 网关实例资源</h1><p>​    该实例需要如下四个资源文件，前两个资源是 Istio 专有的，后两个是 k8s 层面的：</p><blockquote><p>jiuxi-gw.yaml        # 网关资源</p><p>jiuxi-vs.yaml        # 虚拟服务资源</p><p>jiuxi-svc.yaml        # k8s 服务资源</p><p>jiuxi-deploy.yaml    # k8s deployment 资源</p></blockquote><h2 id="4-1-k8s-服务资源"><a href="#4-1-k8s-服务资源" class="headerlink" title="4.1 k8s 服务资源"></a>4.1 k8s 服务资源</h2><p><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio virtual servi_03"><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589788605151298.png" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio traffic manag_10"></p><h2 id="4-2-k8s-deployment-资源"><a href="#4-2-k8s-deployment-资源" class="headerlink" title="4.2 k8s deployment 资源"></a>4.2 k8s deployment 资源</h2><p><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio virtual servi_03"><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589788613855533.png" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio traffic manag_12"></p><h2 id="4-3-Istio-virtual-service-资源"><a href="#4-3-Istio-virtual-service-资源" class="headerlink" title="4.3 Istio virtual service 资源"></a>4.3 Istio virtual service 资源</h2><p><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio virtual servi_03"><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589788623896776.png" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio 流量管理_14"></p><h2 id="4-4-Istio-gateway-资源"><a href="#4-4-Istio-gateway-资源" class="headerlink" title="4.4 Istio gateway 资源"></a>4.4 Istio gateway 资源</h2><p><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio virtual servi_03"><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589788633797421.png" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio traffic manag_16"></p><p>​    自此，整个网关运行需要的资源文件已经编写完毕。</p><hr><h1 id="5-istio-ingressgateway-配置"><a href="#5-istio-ingressgateway-配置" class="headerlink" title="5 istio-ingressgateway 配置"></a>5 istio-ingressgateway 配置</h1><h2 id="5-1-修改-istio-ingressgateway-服务类型"><a href="#5-1-修改-istio-ingressgateway-服务类型" class="headerlink" title="5.1 修改 istio-ingressgateway 服务类型"></a>5.1 修改 istio-ingressgateway 服务类型</h2><p>​    默认情况下，istio-ingressgateway 的 k8s 服务类型是 LoadBalancer，因为 LoadBalancer 服务类型一般针对的是云服务商，所以使用基于 NodePort 的 k8s 服务方式。</p><p>​    使用如下命令修改 istio-ingressgateway 服务类型：</p><blockquote><p>kubectl patch svc -n istio-system istio-ingressgateway -p ‘{“spec”: {“type”: “NodePort”}}’</p></blockquote><h2 id="5-2-修改-istio-ingressgateway-网络命名空间配置"><a href="#5-2-修改-istio-ingressgateway-网络命名空间配置" class="headerlink" title="5.2 修改 istio-ingressgateway 网络命名空间配置"></a>5.2 修改 istio-ingressgateway 网络命名空间配置</h2><h3 id="5-2-1-开启-istio-ingressgateway-容器-80、443-端口"><a href="#5-2-1-开启-istio-ingressgateway-容器-80、443-端口" class="headerlink" title="5.2.1 开启 istio-ingressgateway 容器 80、443 端口"></a>5.2.1 开启 istio-ingressgateway 容器 80、443 端口</h3><p>​    使用 kubectl edit deployment -n istio-system istio-ingressgateway 指令编辑资源配置，添加 istio-proxy 容器对外服务端口 80 和 443，截图如下所示：</p><p><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio virtual servi_03"><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589788649368734.png" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio 流量管理_18"></p><h3 id="5-2-2-将容器网络空间绑定宿主机网络空间"><a href="#5-2-2-将容器网络空间绑定宿主机网络空间" class="headerlink" title="5.2.2 将容器网络空间绑定宿主机网络空间"></a>5.2.2 将容器网络空间绑定宿主机网络空间</h3><p>​    执行此步是因为 istio gateway 资源指定名为 jiuxi-gw 的 host 端口为 80，而上面 istio-ingressgateway 的  NodePort 服务端口默认只能处于 30000 ~ 32767 之间，所以基于“jiuxi-gw：NodePort”方式是无法访问到  istio gateway 的。如果要直接通过 istio gateway 访问，需要开放 istio-ingressgateway pod 的 hostNetwork 配置项：</p><p>​    使用 kubectl edit deployment -n istio-system istio-ingressgateway 指令编辑资源配置：</p><p><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio virtual servi_03"><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589788660219227.png" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio gateway_20"></p><p>​    修改完毕后，执行如下命令查看 istio-ingressgateway pod 所在宿主机 IP：</p><p><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio virtual servi_03"><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589788676122086.png" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio virtual servi_22"></p><p>​    ssh 登录宿主机 IP（本人是 10.110.101.203），执行如下指令验证是否宿主机开启了 80 端口：</p><p><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio virtual servi_03"><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589788686108792.png" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio gateway_24"></p><hr><h1 id="6-部署-Istio-资源"><a href="#6-部署-Istio-资源" class="headerlink" title="6 部署 Istio 资源"></a>6 部署 Istio 资源</h1><p>​    执行如下语句部署前面创建的 4 个 Istio 资源：</p><blockquote><p>kubectl apply -f .</p></blockquote><p>​    执行结果如下图所示：</p><p><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio virtual servi_03"><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589788693327159.png" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_Docker_26"></p><hr><h1 id="7-访问-istio-网关"><a href="#7-访问-istio-网关" class="headerlink" title="7 访问 istio 网关"></a>7 访问 istio 网关</h1><p>​    随便找一台虚拟机，编辑 /etc/hosts 文件，添加 istio-ingressgateway pod 所在主机映射：</p><p><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio virtual servi_03"><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1589788702452360.png" srcset="/img/loading.gif" lazyload alt="第三十章 九析带你轻松完爆 Istio - 网关 gateway 实例_istio gateway_28"></p><p>​    映射内容如下：</p><blockquote><p>10.110.101.203 jiuxi.gw.org</p></blockquote><p>​    使用 curl 命令行访问 jiuxi.gw.org，发现基于 gateway 的流量管理已经生效（即：负载均衡权重为 50 - 50）。</p><hr><h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8 总结"></a>8 总结</h1><p>​    在 istio 中，有关 istio-ingressgateway、gateway、virtual service 和 destination rule 之间的关系很容易让大家引起混淆。其实你不妨这么来理解：</p><p>​    istio-ingressgateway 作用就像飞机场的出口，这里承载了所有的流量；gateway 作用就像旅行社，起到了分流的作用；virtual service  指旅行社的导游，起到了对分流后的流量进行管理和路由的作用；而 destination rule 就像导游指派的大巴一样，将 vs  的流量路由到真正的地方去。</p><p>​    自此，九析带你们轻松完爆了 Istio 的 gateway。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - 网络流向之 iptables chain</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-%E7%BD%91%E7%BB%9C%E6%B5%81%E5%90%91%E4%B9%8B-iptables-chain/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-%E7%BD%91%E7%BB%9C%E6%B5%81%E5%90%91%E4%B9%8B-iptables-chain/</url>
    
    <content type="html"><![CDATA[<p> 前言</p><p>2 邀约</p><p>3 正文</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>​    如果你对博客有任何疑问，请告诉我。<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587895000811110.png" srcset="/img/loading.gif" lazyload alt="第二十九章 九析带你轻松完爆 Istio - 网络流向之 iptables chain_istio 视频"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587895007995640.png" srcset="/img/loading.gif" lazyload alt="第二十九章 九析带你轻松完爆 Istio - 网络流向之 iptables chain_k8s 视频_02"></p><hr><h1 id="3-正文"><a href="#3-正文" class="headerlink" title="3 正文"></a>3 正文</h1><p>​    一切都是那么明亮，光线照在身上，暖暖的。</p><p>​    仰起头，依稀能听到风声。庭院里早春的鸟儿在围墙上啁啾，三五个下人在打扫着庭院，丫鬟婆子们在天井嗑着瓜子闲聊天，嬉笑声惊动了房脊上的信鸽，扑棱棱扇动双翅滑向远处湛蓝的天空……</p><p>​    我是刘全，和府的总管。外表虽然光鲜，实质却仍是一个仆人。我清楚知道自己的身份，每天小心谨慎、兢兢业业、如履薄冰般尽忠职守，日复一日、年复一年。</p><p>​    很多人背后指责我狐假虎威、狗仗人势，我不解释也不能解释。我明白很多脏活必须我来做，很多坏人必须我来当。我必须做到多面，这是我的工作，更是我的天职。我知道太多讳莫如深、彼此心知肚明、但又不能点破说破的潜规则，我只能自己默默消化。我不被人理解，我习惯了。很多时候我都必须像鹰一般敏锐注视整个府邸的动态，并时时保持警惕，我不能有一丝疏漏，我不能让大人为难。</p><p>​    一切波澜不惊之下往往隐藏着狂流暗涌。</p><p>​    庞大帝国的中枢体系并不在黄墙之内，而是尽在府邸之中。1300 万平方公里疆域的数据全部汇集于此，并在此处做流转、做分发。咫尺便是天涯、天涯又近在咫尺。</p><p>​    每天这里都在上演国泰民安、妻离子散；朔漠狼烟、塞外江南……</p><p>​    我观望、处理、不带感情。晨钟暮鼓、安之若素。</p><p>​    繁重的工作并没有将我压垮，因为我并不是一个人……</p><p>​    我的用人标准很简单：少而精、懂协作。基于此，经过层层筛选和选拔，最后我把目光锁定在五个人身上（扑入锐、英扑特、鳌扑特、佛卧德、剖思特），这五个人各司其职，协调和控制整个帝国信息流的脉络走向。</p><blockquote><p>扑入锐：奏折入口。核查奏折是否跟和府有关。如果跟和府有关则将奏折转给英扑特。</p><p>英扑特：接收来自扑入锐的奏折，并做规则检查，通过的奏折转给和府内部事务部门处理</p><p>熬扑特：接受和府内部事务部门写的奏折或者批示英扑特递交的折子，并做规则检查，检查并处理完毕后交给剖思特。</p><p>佛卧德：接受来自扑入锐的奏折，这些奏折表面跟和府无关，经过规则检查之后，直接转给剖思特。</p><p>剖思特：接受来自鳌扑特和佛卧德的奏折，并做规则检查。处理完把它们送到该送的地方去。</p></blockquote><p>​    整个数据信息流的处理极其缜密。我将他们紧紧编制在我设计的链条里。我观察着他们，规范着他们的一举一动。每天我都要把这一幕幕绘制成图，然后牢牢地印在我的脑海里。<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587894981198101.png" srcset="/img/loading.gif" lazyload alt="第二十九章 九析带你轻松完爆 Istio - 网络流向之 iptables chain_istio 视频_03"></p><p>============================================================================</p><p>​    数据在主机中的具体流向，一般会有三种路径：</p><blockquote><p>第一：数据报文通过网络、流经网卡、进入主机。经过检查，数据报文目标如果是本机，则将报文送到用户空间中的相关进程进行处理。</p><p>第二：数据报文通过网络、流经网卡、进入主机。经过检查，数据报文目标如果不是本机，则将报文直接通过网卡再发送到其他主机</p><p>第三：用户空间的进程产生数据报文，并将此报文通过内核空间的网络协议栈发送给网卡，再通过网卡把数据报文发送给其他主机</p></blockquote><p>​    如果数据只是在主机里流來流去，而不施加任何规则的话，世界就不会这么复杂。但是往往事与愿违，如果有人要恶意破坏系统怎么办呢？</p><p>​    就像刘全为了避免不利于和府的奏折流到皇上那里而设置五人关卡一样。linux 也采用了同样的机制来控制数据流，更为巧合地是，也是五道关卡。</p><blockquote><p>prerouting（扑入锐）</p><p>input（英扑特）</p><p>forward（佛卧德）</p><p>output（鳌扑特）</p><p>postrouting（剖思特）</p></blockquote><p>​    iptables 通过在上述五道关卡上设置更多的规则来对主机中流动的数据做流向控制。数据流向图如下所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587894989758506.png" srcset="/img/loading.gif" lazyload alt="第二十九章 九析带你轻松完爆 Istio - 网络流向之 iptables chain_istio 视频_04"></p><p>​    未完待续……</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - 网络包之 iptables netfilter 关系</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-%E7%BD%91%E7%BB%9C%E5%8C%85%E4%B9%8B-iptables-netfilter-%E5%85%B3%E7%B3%BB/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-%E7%BD%91%E7%BB%9C%E5%8C%85%E4%B9%8B-iptables-netfilter-%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 正文</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>​    如果你对博客有任何疑问，请告诉我。<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587698518570214.png" srcset="/img/loading.gif" lazyload alt="第二十八章 九析带你轻松完爆 Istio - 网络包之 iptables netfilter 关系_k8s iptables"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587698527213780.png" srcset="/img/loading.gif" lazyload alt="第二十八章 九析带你轻松完爆 Istio - 网络包之 iptables netfilter 关系_iptables_02"></p><hr><h1 id="3-正文"><a href="#3-正文" class="headerlink" title="3 正文"></a>3 正文</h1><p>​    淅淅沥沥的雨不像下在外面，而是下在心里。</p><p>​    清秀的男人推开重重的府门，外面的光线一点点透进去，就像蹑手蹑脚的小偷，悄无声息。空间中有潮湿木头腐朽的味道，男人微皱一下浓眉。</p><p>​    房间本是宽敞，却被大大小小的箱子叠床架屋，所以显得异常逼仄。箱子质地坚硬结实，仿佛从纹理就能看出里面的价值。有些锁已经有了锈的痕迹，但却依然古色古香。</p><p>​    雨声似乎大了些，淅淅沥沥打在青石板的门阶上。男人透过门缝瞥了瞥远方，挡住视线的是一幢一幢的深不可测的门房。</p><p>​    这里曾经风雨西窗，这里也曾衰草枯杨……</p><p>​    男人收回目光，垂下眼睑，沉浸在一片静穆之中。</p><p>​    远远的脚步声近了，门被打开又被迅速关上。一个俊俏的小厮满脸笑容又恭恭敬敬地靠近。</p><p>​    老爷，这是新纳贡的单子。</p><blockquote><p>山东府台跟我们素有不合，他上贡皇上的礼品我统一给挡了。</p><p>福建的礼品有些我觉得老佛爷不喜欢，就暂放在老爷的府上，其它我觉得合适的就送上去了。</p><p>两江总督的进献的礼品太过豪奢，恐圣上震怒伤了身子，我全部都先扣下来暂存在老爷府上等待发落。</p><p>……</p></blockquote><p>​    男人一言不发，似乎注意力全不在这里。他对小厮做事绝对是放心的。自从他当了总管之后，大大小小的规则都是他制定的。一次疏忽或纰漏都不曾有过。男人此刻心中所想到底是什么，恐怕只有他自己知道。</p><p>============================================================================</p><p>​    男人叫和珅、小厮叫刘全。</p><p>​    和珅是帝国的柱石，它是整个帝国系统的“安全框架”，他深不可测，位于整个系统的内核空间，不可直接触达，他掌握整个帝国的数据走向。</p><p>​    刘全是和珅的代理。他是和珅的心腹，为和珅出谋划策、制定一系列的事情处理规则。他不处于高墙之内，仅浮沉在市井的用户空间，却具有跟内核态打交道的能力。</p><p>============================================================================</p><p>​    和珅就像 linux 内核中的 netfilter 安全框架，而刘全就是 netfilter 的客户端代理工具 iptables。通过刘全，可以将相应的规则作用在和珅之上。</p><p>​    netfilter 是 linux 操作系统核心层的一个数据包处理模块，主要功能如下：</p><blockquote><p>数据包过滤功能</p><p>数据包内容修改</p><p>数据包网络地址转换（NAT，net address translate）</p></blockquote><p>​    iptables 则是一个客户端工具，可以通过 iptables 制定一系列的规则，最终作用在 netfilter 之上，起到发挥 netfilter 功能，控制数据包流向与控制的作用。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - k8s 流量进入集群之 Ingress</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-k8s-%E6%B5%81%E9%87%8F%E8%BF%9B%E5%85%A5%E9%9B%86%E7%BE%A4%E4%B9%8B-Ingress/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-k8s-%E6%B5%81%E9%87%8F%E8%BF%9B%E5%85%A5%E9%9B%86%E7%BE%A4%E4%B9%8B-Ingress/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 Ingress 介绍</p><p>4 ingress 实例</p><p>  4.1 ingress 资源文件</p><p>  4.2 service 资源文件</p><p>  4.3 pod 资源文件</p><p>5 访问 ingress</p><p>  5.1 获取 ingress HOST</p><p>  5.2 域名解析绑定</p><p>  5.3 访问 ingress</p><p>6 结论</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>​    如果你对博客有任何疑问，请告诉我。<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587613783382115.png" srcset="/img/loading.gif" lazyload alt="第二十七章 九析带你轻松完爆 Istio - k8s 流量进入集群之 Ingress_k8s 视频"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587613790304553.png" srcset="/img/loading.gif" lazyload alt="第二十七章 九析带你轻松完爆 Istio - k8s 流量进入集群之 Ingress_ingress-controller_02"></p><hr><h1 id="3-Ingress-介绍"><a href="#3-Ingress-介绍" class="headerlink" title="3 Ingress 介绍"></a>3 Ingress 介绍</h1><p>​    Ingress 中文含义就是“入口”，非常形象地定义了这种资源的本质：Ingress 就是 k8s 的门户。</p><p>​    就像一幢建筑物，比如酒店、商场等，不止一个入口，k8s 也可以定义多个入口放流量进来。</p><p>​    k8s 集群必须部署一个 Ingress 控制器（比如 nginx、traefik 等），Ingress 控制器的作用就是创建 Ingress  资源，好让其生效。Ingress 控制器跟 Ingress 的关系就像 nginx 跟 nginx.conf( nginx 配置文件) 一样。</p><p>​    Ingress 控制器容器内一般有两个关键的进程，分别是一个负载均衡器（比如 nginx、haproxy 等）和一个控制器守护进程。控制器守护进程会从 k8s 接收所需的 Ingress 创建需求，并将其生成一个 nginx 或 haproxy 的配置片段，并重新加载负载均衡器来使其生效。</p><p>​    就拿 nginx-ingress-controller 举例，nginx 是 nginx-ingress-controller 内部进程，也是其负载均衡器，而 nginx-ingress-controller 是 k8s 的负载均衡器。</p><p>nginx-ingress-controller 内部进程截图如下所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587613800164339.png" srcset="/img/loading.gif" lazyload alt="第二十七章 九析带你轻松完爆 Istio - k8s 流量进入集群之 Ingress_k8s 视频_03"></p><hr><h1 id="4-ingress-实例"><a href="#4-ingress-实例" class="headerlink" title="4 ingress 实例"></a>4 ingress 实例</h1><p>​    如果要展示 ingress 实例，需要三个资源文件：</p><blockquote><p>1 ingress 流量入口资源文件</p><p>2 service 流量从入口进入后的流向资源文件</p><p>3 pod 流量最终目的地资源文件</p></blockquote><h2 id="4-1-ingress-资源文件"><a href="#4-1-ingress-资源文件" class="headerlink" title="4.1 ingress 资源文件"></a>4.1 ingress 资源文件</h2><p><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第二十七章 九析带你轻松完爆 Istio - k8s 流量进入集群之 Ingress_k8s 视频_04"><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587613808888408.png" srcset="/img/loading.gif" lazyload alt="第二十七章 九析带你轻松完爆 Istio - k8s 流量进入集群之 Ingress_k8s 视频_05"></p><h2 id="4-2-service-资源文件"><a href="#4-2-service-资源文件" class="headerlink" title="4.2 service 资源文件"></a>4.2 service 资源文件</h2><p><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第二十七章 九析带你轻松完爆 Istio - k8s 流量进入集群之 Ingress_k8s 视频_04"><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587613813933169.png" srcset="/img/loading.gif" lazyload alt="第二十七章 九析带你轻松完爆 Istio - k8s 流量进入集群之 Ingress_ingress-controller_07"></p><h2 id="4-3-pod-资源文件"><a href="#4-3-pod-资源文件" class="headerlink" title="4.3 pod 资源文件"></a>4.3 pod 资源文件</h2><p><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第二十七章 九析带你轻松完爆 Istio - k8s 流量进入集群之 Ingress_k8s 视频_04"><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587613818578144.png" srcset="/img/loading.gif" lazyload alt="第二十七章 九析带你轻松完爆 Istio - k8s 流量进入集群之 Ingress_ingress-controller_09"></p><hr><h1 id="5-访问-ingress"><a href="#5-访问-ingress" class="headerlink" title="5 访问 ingress"></a>5 访问 ingress</h1><h2 id="5-1-获取-ingress-HOST"><a href="#5-1-获取-ingress-HOST" class="headerlink" title="5.1 获取 ingress HOST"></a>5.1 获取 ingress HOST</h2><p>​    上面介绍了 nginx-ingress-controller 其实就是 k8s 的负载均衡器，或者说 nginx-ingress-controller  就是 k8s 的 nginx。那么 nginx-ingress-controller pod 所在宿主机地址就是 k8s  的入口地址。如下截图所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587613823485947.png" srcset="/img/loading.gif" lazyload alt="第二十七章 九析带你轻松完爆 Istio - k8s 流量进入集群之 Ingress_k8s ingress_10"></p><p>​    因为我的 nginx-ingress-controller pod 直接采用的是 hostNetwork: true，也就是使用了宿主机的网络命名空间。因此这里的 Pod IP 就是宿主机的 IP，也就是说访问的时候可以直接使用此 IP。</p><h2 id="5-2-域名解析绑定"><a href="#5-2-域名解析绑定" class="headerlink" title="5.2 域名解析绑定"></a>5.2 域名解析绑定</h2><p>​    编辑 /etc/hosts（centos）文件，添加域名解析定义：</p><blockquote><p>10.110.101.100    ingress.jiuxi.org</p></blockquote><h2 id="5-3-访问-ingress"><a href="#5-3-访问-ingress" class="headerlink" title="5.3 访问 ingress"></a>5.3 访问 ingress</h2><p>​    执行如下命令访问 ingress：</p><blockquote><p>curl <a href="http://ingress.jiuxi.org/"> http://ingress.jiuxi.org</a></p></blockquote><p>​    命令执行结果如下所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587613831548777.png" srcset="/img/loading.gif" lazyload alt="第二十七章 九析带你轻松完爆 Istio - k8s 流量进入集群之 Ingress_nginx-ingress-contr_11"></p><hr><h1 id="6-结论"><a href="#6-结论" class="headerlink" title="6 结论"></a>6 结论</h1><p>​    使用 nodeport、loadbalancer 跟 ingress 在实现路由方式上有所不同。对于 loadbalancer 和  nodeport，都是将流量导入到节点上的 kube-proxy 进程，后者再将流量转发到后面的 pod。而 Ingress  负载均衡器则将流量直接转发到选定的 Pod，这样效率更高。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - k8s 流量进入集群之 NodePort</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-k8s-%E6%B5%81%E9%87%8F%E8%BF%9B%E5%85%A5%E9%9B%86%E7%BE%A4%E4%B9%8B-NodePort/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-k8s-%E6%B5%81%E9%87%8F%E8%BF%9B%E5%85%A5%E9%9B%86%E7%BE%A4%E4%B9%8B-NodePort/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 NodePort 样例</p><p>4 访问流程</p><p>5 实例演示</p><p>6 缺点</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>​    如果你对博客有任何疑问，请告诉我。<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587550119779184.png" srcset="/img/loading.gif" lazyload alt="第二十六章 九析带你轻松完爆 Istio - k8s 流量进入集群之 NodePort_k8s 视频"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587550126151290.png" srcset="/img/loading.gif" lazyload alt="第二十六章 九析带你轻松完爆 Istio - k8s 流量进入集群之 NodePort_k8s nodeport_02"></p><hr><h1 id="3-NodePort-样例"><a href="#3-NodePort-样例" class="headerlink" title="3 NodePort 样例"></a>3 NodePort 样例</h1><p>​    跟 hostNetwork 和 hostPort 不同，NodePort 属于 service 类型之一。hostPort 和 hostNetwork 作用对象是 Pod，而 NodePort 作用对象则是 service。</p><p>​    pod 文件如下所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587550204849539.png" srcset="/img/loading.gif" lazyload alt="第二十六章 九析带你轻松完爆 Istio - k8s 流量进入集群之 NodePort_istio 教程_03"></p><p>​    service 文件如下：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587550210984313.png" srcset="/img/loading.gif" lazyload alt="第二十六章 九析带你轻松完爆 Istio - k8s 流量进入集群之 NodePort_istio 教程_04"></p><p>​    创建 NodePort 服务时，用户可以在 30000 ~ 32767 范围内指定一个端口，也可以通过 patch 打补丁的方式修改 service 类型，这样 NodePort 端口将会在范围 30000 ~ 32767 之间自动分配。</p><blockquote><p>kubectl patch svc svc_name -n ns_name -p ‘{“type”: “NodePort”}’</p></blockquote><hr><h1 id="4-访问流程"><a href="#4-访问流程" class="headerlink" title="4 访问流程"></a>4 访问流程</h1><p>​    下图展示当 k8s svc 创建之后，k8s 集群内部都发生了哪些变化。<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587550218909632.png" srcset="/img/loading.gif" lazyload alt="第二十六章 九析带你轻松完爆 Istio - k8s 流量进入集群之 NodePort_istio 视频_05"></p><p>​    当 client 发送 kubectl apply 指令给 APIServer 后，会生成相关的 service 对象，k8s 集群内的所有节点（master 和 node）上都会运行 kube-proxy 进程，如下截图所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587550225387994.png" srcset="/img/loading.gif" lazyload alt="第二十六章 九析带你轻松完爆 Istio - k8s 流量进入集群之 NodePort_istio 视频_06"></p><p>​    该进程的作用就是负责跟 APIServer 进行通信并对 node 上的 pod 进行生命周期管理。如果创建了 k8s service ，那么 kube-proxy  会创建相应的 iptables 规则，并将发送到 service nodePort 的流量转发到 service 后端提供的 Pod  的相应端口上。</p><hr><h1 id="5-实例演示"><a href="#5-实例演示" class="headerlink" title="5 实例演示"></a>5 实例演示</h1><p>​    当执行 jiuxi-svc.yaml 资源文件后，如下截图所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587550231487434.png" srcset="/img/loading.gif" lazyload alt="第二十六章 九析带你轻松完爆 Istio - k8s 流量进入集群之 NodePort_k8s nodeport_07"></p><p>​    查看网络监控接口可知 30088 对应的服务进程就是 kube-proxy，如下图所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587550237774324.png" srcset="/img/loading.gif" lazyload alt="第二十六章 九析带你轻松完爆 Istio - k8s 流量进入集群之 NodePort_k8s nodeport_08"></p><p>​    当我们通过 curl 访问 hostIP:30088 时，数据包会通过 30088 端口送给 kube-proxy 进程，kube-proxy 进程会根据 k8s service 的 endpoint 将数据包路由到实际的 pod IP 和对应的端口去。如下截图查看 service 对应的  endpoints。<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587550245651146.png" srcset="/img/loading.gif" lazyload alt="第二十六章 九析带你轻松完爆 Istio - k8s 流量进入集群之 NodePort_istio 视频_09"></p><hr><h1 id="6-缺点"><a href="#6-缺点" class="headerlink" title="6 缺点"></a>6 缺点</h1><p>​    使用 NodePort 方式，在 k8s 集群内部，每个节点（master 或 node）上 kube-proxy 进程都会开启相关的端口。如果服务都采用这样的方式，端口就有冲突的可能。因此建议谨慎使用。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - k8s 流量进入集群之 hostPort</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-k8s-%E6%B5%81%E9%87%8F%E8%BF%9B%E5%85%A5%E9%9B%86%E7%BE%A4%E4%B9%8B-hostPort/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-k8s-%E6%B5%81%E9%87%8F%E8%BF%9B%E5%85%A5%E9%9B%86%E7%BE%A4%E4%B9%8B-hostPort/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 hostPort 样例</p><p>4 hostPort 与 hostNetwork 异同</p><p>  4.1 相同点</p><p>  4.2 不同点</p><p>5 hostPort 使用场景</p><p>6 注意</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>​    如果你对博客有任何疑问，请告诉我。<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587465765267666.png" srcset="/img/loading.gif" lazyload alt="第二十五章 九析带你轻松完爆 Istio - k8s 流量进入集群之 hostPort_istio 流量管理"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587465773277912.png" srcset="/img/loading.gif" lazyload alt="第二十五章 九析带你轻松完爆 Istio - k8s 流量进入集群之 hostPort_k8s 视频_02"></p><hr><h1 id="3-hostPort-样例"><a href="#3-hostPort-样例" class="headerlink" title="3 hostPort 样例"></a>3 hostPort 样例</h1><p>​    样例代码如下所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587465780365910.png" srcset="/img/loading.gif" lazyload alt="第二十五章 九析带你轻松完爆 Istio - k8s 流量进入集群之 hostPort_k8s hostPort_03"></p><p>​    pod 发布之后，便会将容器端口开放给了外部网络。外部可以通过 pod 所在宿主机和 hostPort 值访问到 Pod 内的容器提供的服务。</p><hr><h1 id="4-hostPort-与-hostNetwork-异同"><a href="#4-hostPort-与-hostNetwork-异同" class="headerlink" title="4 hostPort 与 hostNetwork 异同"></a>4 hostPort 与 hostNetwork 异同</h1><h2 id="4-1-相同点"><a href="#4-1-相同点" class="headerlink" title="4.1 相同点"></a>4.1 相同点</h2><p>​    hostPort 与 hostNetwork 本质上都是暴露 pod 宿主机 IP 给终端用户，因为 pod 生命周期并不固定，随时都有可能被完爆，故 IP  的不确定最终导致用户使用上的不方便；此外宿主机端口占用也导致不能在同一台机子上有多个程序使用同一端口。因此一般情况下，不要使用 hostPort 方式。</p><h2 id="4-2-不同点"><a href="#4-2-不同点" class="headerlink" title="4.2 不同点"></a>4.2 不同点</h2><p>​    使用 hostNetwork，pod 实际上用的是 pod 宿主机的网络地址空间：即 pod  IP 是宿主机 IP，而非 cni 分配的 pod IP，端口是宿主机网络监听接口。</p><p>使用 hostPort，pod IP 并非宿主机 IP，而是 cni 分配的 pod IP，跟其他普通的 pod 使用一样的 ip  分配方式，端口并非宿主机网络监听端口，只是使用了 DNAT 机制将 hostPort 指定的端口映射到了容器的端口之上（可以通过  iptables 命令进行查看）。外部访问此 pod 时，仍然使用宿主机和 hostPort 方式。pod ip 跟宿主机 ip 截图如下：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587465825662942.png" srcset="/img/loading.gif" lazyload alt="第二十五章 九析带你轻松完爆 Istio - k8s 流量进入集群之 hostPort_istio 流量管理_04"></p><p>​    有关端口 DNAT 通过 iptables 命令进行查看，如下截图所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587465835982578.png" srcset="/img/loading.gif" lazyload alt="第二十五章 九析带你轻松完爆 Istio - k8s 流量进入集群之 hostPort_istio 视频_05"></p><p>​    由上图可知，pod 所在宿主机上的 iptables nat 表流向如下：</p><blockquote><p>1 当客户端发起 pod 访问时，比如 curl <a href="http://pod_in_host:hostPort">http://pod_in_host:hostPort</a></p><p>2 网络包会流经 pod 宿主机的 prerouting chain，会命中 CNI-HOSTPORT-DNAT 链</p><p>3 网络包会流经 CNI-HOSTPORT_DNAT 链中的第 3 条规则，即 DNAT 目标，此时会将 9998 端口访问的流量路由到 80 端口去</p></blockquote><p>​    基于此，当客户端访问 pod 所在主机的 9998 端口时，流量会自动被路由到 IP 为 10.244.11.55（也就是 pod ip）的 80 端口上。</p><hr><h1 id="5-hostPort-使用场景"><a href="#5-hostPort-使用场景" class="headerlink" title="5 hostPort 使用场景"></a>5 hostPort 使用场景</h1><p>​    nginx-ingress-controller 就使用到了 hostPort 方式，同时开启了 80 和 443 端口，如下截图所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587465846114894.png" srcset="/img/loading.gif" lazyload alt="第二十五章 九析带你轻松完爆 Istio - k8s 流量进入集群之 hostPort_istio 视频_06"></p><hr><h1 id="6-注意"><a href="#6-注意" class="headerlink" title="6 注意"></a>6 注意</h1><p>​    当 pod 同时使用了 hostNetwork 和 hostPort，那么 hostNetwork 将会直接使用宿主机网络命名空间，hostPort 其实就形同虚设了。可以认为 hostNetwork 选项优先级要高于 hostPort。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - k8s 流量进入集群之 hostNetwork</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-k8s-%E6%B5%81%E9%87%8F%E8%BF%9B%E5%85%A5%E9%9B%86%E7%BE%A4%E4%B9%8B-hostNetwork/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-k8s-%E6%B5%81%E9%87%8F%E8%BF%9B%E5%85%A5%E9%9B%86%E7%BE%A4%E4%B9%8B-hostNetwork/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 k8s 流量进入集群方式</p><p>4 hostNetwork 样例</p><p>5 hostNetwork 影响</p><p>  5.1 Pod IP 和 Port</p><p>  5.2 node 个数跟 pod 副本数</p><p>6 hostNetwork 使用场景</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>​    如果你对博客有任何疑问，请告诉我。<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587352067700864.png" srcset="/img/loading.gif" lazyload alt="第二十四章 九析带你轻松完爆 Istio - k8s 流量进入集群之 hostNetwork_istio 视频"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587352077750654.png" srcset="/img/loading.gif" lazyload alt="第二十四章 九析带你轻松完爆 Istio - k8s 流量进入集群之 hostNetwork_k8s 视频_02"></p><hr><h1 id="3-k8s-流量进入集群方式"><a href="#3-k8s-流量进入集群方式" class="headerlink" title="3 k8s 流量进入集群方式"></a>3 k8s 流量进入集群方式</h1><p>​    k8s 集群外的流量如果要进入 k8s，通常有如下几种方式：</p><blockquote><p>hostNetwork</p><p>NodePort</p><p>ClusterIP</p><p>LoadBalancer</p><p>Ingress</p><p>hostPort</p></blockquote><p>​    本节重点介绍 hostNetwork 方式。</p><hr><h1 id="4-hostNetwork-样例"><a href="#4-hostNetwork-样例" class="headerlink" title="4 hostNetwork 样例"></a>4 hostNetwork 样例</h1><p>​    截图如下：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587352085511041.png" srcset="/img/loading.gif" lazyload alt="第二十四章 九析带你轻松完爆 Istio - k8s 流量进入集群之 hostNetwork_istio 网络_03"></p><p>​    hostNetwork 只能作用在 Pod 上。如果 Pod 开启了 hostNetwork: true，则该 Pod 直接使用当前宿主机的网络空间，如果 Pod  内的进程需要开启网络监听接口，就会直接在当前宿主机开启。如上图可知一个 Pod 内运行一个 busybox 的容器，该 busybox 容器内的 httpd 进程会开启 8888 网络监听端口，而该端口会直接开启在 Pod 所在宿主机上。</p><hr><h1 id="5-hostNetwork-影响"><a href="#5-hostNetwork-影响" class="headerlink" title="5 hostNetwork 影响"></a>5 hostNetwork 影响</h1><h2 id="5-1-Pod-IP-和-Port"><a href="#5-1-Pod-IP-和-Port" class="headerlink" title="5.1 Pod IP 和 Port"></a>5.1 Pod IP 和 Port</h2><p>​    如果 Pod 采用主机网络策略（hostNetwork：true），其 IP 就是宿主机的 IP，其 Port 就是宿主机的 Port。如下图所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587352096237988.png" srcset="/img/loading.gif" lazyload alt="第二十四章 九析带你轻松完爆 Istio - k8s 流量进入集群之 hostNetwork_k8s 网络_04"></p><h2 id="5-2-node-个数跟-pod-副本数"><a href="#5-2-node-个数跟-pod-副本数" class="headerlink" title="5.2 node 个数跟 pod 副本数"></a>5.2 node 个数跟 pod 副本数</h2><p>​    如果 Pod 采用主机网络策略（hostNetwork：true），Pod 副本数不能超过 node 数，因为 pod 最终会采用 node  的网络命名空间，如果 pod 副本数多于 node 数，则会有些 pod 不能创建成功。如下图所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587352103773057.png" srcset="/img/loading.gif" lazyload alt="第二十四章 九析带你轻松完爆 Istio - k8s 流量进入集群之 hostNetwork_istio 网络_05"></p><p>​    由上图可知，因为采用了 hostNetwork，所以在同一个 Node 节点（k8s-w-202）上就不能同时运行两个 pod，因为该 pod 都使用了同一个网络端口 8888。如下日志截图可知：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587352110241577.png" srcset="/img/loading.gif" lazyload alt="第二十四章 九析带你轻松完爆 Istio - k8s 流量进入集群之 hostNetwork_k8s 网络_06"></p><p>​    自此，我们可以得知，使用 hostNetwork 具有相当大的局限，首先 Pod 有可能被完爆，所以如果直接采用 IP 的方式跟 Pod  打交道会有不可预期的后果。此外，随着宿主机运行程序的增多，端口冲突的概率就会大大增加，因此 hostNetwork 的采用必须慎之又慎。</p><hr><h1 id="6-hostNetwork-使用场景"><a href="#6-hostNetwork-使用场景" class="headerlink" title="6 hostNetwork 使用场景"></a>6 hostNetwork 使用场景</h1><p>​    一般情况下使用 hostNetwork 的场景多用在操作或者管理宿主机的网络环境上，比如我们经常使用的网络插件，比如 flannel、canal  等。这些网络插件可以完全控制集群中每个节点上的网络，比如可以将其他 pod （hotNetwork：false）连接到 overlay  网络中。下图展示本人的 canal 网络插件 pod 的配置：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1587352121991492.png" srcset="/img/loading.gif" lazyload alt="第二十四章 九析带你轻松完爆 Istio - k8s 流量进入集群之 hostNetwork_istio 视频_07"></p><p>​        </p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - destination rule 介绍</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-destination-rule-%E4%BB%8B%E7%BB%8D/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-destination-rule-%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 介绍</p><p>4 路由策略</p><p>5 样例说明</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>​    如果你对博客有任何疑问，请告诉我。<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586941964975167.png" srcset="/img/loading.gif" lazyload alt="第二十三章 九析带你轻松完爆 Istio - destination rule 介绍_Istio destination r"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586941972382785.png" srcset="/img/loading.gif" lazyload alt="第二十三章 九析带你轻松完爆 Istio - destination rule 介绍_Istio 视频_02"></p><hr><h1 id="3-介绍"><a href="#3-介绍" class="headerlink" title="3 介绍"></a>3 介绍</h1><p>​    上章展示了 destination rule 一个实例。</p><p>​    destination rules 是 Istio 流量路由的关键功能，它不能独自使用，必须跟 Virtual Service 共同发挥作用。当  destination rules 跟 virtual service 共同使用的时候，virtual service  决定将流量路由到逻辑地址，而 destination rules 则决定流量路由到物理地址。</p><p>​    virtual service 跟 destination rules 路由关系就像变量到内存的地址映射一样，destination 代表内存实际地址，而 virtual service 作用就像程序的指针。</p><p>​    destination rules 通常用在微服务的版本分组上（例如可以通过 version 标签将微服务进行分组）。通过 destination rules  的分组规则可以实现将流量路由到服务的不同版本中，进而实现类似灰度、金丝雀、蓝绿等版本分流的策略。</p><p>​    destination rules 不仅可以决定把流量路由到何处，还可以制定如何路由流量（比如是轮询路由流量，还是随机路由流量等等）。有关 destination rules 选项可以参考 <a href="https://istio.io/docs/reference/config/networking/destination-rule/"> Destination Rule 指南</a>。</p><hr><h1 id="4-路由策略"><a href="#4-路由策略" class="headerlink" title="4 路由策略"></a>4 路由策略</h1><p>​    默认情况下，Istio 使用轮询的负载均衡路由策略（round-robin），也就是说服务所有实例按顺序接收请求。当然 Istio 也支持如下的模型，这些模型都可以通过在 destination rule 中进行指定：</p><blockquote><p>Random：请求被随机分配给服务的实例</p><p>Weighted：请求基于权重被分配给服务的实例</p><p>Least requests：请求被分配给服务最少被访问的实例</p></blockquote><hr><h1 id="5-样例说明"><a href="#5-样例说明" class="headerlink" title="5 样例说明"></a>5 样例说明</h1><p>​    Istio 官方给出的 destination rule 样例如下：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586941984155387.png" srcset="/img/loading.gif" lazyload alt="第二十三章 九析带你轻松完爆 Istio - destination rule 介绍_Istio 流量管理_03"></p><p>​    上例 destination rule 中指定了 subsets，子集是根据 version 来定义。注意，这里 labels  内容可以自由定义，不一定非要是 version。其中的 trafficPolicy  就是流量路由到服务所有实例的策略（比如随机、轮询、按权重、最少访问等）。此外针对 v2 这个  subsets，它的路由策略比较特殊，它覆盖了默认的 RANDOM 方式，而是直接采用了 ROUND_ROBIN 方式。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - destination rule 实例</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-destination-rule-%E5%AE%9E%E4%BE%8B/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-destination-rule-%E5%AE%9E%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 介绍</p><p>4 灰度</p><p>5 destination rule 样例</p><p>  5.1 客户端资源文件</p><p>  5.2 deployment 资源文件</p><p>  5.3 service 资源文件</p><p>  5.4 Istio virtual service 资源文件</p><p>  5.5 Istio destination rule 资源文件</p><p>6 Istio 注入</p><p>7 验证 destination rule</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586921192580920.png" srcset="/img/loading.gif" lazyload alt="第二十二章 九析带你轻松完爆 Istio - destination rule 实例_Istio 流量管理"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586921199348308.png" srcset="/img/loading.gif" lazyload alt="第二十二章 九析带你轻松完爆 Istio - destination rule 实例_Istio destination r_02"></p><hr><h1 id="3-介绍"><a href="#3-介绍" class="headerlink" title="3 介绍"></a>3 介绍</h1><p>​    在上章节介绍了一个使用 Virtual Service 实现按权重（weight）分配流量的例子。整个过程如下架构图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586921280361186.png" srcset="/img/loading.gif" lazyload alt="第二十二章 九析带你轻松完爆 Istio - destination rule 实例_Istio 视频_03"></p><p>​    整个流控过程仅仅添加了一个 virtual service 就得以解决，有关 virtual service 的代码如下所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586921289867471.png" srcset="/img/loading.gif" lazyload alt="第二十二章 九析带你轻松完爆 Istio - destination rule 实例_Istio virtual servi_04"></p><p>​    但是上面这种方案在于调用方通过两层服务才能调用到最终的 Pod（比如：客户端需要通过 web-svc 和 nginx-svc 才能最终调用到 Nginx  Pod）。能不能仅仅只通过一层服务就能达到这样的效果呢？（即：只通过 web-svc）。答案是必须可以。</p><hr><h1 id="4-灰度"><a href="#4-灰度" class="headerlink" title="4 灰度"></a>4 灰度</h1><p>​    其实上面的样例非常山寨，导致根本就没有实际工作场景可以复制，仅仅只是为了展示独立 virtual service 功能。</p><p>​    但是按权重分配流量确是工作中常见的需求，比如灰度、金丝雀、蓝绿发布等。</p><p>​    灰度，意味着做事并没有那么敞亮，比如，你想跟一个心仪的女子上演一幕东京爱情故事，你的做法大概是跟她暧昧、爱抚、亲吻、最后进行爱的鼓掌。整个过程的本质就是完成一次状态转移，即从孤军奋战式撸管状态转移到团队协作式鼓掌状态。</p><p>​    灰度发布的过程跟上面的过程比较类似，都是亦步亦趋，循循善诱的过程。即：将版本 v1 的服务变更到版本 v2，但是却并不采用刚烈的极端做法。具体做法是先切 20% 流量给版本 v2，观察一阵子没啥异常事情发生，就再切  20% 流量，然后逐步切换剩下的其他流量，最终完成整个版本的替换以及所有用户流量的转移。</p><hr><h1 id="5-destination-rule-样例"><a href="#5-destination-rule-样例" class="headerlink" title="5 destination rule 样例"></a>5 destination rule 样例</h1><p>​    下面介绍使用 virtual service + destination rule 来实现灰度发布。有关 destination rule 的理论在下章节介绍。整个样例的架构图如下：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586921312295542.png" srcset="/img/loading.gif" lazyload alt="第二十二章 九析带你轻松完爆 Istio - destination rule 实例_Istio 流量管理_05"></p><p>​    样例所需要的资源文件介绍如下：</p><blockquote><p># 客户端，用来访问 httpd-v1 和 httpd-v2 的容器资源文件</p><p>jiuxi-client.yaml</p><p># deployment，声明并定义 httpd 的资源文件</p><p>jiuxi-deploy.yaml</p><p># service，关联 httpd pod 的资源文件</p><p>jiuxi-svc.yaml</p><p># Istio virtual service，声明流量路由和权重的资源文件</p><p>jiuxi-vs.yaml</p><p># Istio destination rule，定义流量路由的资源文件</p><p>jiuxi-dr.yaml</p></blockquote><h2 id="5-1-客户端资源文件"><a href="#5-1-客户端资源文件" class="headerlink" title="5.1 客户端资源文件"></a>5.1 客户端资源文件</h2><p>​    jiuxi-client.yaml:<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586921328294728.png" srcset="/img/loading.gif" lazyload alt="第二十二章 九析带你轻松完爆 Istio - destination rule 实例_Istio 教程_06"></p><h2 id="5-2-deployment-资源文件"><a href="#5-2-deployment-资源文件" class="headerlink" title="5.2 deployment 资源文件"></a>5.2 deployment 资源文件</h2><p>​    jiuxi-deploy.yaml：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586921339777599.png" srcset="/img/loading.gif" lazyload alt="第二十二章 九析带你轻松完爆 Istio - destination rule 实例_Istio 流量管理_07"></p><h2 id="5-3-service-资源文件"><a href="#5-3-service-资源文件" class="headerlink" title="5.3 service 资源文件"></a>5.3 service 资源文件</h2><p>​    jiuxi-svc.yaml：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586921348536422.png" srcset="/img/loading.gif" lazyload alt="第二十二章 九析带你轻松完爆 Istio - destination rule 实例_Istio 流量管理_08"></p><h2 id="5-4-Istio-virtual-service-资源文件"><a href="#5-4-Istio-virtual-service-资源文件" class="headerlink" title="5.4 Istio virtual service 资源文件"></a>5.4 Istio virtual service 资源文件</h2><p>​    jiuxi-vs.yaml:<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586921359681595.png" srcset="/img/loading.gif" lazyload alt="第二十二章 九析带你轻松完爆 Istio - destination rule 实例_Istio 教程_09"></p><h2 id="5-5-Istio-destination-rule-资源文件"><a href="#5-5-Istio-destination-rule-资源文件" class="headerlink" title="5.5 Istio destination rule 资源文件"></a>5.5 Istio destination rule 资源文件</h2><p>​    jiuxi-dr.yaml：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586921368116463.png" srcset="/img/loading.gif" lazyload alt="第二十二章 九析带你轻松完爆 Istio - destination rule 实例_Istio 教程_10"></p><hr><h1 id="6-Istio-注入"><a href="#6-Istio-注入" class="headerlink" title="6 Istio 注入"></a>6 Istio 注入</h1><p>​    要使得 virtual service 和 destination rule 生效，必须要保证通讯双方都处于 Istio 服务网格之内，即：必须经过 Istio 的注入，执行语句如下：</p><blockquote><p>istioctl kube-inject -f jiuxi-client.yaml | kubectl apply -f -</p><p>istioctl kube-inject -f jiuxi-deploy.yaml | kubectl apply -f -</p></blockquote><hr><h1 id="7-验证-destination-rule"><a href="#7-验证-destination-rule" class="headerlink" title="7 验证 destination rule"></a>7 验证 destination rule</h1><p>​    登入 busybox client 容器，访问 jiuxi-svc，发现 dr 已经生效，截图如下：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586921382193476.png" srcset="/img/loading.gif" lazyload alt="第二十二章 九析带你轻松完爆 Istio - destination rule 实例_Istio 教程_11"></p><p>​    自此，九析带你轻松完爆了 Istio destination rule 实例。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - Istio 路由规则</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-Istio-%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-Istio-%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 Routing Rule 语法</p><p>4 Routing Rule 优先级</p><p>5 Routing Rule 匹配规则/条件</p><p>  5.1 基于 HttpMatchRequest</p><p>  5.2 基于权重</p><p>6 流量操作（HTTPRoute）</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>​    如果你对博客有任何疑问，请告诉我。</p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586422323756366.png" srcset="/img/loading.gif" lazyload alt="第二十一章 九析带你轻松完爆 service mesh - Istio 路由规则_istio 视频"></p><hr><h1 id="3-Routing-Rule-语法"><a href="#3-Routing-Rule-语法" class="headerlink" title="3 Routing Rule 语法"></a>3 Routing Rule 语法</h1><p>​    在上节中介绍了 Virtual Service 的概念，并运行了一个简单的样例，大家应该对 Virtual Service 有了一个大致的了解。</p><p>​    Virutal Service 中最重要的概念就是路由规则（Routing Rule），注意跟 Istio traffic management 中的另外一个概念——目的地规则（Destination Rule）区分，前者是一个逻辑概念，而后者则跟 Virtual  Service 一样，是实际可以部署到 K8S 上的 Istio 资源。</p><p>​    在解释路由规则之前，这里先举一个例子：</p><p>​    又到了招聘的高峰期，HR 陆续招聘了一批校园毕业生。招聘结束后，这些毕业生要分配到具体的工作岗位。分配的规则如下：</p><blockquote><p>一、986 学校毕业的学生分配到基础平台组</p><p>二、普通学校毕业的学生分配到交易平台组</p><p>三、黑马程序员毕业的学生分配到运维平台组</p></blockquote><p>​    上面的例子提到了两个概念。一：匹配规则（或匹配条件）；二：路由目的地。这其实也就是这节介绍的主角 Routing Rule，Routing Rule 这两个单词就完美的包含了上面两个概念。</p><p>下面再接着看代码，加深一下理解：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586422367807809.png" srcset="/img/loading.gif" lazyload alt="第二十一章 九析带你轻松完爆 service mesh - Istio 路由规则_istio traffic manag_02"></p><p>​    语法简单解释如下，大意也就是匹配 XX 规则就路由到 OO，如果不匹配规则就路由到 SY（有点 if…else… 的味道）：</p><blockquote><p>match…route destination…/ route destination …</p></blockquote><p>​    当然这里有一点需要澄清，就是匹配条件并非强制，也就是说路由规则不一定非要有匹配项（match），仅有路由也是可以的。</p><p>​    翻看第二十章运行本人设计的用例，执行命令和执行结果如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586422376843726.png" srcset="/img/loading.gif" lazyload alt="第二十一章 九析带你轻松完爆 service mesh - Istio 路由规则_istio traffic manag_03"></p><hr><h1 id="4-Routing-Rule-优先级"><a href="#4-Routing-Rule-优先级" class="headerlink" title="4 Routing Rule 优先级"></a>4 Routing Rule 优先级</h1><p>​    路由规则从上到下按顺序进行评估，其中 Virtual Service  定义的第一个路由规则具有最高优先级。当然这里建议在每个虚拟服务中提供默认的“无条件”或者基于权重（weight）的规则来作为最后一个规则，以确保到虚拟服务的流量始终具有至少一条匹配的路由。</p><hr><h1 id="5-Routing-Rule-匹配规则-条件"><a href="#5-Routing-Rule-匹配规则-条件" class="headerlink" title="5 Routing Rule 匹配规则/条件"></a>5 Routing Rule 匹配规则/条件</h1><h2 id="5-1-基于-HttpMatchRequest"><a href="#5-1-基于-HttpMatchRequest" class="headerlink" title="5.1 基于 HttpMatchRequest"></a>5.1 基于 HttpMatchRequest</h2><p>​    匹配规则/条件从关键字 match 开始，针对某些匹配条件，可以选择使用精确值（exact），前缀（prefix）或正则表达式来选择它们。 有关匹配条件字段及其可能值的完整列表可在 <a href="https://istio.io/docs/reference/config/networking/virtual-service/#HTTPMatchRequest"> HTTPMatchRequest</a> 找到。</p><p>​    http 匹配条件样例资源文件如下，该样例中指明请求 uri 在忽略大小写的情况下，前缀如果是  /ratings/v2/，并且 http header 中 end-user 字段的值为 jason，就路由到命名空间为 prod 的名称为  ratings 的服务去：</p><blockquote><p>apiVersion: networking.istio.io/v1alpha3</p><p>kind: VirtualService</p><p>metadata:  </p><p>  name: ratings-route</p><p>spec:  </p><p>  hosts:  </p><p>  - ratings.prod.svc.cluster.local  </p><p>  http:  </p><p>  - match:   </p><p>​    - headers:     </p><p>​      end-user:      </p><p>​        exact: jason    </p><p>​     uri:     </p><p>​      prefix: “/ratings/v2/“    </p><p>​     ignoreUriCase: true   </p><p>​    route:   </p><p>​    - destination:     </p><p>​      host: ratings.prod.svc.cluster.local</p></blockquote><h2 id="5-2-基于权重"><a href="#5-2-基于权重" class="headerlink" title="5.2 基于权重"></a>5.2 基于权重</h2><p>​    路由规则除了基于 HTTPMatchRequest 匹配之外，还可以基于权重（weight），通过权重就可以轻松完爆 A/B 测试和金丝雀（Canary）发布了。权重设置如下所示：</p><blockquote><p>apiVersion: networking.istio.io/v1alpha3</p><p>kind: VirtualService</p><p>metadata:</p><p>  name: web-vs-svc</p><p>spec:</p><p>  hosts:</p><p>  - web-svc</p><p>  http:</p><p>  - route:</p><p>​    - destination:</p><p>​      host: httpd-svc</p><p>​      weight: 20</p><p>​    - destination:</p><p>​      host: tomcat-svc</p><p>​      weight: 80</p></blockquote><hr><h1 id="6-流量操作（HTTPRoute）"><a href="#6-流量操作（HTTPRoute）" class="headerlink" title="6 流量操作（HTTPRoute）"></a>6 流量操作（HTTPRoute）</h1><p>​    可以使用路由规则对流量做一些操作：</p><blockquote><p>附加或者删除标题</p><p>重写 URL</p><p>为路由目的地设置重试策略</p></blockquote><p>​    有关流量操作的例子如下：</p><blockquote><p>apiVersion: networking.istio.io/v1alpha3</p><p>kind: VirtualService</p><p>metadata:</p><p>  name: web-vs-svc</p><p>spec:</p><p>  hosts:</p><p>  - web-svc</p><p>  http:</p><p>  - match:</p><p>​    - uri:</p><p>​      prefix: /index.html</p><p>​     rewrite:</p><p>​      uri: /index.html</p><p>​     route:</p><p>​     - destination:</p><p>​        host: tomcat-svc</p></blockquote><p>​    有关流量操作的更多信息，可以参考 <a href="https://istio.io/docs/reference/config/networking/virtual-service/#HTTPRoute"> HTTPRoute</a>。</p><p>​    自此，九析带你轻松完爆 Istio 路由规则。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 Istio - virtual service 简述</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-virtual-service-%E7%AE%80%E8%BF%B0/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-Istio-virtual-service-%E7%AE%80%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 virtual service 简述</p><p>4 virtual service 样例</p><p>  4.1 jiuxi-busybox.yaml</p><p>  4.2 jiuxi-deployment.yaml</p><p>  4.3 jiuxi-svc.yaml</p><p>  4.4 jiuxi-vs.yaml</p><p>5 Istio 注入</p><p>6 登录客户端验证规则生效</p><p>7 总结</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586397634467970.png" srcset="/img/loading.gif" lazyload alt="第二十章 九析带你轻松完爆 Istio - virtual service 简述_istio 流量管理"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586397641993499.png" srcset="/img/loading.gif" lazyload alt="第二十章 九析带你轻松完爆 Istio - virtual service 简述_istio 教程_02"></p><hr><h1 id="3-virtual-service-简述"><a href="#3-virtual-service-简述" class="headerlink" title="3 virtual service 简述"></a>3 virtual service 简述</h1><p>​    在前面的章节中已经讲过了 virtual service 的概念和理论了。这里再做一个赘述，virtual service 是虚拟服务，它并非真正的 k8s  service，首先不能通过 kubectl get svc 的方式找到它，其次在服务调用的时候也不会直接调用它，它就像 k8s service 背后的女人一样，紧紧握着 k8s service 的老二，让它乖乖按照自己的旨意将请求流量路由到网格内的特定目标。</p><p>如下是经常困扰初学者的问题，下面一一做解答。</p><blockquote><p><strong>问题一：Virtual service 跟 k8s service 的关系是什么。属于强绑定吗？</strong></p><p>回答：不是强绑定。virtual service 可以帮助 k8s service 在路由控制上做到更细粒度，不必只是 Round-Robin 策略。</p><p><strong>问题二：Virtual service 必须要跟 Istio traffic management 的其他资源，比如 destination rule、gateway、service entries 捆绑使用吗？</strong></p><p>回答：否。Virtual service 自身就可以产生作用。当然它也可以跟网关，或者跟 destination rule 一起构造更加灵活、丰富的路由规则。</p><p><strong>问题三：路由规则（Routing rules）跟 Destination rule 是同样的东西吗？</strong></p><p>回答：否。路由规则是逻辑上的概念，而 Destination rule 是 Istio 的一种资源。你可以将 Destination rule 看做 Routing rules 的子集。</p><p><strong>问题四：Virtaul service 的 hosts 字段填写什么内容？</strong></p><p>回答：hosts 字段值是客户端向服务发送请求时使用的地址。这个地址可以是 IP 地址、DNS 名称、也可以是 k8s service  名称（短名词地址或者完整地址，比如  web-svc.default.cluster.local）,如果是短名称，要求可以隐式或者显式地解析为完全限定域名（FQDN）。当然也可以使用通配符（*）前缀，从而为所有匹配的服务创建一套路由规则。虚拟服务主机实际上不一定是 Istio 服务注册表的一部分，它们只是可以可寻址的虚拟目的地而已。这样，也就可以为网格内没有可路由条目的虚拟主机流量进行建模。</p></blockquote><hr><h1 id="4-virtual-service-样例"><a href="#4-virtual-service-样例" class="headerlink" title="4 virtual service 样例"></a>4 virtual service 样例</h1><p>​    下面介绍一个 virtual service 独立作用的例子，本例需要的资源如下：</p><blockquote><p># 调用服务的客户端</p><p>jiuxi-busybox.yaml</p></blockquote><blockquote><p># 两个 web 服务器: tomcat 和 httpd。模拟两个微服务，需要被 Istio 注入，注入后就变成服务网格中的服务</p><p>jiuxi-deployment.yaml</p><p># 定义 3 个服务：httpd-svc 指向 httpd，tomcat-svc 指向 tomcat。web-svc 同时指向 httpd 和 tomcat</p><p>jiuxi-svc.yaml</p><p># Istio virtual service：定义虚拟服务，该虚拟服务作用在 web-svc 服务上，并设置简单的路由规则（Routing rule，而非 Destination rule）</p><p>jiuxi-vs.yaml</p></blockquote><p>​    下面一一介绍各个资源文件明细。</p><h2 id="4-1-jiuxi-busybox-yaml"><a href="#4-1-jiuxi-busybox-yaml" class="headerlink" title="4.1 jiuxi-busybox.yaml"></a>4.1 jiuxi-busybox.yaml</h2><p>​    代码如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586397653621566.png" srcset="/img/loading.gif" lazyload alt="第二十章 九析带你轻松完爆 Istio - virtual service 简述_istio traffic manag_03"></p><h2 id="4-2-jiuxi-deployment-yaml"><a href="#4-2-jiuxi-deployment-yaml" class="headerlink" title="4.2 jiuxi-deployment.yaml"></a>4.2 jiuxi-deployment.yaml</h2><p>​    代码如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586397659465460.png" srcset="/img/loading.gif" lazyload alt="第二十章 九析带你轻松完爆 Istio - virtual service 简述_istio 流量管理_04"></p><h2 id="4-3-jiuxi-svc-yaml"><a href="#4-3-jiuxi-svc-yaml" class="headerlink" title="4.3 jiuxi-svc.yaml"></a>4.3 jiuxi-svc.yaml</h2><p>​    代码如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586397666911168.png" srcset="/img/loading.gif" lazyload alt="第二十章 九析带你轻松完爆 Istio - virtual service 简述_istio 视频_05"></p><h2 id="4-4-jiuxi-vs-yaml"><a href="#4-4-jiuxi-vs-yaml" class="headerlink" title="4.4 jiuxi-vs.yaml"></a>4.4 jiuxi-vs.yaml</h2><p>​    代码如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586397672550709.png" srcset="/img/loading.gif" lazyload alt="第二十章 九析带你轻松完爆 Istio - virtual service 简述_istio 流量管理_06"></p><hr><h1 id="5-Istio-注入"><a href="#5-Istio-注入" class="headerlink" title="5 Istio 注入"></a>5 Istio 注入</h1><p>​    针对客户端和 deployment 执行手工注入：</p><blockquote><p>istioctl kube-inject -f jiuxi-deploy.yaml jiuxi-busybox.yaml | kubectl apply -f -</p><p>istioctl kube-inject -f jiuxi-busybox.yaml | kubectl apply -f -</p></blockquote><hr><h1 id="6-登录客户端验证规则生效"><a href="#6-登录客户端验证规则生效" class="headerlink" title="6 登录客户端验证规则生效"></a>6 登录客户端验证规则生效</h1><p>​    登录到 busybox，然后通过如下命令均可以看到规则生效：</p><blockquote><p>wget -q -O - <a href="http://web-svc:8080/"> http://web-svc:8080</a>    # web-svc 是 k8s service。字母 O，非数字 0</p><p>wget -q -O - <a href="http://ip:8080/">http://IP:8080</a>        # IP 是 web-svc 的 ClusterIP。</p></blockquote><hr><h1 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h1><p>​    自此九析带你轻松完爆了 Istio traffic management 的 virtaul service。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - Istio virtual service</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-Istio-virtual-service/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-Istio-virtual-service/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 虚拟服务（Virtual Service）</p><p>4 虚拟服务跟 K8s 服务的关系</p><p>5 虚拟服务实例</p><p>  5.1 k8s 资源</p><p>  5.2 Istio 资源</p><p>  5.3 Istio 注入</p><p>  5.4 创建客户端和客户端 Istio 注入</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586269741539025.png" srcset="/img/loading.gif" lazyload alt="第十九章 九析带你轻松完爆 service mesh - Istio virtual service_istio virtual servi"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586269750697704.png" srcset="/img/loading.gif" lazyload alt="第十九章 九析带你轻松完爆 service mesh - Istio virtual service_istio virtual servi_02"></p><hr><h1 id="3-虚拟服务（Virtual-Service）"><a href="#3-虚拟服务（Virtual-Service）" class="headerlink" title="3 虚拟服务（Virtual Service）"></a>3 虚拟服务（Virtual Service）</h1><p>​    虚拟服务（Virtual Service）以及目标规则（Destination Rule）是 Istio 流量路由的两大基石。虚拟服务可以将流量路由到 Istio 服务网格中的服务。每个虚拟服务由一组路由规则组成，这些路由规则按顺序进行评估。</p><p>​    如果没有 Istio virtual service，仅仅使用 k8s service 的话，那么只能实现最基本的流量负载均衡转发，但是就不能实现类似按百分比来分配流量等更加复杂、丰富、细粒度的流量控制了。</p><hr><h1 id="4-虚拟服务跟-K8s-服务的关系"><a href="#4-虚拟服务跟-K8s-服务的关系" class="headerlink" title="4 虚拟服务跟 K8s 服务的关系"></a>4 虚拟服务跟 K8s 服务的关系</h1><p>​    虚拟服务相当于 K8s 服务的 sidecar，在原本 K8s 服务的功能之上，提供了更加丰富的路由控制。</p><hr><h1 id="5-虚拟服务实例"><a href="#5-虚拟服务实例" class="headerlink" title="5 虚拟服务实例"></a>5 虚拟服务实例</h1><p>​    以下介绍使用 “虚拟服务（virtual service）+目标规则（destination rule）” 实现一个流量分流的例子。本示例共需要四种资源，k8s 和 istio 各两种：</p><p>​    k8s 资源介绍如下：</p><blockquote><p>1 两个 deployment，一个 tomcat，一个 nginx</p><p>2 一个 service 关联上面这两个 deployment</p></blockquote><p>​    Istio 资源介绍如下：</p><blockquote><p>1 一个 destination rule，设置目标规则定义</p><p>2 一个 virtual service 关联上面的 service，用来设置分流权重（weight）和设置分流目标规则定义）</p></blockquote><h2 id="5-1-k8s-资源"><a href="#5-1-k8s-资源" class="headerlink" title="5.1 k8s 资源"></a>5.1 k8s 资源</h2><p>​    k8s 资源共有两类，分别为 deployment 和 service，其中 deployment 资源文件明细如下：</p><blockquote><p># jiuxi-deploy.yaml</p><p>apiVersion: apps/v1</p><p>kind: Deployment</p><p>metadata:</p><p>  name: nginx-deploy</p><p>spec:</p><p>  replicas: 1</p><p>  selector:</p><p>​    matchLabels:</p><p>​      type: web</p><p>​      app: nginx</p><p>  template:</p><p>​    metadata:</p><p>​    labels:</p><p>​      type: web</p><p>​      app: nginx</p><p>​    spec:</p><p>​      containers:</p><p>​      - image: nginx:1.14-alpine</p><p>​        imagePullPolicy: IfNotPresent</p><p>​        name: nginx</p><p>​        ports:</p><p>​        - containerPort: 80</p><p>​          name: port</p><p>​          protocol: TCP</p><p>-–</p><p>apiVersion: apps/v1</p><p>kind: Deployment</p><p>metadata:</p><p>  name: tomcat-deploy</p><p>spec:</p><p>  replicas: 1</p><p>  selector:</p><p>​    matchLabels:</p><p>​      type: web</p><p>​      app: tomcat</p><p>  template:</p><p>​    metadata:</p><p>​      labels:</p><p>​        type: web</p><p>​        app: tomcat</p><p>​    spec:</p><p>​      containers:</p><p>​      - image: docker.io/kubeguide/tomcat-app:v1</p><p>​        imagePullPolicy: IfNotPresent</p><p>​        name: tomcat</p><p>​        ports:</p><p>​        - containerPort: 8080</p><p>​          name: port</p><p>​          protocol: TCP</p></blockquote><p>​    部署上面的 jiuxi-deploy.yaml 文件，语句如下：</p><blockquote><p>kubectl apply -f jiuxi-deploy.yaml</p></blockquote><p>​    service 资源文件明细如下：</p><blockquote><p># jiuxi-svc.yaml</p><p>apiVersion: v1</p><p>kind: Service</p><p>metadata:</p><p>  name: web-svc</p><p>spec:</p><p>  ports:</p><p>  - name: port</p><p>​    port: 8080</p><p>​    protocol: TCP</p><p>​    targetPort: 8080</p><p>  selector:</p><p>​    type: web</p></blockquote><p>​    部署上面的 service 文件，语句如下：</p><blockquote><p>kubectl apply -f jiuxi-svc.yaml</p></blockquote><p>​    自此，k8s 层面的资源文件准备完毕，现在通过访问 service，可以发现自动实现了RoundBin的负载均衡策略，即分配到 tomcat 和 nginx 的流量各为 50%。</p><h2 id="5-2-Istio-资源"><a href="#5-2-Istio-资源" class="headerlink" title="5.2 Istio 资源"></a>5.2 Istio 资源</h2><p>​    Istio 资源共有两类，分别为虚拟服务（Virtual Service）和目的地规则（Destination Rule）。虚拟服务作用在 k8s 服务之上，并加强了原 k8s 服务的功能：</p><ul><li><ul><li>指定目的地（tomcat 或 nginx）</li><li>重新分配流量（即不再是 50% / 50%，而是 75% / 25%）</li></ul></li></ul><p>​    目的地规则文件 jiux-dr.yaml 如下：</p><blockquote><p># jiuxi-dr.yaml</p><p>apiVersion: networking.istio.io/v1alpha3</p><p>kind: DestinationRule</p><p>metadata:</p><p>  name: jiuxi-dr</p><p>spec:</p><p>  host: jiuxi-svc</p><p>  subsets:</p><p>  - name: tomcat</p><p>​    labels:</p><p>​      app: tomcat</p><p>  - name: nginx</p><p>​    labels:</p><p>​      app: nginx</p></blockquote><p>​    上面的目的地资源文件作用在 jiux-svc 这个 k8s 服务上，通过 labels 字段指定不同的 pod，然后通过 name 字段提供给下面的 virtual service，起到关联到具体 pod 的作用。</p><p>​    如果这里你不好理解，可以这么来理解。以前 k8s service 跟 pod 关联是一维坐标关联，从上面例子可知，nginx 跟 tomcat 对 svc  而言是没什么区别的，因为都是相同的 labels 指定。但是如果采用了 virtual service 和 destination 相当于对  service 后面的 pod 使用了二维坐标关联，这样就可以明确定义 service 后面的 pod 到底有哪些业务含义了（比如一个是  nginx，另外一个是 tomcat）。这里大家仔细琢磨一下。</p><p>​    虚拟服务文件 jiuxi-vs.yaml 如下：</p><blockquote><p># jiuxi-vs.yaml</p><p>apiVersion: networking.istio.io/v1alpha3</p><p>kind: VirtualService</p><p>metadata:</p><p>  name: jiuxi-virtual-svc</p><p>spec:</p><p>  hosts:</p><p>  - jiuxi-svc</p><p>  http:</p><p>  - route:</p><p>​    - destination:</p><p>​        host: jiuxi-svc</p><p>​        subset: nginx</p><p>​      weight: 25</p><p>​    - destination:</p><p>​        host: jiuxi-svc</p><p>​        subset: tomcat</p><p>​      weight: 75</p></blockquote><p>​    执行上面这两个资源文件：</p><blockquote><p>kubectl apply -f jiuxi-dr.yaml</p><p>kubectl apply -f jiuxi-vs.yaml</p></blockquote><p>​    命令执行后的结果如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586269805760280.png" srcset="/img/loading.gif" lazyload alt="第十九章 九析带你轻松完爆 service mesh - Istio virtual service_istio virtual servi_03"></p><h2 id="5-3-Istio-注入"><a href="#5-3-Istio-注入" class="headerlink" title="5.3 Istio 注入"></a>5.3 Istio 注入</h2><p>​    执行如下命令进行 Istio 注入：</p><blockquote><p>istioctl kube-inject -f jiuxi-deploy.yaml | kubectl apply -f -</p></blockquote><p>​    因为 nginx 默认启动是 80 端口，为了保持跟 tomcat 端口保持一致，这里需要登录到 pod 中修改 nginx 端口，操作方法如下：</p><blockquote><p># pod 后缀根据实际情况进行修改</p><p>kubectl exec -it nginx-deploy-957f689f5-7svdz – sh</p></blockquote><p>​    然后编辑 nginx 配置文件：</p><blockquote><p>vi /etc/nginx/conf.d/default.conf</p></blockquote><p>​    修改内容如下截图：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1586269815956928.png" srcset="/img/loading.gif" lazyload alt="第十九章 九析带你轻松完爆 service mesh - Istio virtual service_istio 视频_04"></p><h2 id="5-4-创建客户端和客户端-Istio-注入"><a href="#5-4-创建客户端和客户端-Istio-注入" class="headerlink" title="5.4 创建客户端和客户端 Istio 注入"></a>5.4 创建客户端和客户端 Istio 注入</h2><p>​    创建客户端访问经过 Istio 流控过的 k8s 服务，客户端资源文件如下：</p><blockquote><p># jiuxi-busybox.yaml</p><p>apiVersion: v1</p><p>kind: Pod</p><p>metadata:</p><p>  name: busybox</p><p>spec:</p><p>  containers:</p><p>  - name: nginx</p><p>​    image: busybox</p><p>​    imagePullPolicy: IfNotPresent</p><p>​    command: [“/bin/sh”, “-c”, “sleep 3600” ]</p></blockquote><p>​    执行如下 Istio 注入命令：</p><blockquote><p>istioctl kube-inject -f jiuxi-busybox.yaml | kubectl apply -f -</p></blockquote><p>​    Istio 注入成功后，通过 kubectl exec 登录到 busybox 容器中，然后执行如下语句，验证 virtual service 和 destination rule 功能：</p><blockquote><p>curl <a href="http://jiuxi-svc:8080/"> http://jiuxi-svc:8080</a></p></blockquote><p>​    注意这里的客户端也必须经过 Istio 注入，因为只有客户端被 Istio 注入，客户端才可以接收到来自 Pilot server 端有关 virtual service 和 destination rule 的配置信息，才可以保证 Istio 的 traffic management 真正生效。</p><p>​    自此，九析带你轻松完爆 Istio virtual service + Destination Rule 功能。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - Istio traffic managem</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-Istio-traffic-managem/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-Istio-traffic-managem/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 流量管理概述</p><p>4 istio 流量管理 API 资源</p><hr><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585811911387303.png" srcset="/img/loading.gif" lazyload alt="第十八章 九析带你轻松完爆 service mesh - Istio traffic managem_istio 流量管理"></p><hr><h1 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h1><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585811940367841.png" srcset="/img/loading.gif" lazyload alt="第十八章 九析带你轻松完爆 service mesh - Istio traffic managem_istio traffic manag_02"></p><hr><h1 id="3-流量管理概述"><a href="#3-流量管理概述" class="headerlink" title="3 流量管理概述"></a>3 流量管理概述</h1><p>​    流量管理的本质就是采用策略控制流量的流向和大小。</p><p>​    Istio 流量管理模型依赖于随服务一起部署的 Envoy 代理，网格发送和接收的所有流量（数据平面流量）都通过 Envoy 进行代理。基于此模型可以轻松引导和控制网格周围的流量，而无需对服务进行任何更改。</p><hr><h1 id="4-istio-流量管理-API-资源"><a href="#4-istio-流量管理-API-资源" class="headerlink" title="4 istio 流量管理 API 资源"></a>4 istio 流量管理 API 资源</h1><p>​    为了在网格之间引导流量，Istio 需要知道执行端点在哪里（在 K8s 中就是 Pod），以及这些执行端点属于什么服务。而且 Istio 为了填充自己的服务注册表，会连接到  Istio 所安装平台上的服务发现系统。例如，如果 Istio 被安装到了 K8s 上，那么 Istio 就会自动发现集群中的服务和执行端点。</p><p>​    Istio 自身的服务注册表维护了一组服务以及这些服务背后真正的执行端点，Istio 使用服务注册表产生 Envoy 配置。Istio  本身并不提供服务发现功能，尽管大多数服务是由 Pilot 适配器自动添加到注册表中的，而这些 Pilot  适配器使用的是基础平台（K8s、Consul、纯 DNS）自身的发现服务。</p><p>​    使用此服务注册表，Envoy 代理就可以将流量定向到相关服务。大多数基于微服务的应用系统每个服务后面都会有多个实例处理服务流量。默认情况下，Envoy 代理使用 RoundBin 循环模型在每个服务实例之间平均分配流量。</p><p>​    虽然 Istio 的基本服务发现和负载均衡已经提供了一个有效的服务网格，但 Istio  提供的功能远不止这么多。在许多情况下，都希望对网格流量进行更加细粒度的控制。比如，可能希望将流量以百分比分配到不同的服务版本，作为 A/B  测试的一部分，或者将不同的负载均衡策略应用于特定服务实例版本，又或者你可能还想将特殊规则应用于进出网格的流量等等。以上这些都可以通过使用  Istio 流量管理 API 做到。</p><p>​    Istio 流量管理 API 资源如下：</p><blockquote><p>Virtual Service</p><p>Destination Rule</p><p>Gateway</p><p>Service entries</p><p>Sidecars</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - Istio 架构</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-Istio-%E6%9E%B6%E6%9E%84/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-Istio-%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 架构概述</p><p>4 流量概述</p><p>5 组件介绍</p><p>  5.1 Envoy</p><p>  5.2 Pilot</p><p>  5.3 Citadel</p><p>  5.4 Galley</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585732218872412.png" srcset="/img/loading.gif" lazyload alt="第十七章 九析带你轻松完爆 service mesh - Istio 架构_istio pilot"></p><hr><h2 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h2><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585732227589604.png" srcset="/img/loading.gif" lazyload alt="第十七章 九析带你轻松完爆 service mesh - Istio 架构_istio galley_02"></p><hr><h2 id="3-架构概述"><a href="#3-架构概述" class="headerlink" title="3 架构概述"></a>3 架构概述</h2><p>​    istio 服务网格逻辑上分为数据和控制两大平面。</p><blockquote><p>数据平面：由一组智能代理（envoy）组成，这些代理不仅控制和协调微服务之间的所有网络通信，同时也负责收集和汇报网格的遥测。</p><p>控制平面：制定、应用策略控制网络流量的路由。</p></blockquote><p>​    下图展示 istio 架构：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585732235663897.png" srcset="/img/loading.gif" lazyload alt="第十七章 九析带你轻松完爆 service mesh - Istio 架构_istio pilot_03"></p><hr><h2 id="4-流量概述"><a href="#4-流量概述" class="headerlink" title="4 流量概述"></a>4 流量概述</h2><p>​    由上可知，Istio 架构由数据面和控制面构成，那么 Istio 的流量也可以分为数据面流量和控制面流量。数据面流量是指微服务之间业务调用的流量，控制面流量是指 Istio 各组件之间配置和控制网格行为的流量。</p><p>Istio 中 traffic management 专指数据平面流量。</p><hr><h2 id="5-组件介绍"><a href="#5-组件介绍" class="headerlink" title="5 组件介绍"></a>5 组件介绍</h2><p>​    Istio 1.5.0 取消了原有的 Mixer 组件，保留了 Envoy、Pilot、Citadel、Galley 这 4 个核心的组件，这 4 个组件除了 Envoy 属于 Istio 数据面，其他都属于控制面。下面分别介绍如下：</p><h2 id="5-1-Envoy"><a href="#5-1-Envoy" class="headerlink" title="5.1 Envoy"></a>5.1 Envoy</h2><p>​    Envoy 是使用 C++ 开发的高性能代理，Istio 使用的是经过扩展过的 Envoy，Istio 中的 Envoy 作用是调解所有服务网格单元的入口和出口流量。同时 Envoy 也是与数据平面流量交互的唯一 Istio 组件。</p><p>因为 Envoy 被部署作为微服务的 sidecar，从而与微服务构成了一个有机的整体，所以从功能上自然就具备了 Envoy 的功能：</p><ul><li>动态服务发现</li><li>负载均衡</li><li>TLS 终止</li><li>HTTP/2 和 gRPC 代理</li><li>断路器</li><li>健康检查</li><li>分阶段滚动更新和基于百分比分配流量</li><li>失败注入</li><li>丰富的指标</li></ul><p>​    这种 sidecar 代理方式使 Istio 可以收集网络流量中特定信息作为指标（比如 HTTP 协议头的某些字段、目标 IP 等等），Istio 可以利用这些指标来实施策略，并将其发送给监控系统以报告整个网格行为。</p><p>Sidecar 代理模式允许使用者将 Istio 功能添加到现有微服务中，而无需重新构造或重写代码。</p><p>​    Envoy proxy 启用了一些 Istio 功能和任务，其中包括：</p><ul><li>流量控制功能：使用丰富的路由规则对 HTTP、gRPC、WebSocket 和 TCP 流量实施细粒度的流控</li><li>弹性网络功能：设置重试、故障转移、断路器和故障注入</li><li>安全和身份验证：通过资源部署的方式来应用安全策略、访问控制以及速率限制等功能特性</li><li>基于 WebAssembly 可插拔扩展模型，允许制定自定义策略和网格遥测流量规则</li></ul><h3 id="5-2-Pilot"><a href="#5-2-Pilot" class="headerlink" title="5.2 Pilot"></a>5.2 Pilot</h3><p>​    Pilot 提供 Envoy 边车服务发现、智能路由（比如 A/B 测试、金丝雀发布等）的流量管理能力、网络弹性（超时、重试、断路器等等）。</p><p>​    Pilot 将控制流量行为的高级路由规则转换为 Envoy 特定的配置，并在运行时将其传播给 sidecar。Pilot 抽取特定于平台的服务发现机制，并将其合成为任何符合 Envoy API 的 sidecar 都可以使用的标准格式。</p><p>​    下图展示了平台适配器如何跟 Envoy 代理如何交互：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585732247617501.png" srcset="/img/loading.gif" lazyload alt="第十七章 九析带你轻松完爆 service mesh - Istio 架构_istio envoy_04"></p><blockquote><p>1 平台启动一个服务的新实例，该实例通知其平台适配器</p><p>2 平台适配器将实例注册到 Pilot 抽象模型</p><p>3 Pilot 将流量规则和配置分发给 Envoy 代理通知其更改</p></blockquote><p>​    Pilot 这种设计使得 Istio 可以在 K8s、Consul 和 Nomad 等多种环境中运行，同时保持用于流量管理的相同操作界面。</p><p>​    可以使用 Istio 流控 API 通知 Pilot 转换为 Envoy 配置以达到更新粒度操控服务网格中的流量。</p><h3 id="5-3-Citadel"><a href="#5-3-Citadel" class="headerlink" title="5.3 Citadel"></a>5.3 Citadel</h3><p>​    Citadel 通过内置的身份认证和凭证管理实现了强大的服务到服务、用户到端的身份认证。可以使用 Citadel 升级网格中未加密的流量。运维人员可以通过  Citadel 基于服务身份而不是相对不稳定的第 3 层或第 4 层网络标识符来实施策略。</p><h3 id="5-4-Galley"><a href="#5-4-Galley" class="headerlink" title="5.4 Galley"></a>5.4 Galley</h3><p>​    Galley 是 Istio 验证、提取、处理和分发配置的组件。它负责将其余 Istio 组件与底层平台（例：K8S）获取用户配置的细节隔离开。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - istio kiali jaeger 关联</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-kiali-jaeger-%E5%85%B3%E8%81%94/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-kiali-jaeger-%E5%85%B3%E8%81%94/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 jaeger 介绍</p><p>4 jaeger 安装</p><p>5 jaeger 配置</p><p>6 kiali 关联 jaeger</p><p>7 设置 kiali jaeger 外部链接地址</p><p>8 kiali jaeger 流量关联</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585214264302331.png" srcset="/img/loading.gif" lazyload alt="第十六章 九析带你轻松完爆 service mesh - istio kiali jaeger 关联_istio kiali"></p><hr><h2 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h2><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585214272975021.png" srcset="/img/loading.gif" lazyload alt="第十六章 九析带你轻松完爆 service mesh - istio kiali jaeger 关联_jaeger_02"></p><hr><h2 id="3-jaeger-介绍"><a href="#3-jaeger-介绍" class="headerlink" title="3 jaeger 介绍"></a>3 jaeger 介绍</h2><p>​    jaeger 官网请<a href="https://www.jaegertracing.io/"> 点击</a>。</p><p>​    jaeger 是 Uber 开源的分布式跟踪系统，用于微服务的监控和全链路跟踪，其设计思想来自于 Dapper 和 zipkin。jaeger 特征包括：</p><blockquote><p>分布式上下文传播</p><p>分布式事务监控</p><p>Root 原因分析</p><p>服务依赖性分析</p><p>性能/延迟优化</p></blockquote><p>​    本博客主要介绍将 istio、kiali、jaeger 关联在一起形成一个统一的整体。istio 版本采用的是 1.5.0。有关 istio 和 kiali 组件如何安装和使用，请参考本人的连载博客《<a href="https://blog.51cto.com/14625168/2474277"> 轻松完爆 istio 系列</a>》。如果你觉得不过瘾，也可以看我的免费视频，相信你会听得很开心。</p><hr><h2 id="4-jaeger-安装"><a href="#4-jaeger-安装" class="headerlink" title="4 jaeger 安装"></a>4 jaeger 安装</h2><p>​    如果你使用 istioctl profile demo 安装 istio 的话，jaeger 默认就是安装好的。你可以参考《<a href="https://blog.51cto.com/14625168/2474224"> 轻松完爆 istio 安装</a>》轻松完爆 jaeger 的安装。</p><p>​    安装后的截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585214282847517.png" srcset="/img/loading.gif" lazyload alt="第十六章 九析带你轻松完爆 service mesh - istio kiali jaeger 关联_istio 教程_03"></p><hr><h2 id="5-jaeger-配置"><a href="#5-jaeger-配置" class="headerlink" title="5 jaeger 配置"></a>5 jaeger 配置</h2><p>​    为了可以将 jaeger 暴露在 k8s 集群外访问，需要将 jaeger-query 的 ClusterIP 服务类型更改为 NodePort。执行语句如下，执行结果如上截图所示：</p><blockquote><p>kubectl patch svc -n istio-system jaeger-query -p ‘{“spec”:{“type”: “NodePort”}}’</p></blockquote><hr><p>6 kiali 关联 jaeger</p><p>​    kiali 是可视化服务网格组件，截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585214292159255.png" srcset="/img/loading.gif" lazyload alt="第十六章 九析带你轻松完爆 service mesh - istio kiali jaeger 关联_istio 视频_04"></p><p>​    点击上面箭头 Distributed Tracing 链接可以打开 jaeger。如果访问不到，说明你本地的浏览器并不能直接访问到 kiali 设置的 jaeger 外部链接。</p><hr><h2 id="7-设置-kiali-jaeger-外部链接地址"><a href="#7-设置-kiali-jaeger-外部链接地址" class="headerlink" title="7 设置 kiali jaeger 外部链接地址"></a>7 设置 kiali jaeger 外部链接地址</h2><p>​    编辑 kiali configmap：</p><blockquote><p>kubectl edit configmap -n istio-system kiali</p></blockquote><p>​    在 external_services.tracing.url 内容下添加 jaeger 外部链接，链接地址就是 istio-system 命名空间下 jaeger-query 服务的宿主机地址和 nodeport。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585214303810615.png" srcset="/img/loading.gif" lazyload alt="第十六章 九析带你轻松完爆 service mesh - istio kiali jaeger 关联_jaeger_05"></p><p>​    添加内容如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585214310647910.png" srcset="/img/loading.gif" lazyload alt="第十六章 九析带你轻松完爆 service mesh - istio kiali jaeger 关联_istio 教程_06"></p><p>​    编辑 kiali configmap 后，需要删除并重新生成 kiali pod，好让配置挂载生效，执行语句如下：</p><blockquote><p>kubectl delete pod -n istio-system $(kubectl get pod -n istio-system | grep -i kiali | awk ‘{print $1}’)</p></blockquote><p>​    执行完后，再次查看 kiali pod，发现 url 值已经生效：</p><blockquote><p># 注意 kiali pod 根据自己情况填写，不要直接照抄哥的</p><p>kubectl exec -it -n istio-system kiali-76f556db6d-88vtd – cat /kiali-configuration/config.yaml</p></blockquote><p>​    命令直接结果如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585214318470229.png" srcset="/img/loading.gif" lazyload alt="第十六章 九析带你轻松完爆 service mesh - istio kiali jaeger 关联_istio 视频_07"></p><p>​    再次访问 kiali，发现 Distributed Tracing 链接可以访问，并且可以打开 jaeger 页面，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585214326580895.png" srcset="/img/loading.gif" lazyload alt="第十六章 九析带你轻松完爆 service mesh - istio kiali jaeger 关联_istio kiali_08"></p><hr><h2 id="8-kiali-jaeger-流量关联"><a href="#8-kiali-jaeger-流量关联" class="headerlink" title="8 kiali jaeger 流量关联"></a>8 kiali jaeger 流量关联</h2><p>​    以上的操作中通过 kiali 可以打开 jaeger 了，还可以通过实际流量将 kiali 和 jaeger 关联起来，首先打入一些流量，这里采用的是 istio 的官方用例 bookinfo：【必须注意：一定要放入网格才可以看到流量】</p><blockquote><p>while true; do curl 10.98.126.37/productpage; done</p></blockquote><p>​    访问 kiali 的 service 菜单标签：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585214335780595.png" srcset="/img/loading.gif" lazyload alt="第十六章 九析带你轻松完爆 service mesh - istio kiali jaeger 关联_istio 教程_09"></p><p>​    双击 productpage 进入微服务，然后选择标签页 Traces，再点击蓝色圆圈（trace 点）后会显示该 tracing 的路径信息，然后再选择链接（View Trace in Tracing）：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585214344969895.png" srcset="/img/loading.gif" lazyload alt="第十六章 九析带你轻松完爆 service mesh - istio kiali jaeger 关联_jaeger_10"></p><p>​    点击后的 jaeger 截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585214352837969.png" srcset="/img/loading.gif" lazyload alt="第十六章 九析带你轻松完爆 service mesh - istio kiali jaeger 关联_jaeger_11"></p><p>​    自此，九析带你轻松完爆 istio、kiali、jaeger 的关联。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - istio kiali 亲和性调度</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-kiali-%E4%BA%B2%E5%92%8C%E6%80%A7%E8%B0%83%E5%BA%A6/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-kiali-%E4%BA%B2%E5%92%8C%E6%80%A7%E8%B0%83%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 节点调度</p><p>  3.1 节点打标</p><p>  3.2 编写 pod</p><p>4 kiali 亲和性调度</p><p>  4.1 举个例子</p><p>  4.2 节点亲和性调度（NodeAffinity）</p><p>  4.3 kiali 节点亲和性调度</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585126831588294.png" srcset="/img/loading.gif" lazyload alt="第十五章 九析带你轻松完爆 service mesh - istio kiali 亲和性调度_istio nodeaffinity"></p><hr><h2 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h2><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585126838978145.png" srcset="/img/loading.gif" lazyload alt="第十五章 九析带你轻松完爆 service mesh - istio kiali 亲和性调度_istio 教程_02"></p><hr><h2 id="3-节点调度"><a href="#3-节点调度" class="headerlink" title="3 节点调度"></a>3 节点调度</h2><p>​    在开始 kiali 亲和性调度之前，先演示一个简单的例子介绍 pod 选择调度到指定 node：</p><h3 id="3-1-节点打标"><a href="#3-1-节点打标" class="headerlink" title="3.1 节点打标"></a>3.1 节点打标</h3><p>​    使用命令查看当前所有 k8s 节点：</p><blockquote><p>kubectl get nodes</p></blockquote><p>​    命令截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585126886611373.png" srcset="/img/loading.gif" lazyload alt="第十五章 九析带你轻松完爆 service mesh - istio kiali 亲和性调度_istio 视频_03"></p><p>​    现在给 k8s-w-206 这个节点打上一个标签，标签内容为 name: jiuxi，命令如下：</p><blockquote><p>kubectl label node k8s-w-206 name=jiuxi</p></blockquote><h3 id="3-2-编写-pod"><a href="#3-2-编写-pod" class="headerlink" title="3.2 编写 pod"></a>3.2 编写 pod</h3><p>​    编写 pod 资源文件 jiuxi-pod.yaml，文件中使用 nodeSelector 指定该 pod 要调度到 k8s-w-206 节点之上：</p><blockquote><p>apiVersion: v1</p><p>kind: Pod</p><p>metadata:</p><p>  labels:</p><p>​    app: busybox</p><p>​    name: busybox</p><p>spec:</p><p>  containers:</p><p>  - name: busybox</p><p>​    image: busybox</p><p>​    imagePullPolicy: IfNotPresent</p><p>​    command: [ “/bin/sh”, “-c”, “sleep 3600” ]</p><p>​      <strong>nodeSelector:</strong></p><p>​       <strong>name: jiuxi</strong></p></blockquote><p>​    部署 jiuxi-pod.yaml，发现 pod 果然被调度到了 k8s-w-206 这个 node，截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585126896217808.png" srcset="/img/loading.gif" lazyload alt="第十五章 九析带你轻松完爆 service mesh - istio kiali 亲和性调度_istio jaeger_04"></p><hr><h2 id="4-kiali-亲和性调度"><a href="#4-kiali-亲和性调度" class="headerlink" title="4 kiali 亲和性调度"></a>4 kiali 亲和性调度</h2><p>​    上面举例 pod 使用 nodeSelector 选择 node，这就是最简单的 k8s 调度方式。而 kiali 调度方式复杂一些，使用的是节点亲和性调度策略，使用如下命令查看：</p><blockquote><p>kubectl get deployments.apps kiali -n istio-system -o yaml</p></blockquote><p>​    命令执行结果部分显示如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585126904929592.png" srcset="/img/loading.gif" lazyload alt="第十五章 九析带你轻松完爆 service mesh - istio kiali 亲和性调度_istio 视频_05"></p><h3 id="4-1-举个例子"><a href="#4-1-举个例子" class="headerlink" title="4.1 举个例子"></a>4.1 举个例子</h3><p>​    举一个生活的例子，以前去医院看病，病人（pod）不能挑医生（node），排队叫到谁就是谁，冷冰冰完全没有亲和性而言；如今可以网上挂号了，病人也可以挑选中意的医生，这样就有了亲和性，说明社会进步了。</p><p>​    当然病人在挑选医生的过程中也会有两种情况：一种是硬性（required），比如非要某医生，即使他忙，也愿意一直等下去；还有一种是软性（prefered），比如优先选择某医生，但是如果真不行，其他医生也未尝不可。</p><h3 id="4-2-节点亲和性调度（NodeAffinity）"><a href="#4-2-节点亲和性调度（NodeAffinity）" class="headerlink" title="4.2 节点亲和性调度（NodeAffinity）"></a>4.2 节点亲和性调度（NodeAffinity）</h3><p>​    下面的理论可以对照上面的例子。</p><p>​    节点亲和性，也就是 NodeAffinity，用来控制 pod 部署或者不能部署在哪台机器上。</p><p>​    节点亲和性调度策略分为硬策略分为软策略和硬策略两种方式。硬策略是如果没有满足条件的节点，就会不断重试直到条件满足了为止；软策略是如果没有满足条件的节点，pod 就会忽略这条规则，继续完成调度过程。</p><p>​    节点亲和性软硬策略的语法分别介绍如下。</p><ul><li><ul><li>硬策略（关键字 require）：</li></ul></li></ul><blockquote><p>requiredDuringSchedulingIgnoredDuringExecution：</p><p>pod 必须部署到满足条件的节点上，如果节点不满足条件，就不停重试。IgnoreDuringExecution 表示 pod 部署成功后，如果节点标签发生了变化，不再满足 pod 指定的条件，pod 仍会在此节点继续运行</p></blockquote><ul><li><ul><li>软策略（关键字 prefer）：</li></ul></li></ul><blockquote><p>preferredDuringSchedulingIgnoredDuringExecution：</p><p>pod 优先部署到满足条件的节点，如果节点不满足条件，就忽略这些条件，调度到其他节点。</p><p>IgnoredDuringExecution 表示 pod 部署成功后，如果节点标签发生变化，不再满足 pod 指定条件，pod 仍会在此节点继续运行</p></blockquote><h3 id="4-3-kiali-节点亲和性调度"><a href="#4-3-kiali-节点亲和性调度" class="headerlink" title="4.3 kiali 节点亲和性调度"></a>4.3 kiali 节点亲和性调度</h3><p>​    kiali 节点亲和性调度如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585126913155121.png" srcset="/img/loading.gif" lazyload alt="第十五章 九析带你轻松完爆 service mesh - istio kiali 亲和性调度_istio 视频_06"></p><p>​    由图可知，kiali pod 有两个节点亲和性调度策略，一个软策略，一个硬策略。硬策略要求节点  beta.kubernetes.io/arch 标签值必须是  amd64, ppc64le，s390x 三个值之一，如果节点不满足此硬策略，pod 就会一直处于 pending  状态；当满足了此硬策略之后，pod 调度还要经过软策略调度，即：软策略要求节点 beta.kubernetes.io/arch 标签值为  amd64，ppc64le 和 s390x，并且不偏不倚，权重都是 2。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - istio kiali 内部介绍</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-kiali-%E5%86%85%E9%83%A8%E4%BB%8B%E7%BB%8D/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-kiali-%E5%86%85%E9%83%A8%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 预备知识</p><p>4 kiali 组件分析</p><p>5 config.yaml 文件</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585037381430496.png" srcset="/img/loading.gif" lazyload alt="第十四章 九析带你轻松完爆 service mesh - istio kiali 内部介绍_istio jaeger"></p><hr><h2 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h2><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585037389192861.png" srcset="/img/loading.gif" lazyload alt="第十四章 九析带你轻松完爆 service mesh - istio kiali 内部介绍_istio kiali_02"></p><hr><h2 id="3-预备知识"><a href="#3-预备知识" class="headerlink" title="3 预备知识"></a>3 预备知识</h2><p>​    有关 kiali 介绍、安装和使用请参考本人上三篇博客《<a href="https://blog.51cto.com/14625168/2474277"> 九析带你轻松完爆 istio 服务网格系列教程</a>》。这里介绍 istio 1.5.0 kiali 组件。</p><hr><h2 id="4-kiali-组件分析"><a href="#4-kiali-组件分析" class="headerlink" title="4 kiali 组件分析"></a>4 kiali 组件分析</h2><p>​    使用如下命令查看 kiali pod 详情：</p><blockquote><p>kubectl edit pod -n istio-system $(kubectl get pods -n istio-system | grep -i kiali | awk ‘{print $1}’)</p></blockquote><p>​    kiali pod 内只有一个容器，名称为 kiali。该容器在启动的过程中会运行容器内 kiali 进程，该进程会加载  /kiali-configuration/config.yaml 配置文件，该 config.yaml 文件定义了 kiali  进程运行时行为。pod 详情截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585037398490557.png" srcset="/img/loading.gif" lazyload alt="第十四章 九析带你轻松完爆 service mesh - istio kiali 内部介绍_istio jaeger_03"></p><p>​    kiali pod 内 /kiali-configuration/config.yaml 配置文件是通过挂载 configmap 获取到的，如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585037408977832.png" srcset="/img/loading.gif" lazyload alt="第十四章 九析带你轻松完爆 service mesh - istio kiali 内部介绍_istio prometheus_04"></p><p>​    configmap 信息如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585037415874758.png" srcset="/img/loading.gif" lazyload alt="第十四章 九析带你轻松完爆 service mesh - istio kiali 内部介绍_istio jaeger_05"></p><p>​    可以通过语句查看 kiali configmap 内容：</p><blockquote><p>kubectl edit configmap -n istio-system kiali</p></blockquote><p>​    kiali configmap 内容截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585037422449402.png" srcset="/img/loading.gif" lazyload alt="第十四章 九析带你轻松完爆 service mesh - istio kiali 内部介绍_istio 视频_06"></p><p>​    由上图可知，configmap 最终会以 config.yaml 文件的形式挂载到 kiali pod 中的 /kiali-configuration 目录下，登录 kiali pod 查看，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585037430405547.png" srcset="/img/loading.gif" lazyload alt="第十四章 九析带你轻松完爆 service mesh - istio kiali 内部介绍_istio kiali_07"></p><hr><h2 id="5-config-yaml-文件"><a href="#5-config-yaml-文件" class="headerlink" title="5 config.yaml 文件"></a>5 config.yaml 文件</h2><p>​    config.yaml 内容截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1585037437643708.png" srcset="/img/loading.gif" lazyload alt="第十四章 九析带你轻松完爆 service mesh - istio kiali 内部介绍_istio jaeger_08"></p><p>​    该配置文件定义了 kiali 行为，下面分别介绍如下：</p><p>​    首先声明 istio 自身以及 istio 插件在 k8s 哪个命名空间下：</p><blockquote><p># istio 插件 grafana、tracing、pilot、prometheus</p><p>grafana: istio-system</p><p>tracing: istio-system</p><p>pilot: istio-system</p><p>prometheus: istio-system</p><p># istio 自身</p><p>istio_namespace: istio-system</p></blockquote><p>​    其次介绍 kiali 鉴权方式：</p><blockquote><p>auth:</p><p>  strategy: login  # 通过 login 方式进行鉴权</p></blockquote><p>​    再次介绍 kiali deployment 可以访问的 k8s 命名空间：</p><blockquote><p>deployment:</p><p>  accessible_namespaces: [‘**’]        # 没有限制，可访问任何命名空间</p></blockquote><p>​    接着介绍 kiali 对外服务的端口号和访问路径：</p><blockquote><p>server:</p><p>  port: 20001</p><p>  web_root: /kiali</p></blockquote><p>​    最后介绍 kiali 访问 istio、istio 插件（tracing、grafana、promethues）的 url 地址。注意该 url 必须是可以直接访问到的真实地址。</p><blockquote><p>external_services:</p><p>  istio:</p><p>​    url_service_version: <a href="http://istio-pilot.istio-system:8080/version">http://istio-pilot.istio-system:8080/version</a></p><p>  tracing:</p><p>​    url:</p><p>​    in_cluster_url: <a href="http://tracing/jaeger">http://tracing/jaeger</a></p><p>  grafana:</p><p>​    url:</p><p>​    in_cluster_url: <a href="http://grafana:3000/">http://grafana:3000</a></p><p>  prometheus:</p><p>​    url: <a href="http://prometheus.istio-system:9090/">http://prometheus.istio-system:9090</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - istio kiali bookinfo</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-kiali-bookinfo/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-kiali-bookinfo/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 安装 istio</p><p>4 安装 bookinfo 应用</p><p>5 设置 kiali</p><p>6 kiali 可视化 bookinfo</p><p>7 注入和观察流量</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584675889827788.png" srcset="/img/loading.gif" lazyload alt="第十三章 九析带你轻松完爆 service mesh - istio kiali bookinfo_istio 学习"></p><hr><h2 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h2><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584675897514592.png" srcset="/img/loading.gif" lazyload alt="第十三章 九析带你轻松完爆 service mesh - istio kiali bookinfo_istio kiali bookinf_02"></p><hr><h2 id="3-安装-istio"><a href="#3-安装-istio" class="headerlink" title="3 安装 istio"></a>3 安装 istio</h2><p>​    istio 安装教程请参考本人的博客《<a href="https://blog.51cto.com/14625168/2474224"> istio 安装</a>》。</p><hr><h2 id="4-安装-bookinfo-应用"><a href="#4-安装-bookinfo-应用" class="headerlink" title="4 安装 bookinfo 应用"></a>4 安装 bookinfo 应用</h2><p>​    bookinfo 是 istio 官方提供的样例程序。有关安装、istio 注入请参考本人的博客《<a href="https://blog.51cto.com/14625168/2474914"> istio bookinfo 应用</a>》。</p><hr><h2 id="5-设置-kiali"><a href="#5-设置-kiali" class="headerlink" title="5 设置 kiali"></a>5 设置 kiali</h2><p>​    kiali 是使用 istioctl 客户端工具安装 demo profile 时自动就会安装的组件，kiali 是一款 istio 服务网格可视化工具，提供了服务拓补图、全链路跟踪、指标遥测、配置校验、健康检查等功能。</p><p>​    有关 kiali 的配置和简单使用请参考本人的博客《<a href="https://blog.51cto.com/14625168/2479715"> kiali 安装</a>》和《<a href="https://blog.51cto.com/14625168/2479767"> kiali 使用</a>》。</p><hr><h2 id="6-kiali-可视化-bookinfo"><a href="#6-kiali-可视化-bookinfo" class="headerlink" title="6 kiali 可视化 bookinfo"></a>6 kiali 可视化 bookinfo</h2><p>​    登录 kiali，进入 overview 菜单，选中 bookinfo 应用，如下图所示，本人布置在 jiuxi 命名空间：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584675907738139.png" srcset="/img/loading.gif" lazyload alt="第十三章 九析带你轻松完爆 service mesh - istio kiali bookinfo_istio 视频_03"></p><p>​    点击进入 jiuxi 命名空间下的 “4 Applications” ， 进入 “Applications” 视图，可见 bookinfo 样例下的 4 个微服务，并且当前这 4 个微服务状态都健康（Health ✔）如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584675915689224.png" srcset="/img/loading.gif" lazyload alt="第十三章 九析带你轻松完爆 service mesh - istio kiali bookinfo_istio kiali_04"></p><p>​    最关键的可视化内容可以查看 “Graph” 菜单，如下所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584675923857146.png" srcset="/img/loading.gif" lazyload alt="第十三章 九析带你轻松完爆 service mesh - istio kiali bookinfo_kiali bookinfo_05"></p><p>​    下面重点介绍 “Graph” 视图下的功能：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584675930269547.png" srcset="/img/loading.gif" lazyload alt="第十三章 九析带你轻松完爆 service mesh - istio kiali bookinfo_istio 学习_06"></p><blockquote><p>1 命名空间</p><p>2 分类图展示：app（应用视角，label 名为 app，并且 app 值相同的资源算作一类  app）、service（k8s服务视角）、versioned app（标记版本应用视角）、workload（k8s工作负载视角，比如  deployment、job、statefulset、daemonset）</p><p>3 指标展示：Requests per second（每秒多少请求）、Requests percent（请求分布占比）、Response time（响应时间）</p><p>4 显示过滤器：各种显示开关，用复选框表示；可以选择 Traffic Animation，爽爽看</p><p>5 规格过滤显示：可以把它类比为 grep 命令，通过定义好的过滤规则，高亮图的某些组件或元素，比如在 find 字段输入 httpout &gt; 0.5 后回车，可看到如下截图所示</p><p>6 三角形表示 k8s 服务</p><p>7 圆形表示 k8s workload</p><p>8 时间间隔的流量选择器：比如 1m（分钟）、5m、10m、30m、1h（小时）、3h、6h</p><p>9 页面刷新频率：比如每 10 秒、每 15 秒、每 30 秒、每 1 分钟、每 5 分钟、每 15 分钟</p><p>10 命名空间</p><p>11 入口流量、出口流量和总流量显示</p><p>12 图例说明：解释图中各个形状各代表什么意思</p><p>13 layout：不同展示风格（共有三种，选择自己的喜好）</p></blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584675942103722.png" srcset="/img/loading.gif" lazyload alt="第十三章 九析带你轻松完爆 service mesh - istio kiali bookinfo_istio kiali bookinf_07"></p><hr><h2 id="7-注入和观察流量"><a href="#7-注入和观察流量" class="headerlink" title="7 注入和观察流量"></a>7 注入和观察流量</h2><p>​    选择 ingressgateway svc，通过如下指令：</p><blockquote><p>kubectl get svc -n istio-system -o wide    # jiuxi 是我自定义命名空间</p></blockquote><p>​    执行结果如下图：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584675950551018.png" srcset="/img/loading.gif" lazyload alt="第十三章 九析带你轻松完爆 service mesh - istio kiali bookinfo_kiali bookinfo_08"></p><p>​    因为服务类型是 NodePort，所以 ip 要选择宿主机 ip，而不是 svc cluster-ip 或者是 pod ip，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584675958536850.png" srcset="/img/loading.gif" lazyload alt="第十三章 九析带你轻松完爆 service mesh - istio kiali bookinfo_istio kiali_09"></p><p>​    通过 curl 命令打入流量：</p><blockquote><p>while true; do curl <a href="http://10.110.101.98:30100/productpage">http://10.110.101.98:30100/productpage</a>; done</p></blockquote><p>​    通过 kiali graph 视图:</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584675965312153.png" srcset="/img/loading.gif" lazyload alt="第十三章 九析带你轻松完爆 service mesh - istio kiali bookinfo_kiali bookinfo_10"></p><p>​    自此，九析带你轻松完爆 istio kiali bookinfo 应用。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - istio kiali 使用篇</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-kiali-%E4%BD%BF%E7%94%A8%E7%AF%87/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-kiali-%E4%BD%BF%E7%94%A8%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 kiali 控制台</p><p>  3.1 Overview（概观）</p><p>  3.2 Application（应用维度）</p><p>  3.3 workloads（负载维度）</p><p>  3.4 Services（服务维度）</p><p>  3.5 Istio Config（配置维度）</p><p>  3.6 Distributed Tracing（分布式追踪维度）</p><p>4 kiali 架构</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584520514843229.png" srcset="/img/loading.gif" lazyload alt="第十二章 九析带你轻松完爆 service mesh - istio kiali 使用篇_kiali"></p><hr><h2 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h2><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584520523824579.png" srcset="/img/loading.gif" lazyload alt="第十二章 九析带你轻松完爆 service mesh - istio kiali 使用篇_istio kiali_02"></p><hr><h2 id="3-kiali-控制台"><a href="#3-kiali-控制台" class="headerlink" title="3 kiali 控制台"></a>3 kiali 控制台</h2><p>​    kiali 控制台菜单截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584520596533648.png" srcset="/img/loading.gif" lazyload alt="第十二章 九析带你轻松完爆 service mesh - istio kiali 使用篇_istio kiali_03"></p><h3 id="3-1-Overview（概观）"><a href="#3-1-Overview（概观）" class="headerlink" title="3.1 Overview（概观）"></a>3.1 Overview（概观）</h3><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584520614680521.png" srcset="/img/loading.gif" lazyload alt="第十二章 九析带你轻松完爆 service mesh - istio kiali 使用篇_istio kiali_04"></p><p>​    该菜单全局性展示所有命名空间下服务的流量（traffic）、配置状态（config status）、健康状态（✔）、应用数量（Applications）等。</p><h3 id="3-2-Application（应用维度）"><a href="#3-2-Application（应用维度）" class="headerlink" title="3.2 Application（应用维度）"></a>3.2 Application（应用维度）</h3><p>​    applications 指运行中的应用，kiali 独有概念。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584520628534290.png" srcset="/img/loading.gif" lazyload alt="第十二章 九析带你轻松完爆 service mesh - istio kiali 使用篇_kiali 安装_05"></p><p>​    特别注意 kiali 只能识别设置了 app 标签的应用。如果一个应用有多个版本，需要将这几个版本的 app 标签设置为相同的值。</p><p>​    执行如下命令查看 default 命名空间的 deployment：</p><blockquote><p>kubectl get deployments.apps –show-labels</p></blockquote><p>​    命令结果如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911213848142.png" srcset="/img/loading.gif" lazyload alt="image-20210911213848142"></p><p>​    从执行结果来看，default 空间下有 2 个 deployment，但是只有一个 deployment 的标签具有 app 标识，因此在 kiali 中只显示出了 nfs-client-provisioner 应用。</p><h3 id="3-3-workloads（负载维度）"><a href="#3-3-workloads（负载维度）" class="headerlink" title="3.3 workloads（负载维度）"></a>3.3 workloads（负载维度）</h3><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584520645575695.png" srcset="/img/loading.gif" lazyload alt="第十二章 九析带你轻松完爆 service mesh - istio kiali 使用篇_kiali_07"></p><p>​    kiali 中的负载（workloads）跟 k8s 中的资源对应（比如 deployment、Job、Daemonset、Statefulset  等）。k8s 中的这些资源都可以在 kiali 中检测到，不管这些资源有没有加入到 istio 服务网格中。</p><h3 id="3-4-Services（服务维度）"><a href="#3-4-Services（服务维度）" class="headerlink" title="3.4 Services（服务维度）"></a>3.4 Services（服务维度）</h3><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584520655713870.png" srcset="/img/loading.gif" lazyload alt="第十二章 九析带你轻松完爆 service mesh - istio kiali 使用篇_kiali_08"></p><p>​    对应 k8s 的 service 资源类型。</p><h3 id="3-5-Istio-Config（配置维度）"><a href="#3-5-Istio-Config（配置维度）" class="headerlink" title="3.5 Istio Config（配置维度）"></a>3.5 Istio Config（配置维度）</h3><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584520663652461.png" srcset="/img/loading.gif" lazyload alt="第十二章 九析带你轻松完爆 service mesh - istio kiali 使用篇_kiali 安装_09"></p><p>​    istio 相关配置类信息。比如这里选择 istio type 类型，将显示有关 istio 服务网格下面的各个类型对应的配置信息状态（✔ 表示配置有效；！表示告警），如上图所示。</p><p>3.6 Distributed Tracing（分布式追踪维度）</p><h3 id="有关分布式追踪跟其他组件有关（jaeger），以后会详述。"><a href="#有关分布式追踪跟其他组件有关（jaeger），以后会详述。" class="headerlink" title="有关分布式追踪跟其他组件有关（jaeger），以后会详述。"></a>有关分布式追踪跟其他组件有关（jaeger），以后会详述。</h3><hr><h2 id="4-kiali-架构"><a href="#4-kiali-架构" class="headerlink" title="4 kiali 架构"></a>4 kiali 架构</h2><p>​    下图是 kiali 架构：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584520675671264.png" srcset="/img/loading.gif" lazyload alt="第十二章 九析带你轻松完爆 service mesh - istio kiali 使用篇_istio kiali 安装_10"></p><p>​    由架构图可知，kiali 架构还是比较简单的，属于单体应用。kiali 后台既可以跟外部服务 prometheus、cluster API 进行通信获取 istio  服务网格信息，也可以集成可选服务 jaeger 和 grafana做全链路跟踪和可视化指标度量。</p><p>​    自此，九析带你轻松完爆 istio kiali 使用。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - istio kiali 安装</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-kiali-%E5%AE%89%E8%A3%85/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-kiali-%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 邀约</p><p>3 kiali 简介</p><p>4 kiali 安装</p><p>5 kiali 访问</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584516653984882.png" srcset="/img/loading.gif" lazyload alt="第十一章 九析带你轻松完爆 service mesh - istio kiali 安装_kiali jaeger"></p><hr><h2 id="2-邀约"><a href="#2-邀约" class="headerlink" title="2 邀约"></a>2 邀约</h2><p>​    你可以从 b 站搜索 “九析”，获取免费的、更生动的视频资料：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584516661797993.png" srcset="/img/loading.gif" lazyload alt="第十一章 九析带你轻松完爆 service mesh - istio kiali 安装_kaili_02"></p><hr><h2 id="3-kiali-简介"><a href="#3-kiali-简介" class="headerlink" title="3 kiali 简介"></a>3 kiali 简介</h2><p>​    kiali 是一款 istio 服务网格可视化工具，提供了服务拓补图、全链路跟踪、指标遥测、配置校验、健康检查等功能。</p><hr><h2 id="4-kiali-安装"><a href="#4-kiali-安装" class="headerlink" title="4 kiali 安装"></a>4 kiali 安装</h2><p>​    如果使用 istioctl 安装 istio 时采用的 profile 是 demo 的话（有关 profile 介绍，请参照本人的《 <a href="https://blog.51cto.com/14625168/2479111"> istioctl profile 介绍</a>》），默认就会安装好 kiali。istio 安装请参照本人的《<a href="https://blog.51cto.com/14625168/2474224"> istio 安装</a>》博客分分钟轻松完爆。安装好后，直接执行如下命令查看 kiali 组件：</p><blockquote><p>kubectl get all -n istion-system</p></blockquote><p>​    执行结果如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584516715612147.png" srcset="/img/loading.gif" lazyload alt="第十一章 九析带你轻松完爆 service mesh - istio kiali 安装_istio 学习_03"></p><hr><h2 id="5-kiali-访问"><a href="#5-kiali-访问" class="headerlink" title="5 kiali 访问"></a>5 kiali 访问</h2><p>​    在集群内，通过 curl 命令行工具访问 kiali：</p><blockquote><p>curl <a href="http://10.101.30.105:20001/"> http://10.101.30.105:20001</a></p></blockquote><p>​    执行结果如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584516724636987.png" srcset="/img/loading.gif" lazyload alt="第十一章 九析带你轻松完爆 service mesh - istio kiali 安装_kiali jaeger_04"></p><p>​    上图所示 kiali 已经部署成功，服务处于就绪状态。下面改成外部浏览器可以直接访问，需要将 service 的服务类型设置为 nodeport，执行命令如下：</p><blockquote><p>kubectl patch svc -n istio-system kiali -p ‘{“spec”: {“type”: “NodePort”}}’</p></blockquote><p>​    执行结果如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584516731417402.png" srcset="/img/loading.gif" lazyload alt="第十一章 九析带你轻松完爆 service mesh - istio kiali 安装_istio 视频_05"></p><p>​    打开浏览器，访问 k8s 所在服务器 IP 和 NodePort 暴露出来的端口号（这里是 31479），如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584516740649530.png" srcset="/img/loading.gif" lazyload alt="第十一章 九析带你轻松完爆 service mesh - istio kiali 安装_istio kiali_06"></p><p>​    默认用户名密码是 admin/admin，输入后登录：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584516749156466.png" srcset="/img/loading.gif" lazyload alt="第十一章 九析带你轻松完爆 service mesh - istio kiali 安装_istio kiali_07"></p><p>​    自此，九析带你轻松完爆 istio kiali 安装。关于 kiali 说明和使用将在下章说明。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - istio profile 详述</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-profile-%E8%AF%A6%E8%BF%B0/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-profile-%E8%AF%A6%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 istio 之 profile</p><p>3 istioctl profile</p><p>  3.1 demo</p><p>  3.2 minimal</p><p>  3.3 default</p><p>  3.4 empty</p><p>  3.5 remote</p><p>  3.6 separate</p><p>4 总结</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584368141584701.jpeg" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 service mesh - istio profile 详述_istio 安装"></p><p>​    你可以从下面截图中获取免费的、更生动的视频资料：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584440587356556.png" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 service mesh - istio profile 详述_istio 视频_02"></p><hr><h2 id="2-istio-之-profile"><a href="#2-istio-之-profile" class="headerlink" title="2 istio 之 profile"></a>2 istio 之 profile</h2><p>​    在介绍 istio profile 之前，我们先介绍一下电信的套餐：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584368156493068.png" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 service mesh - istio profile 详述_istio 教程_03"></p><p>​    我们去电信开通手机业务时，一般都会选择手机套餐，不同的手机套餐会提供不同的增值服务。如上图所示，每个套餐就是一个 profile。istioctl 在安装 istio 时提供的 profile 概念与此类似，不同 profile 定义了不同的 istio  控制面行为。</p><hr><h2 id="3-istioctl-profile"><a href="#3-istioctl-profile" class="headerlink" title="3 istioctl profile"></a>3 istioctl profile</h2><p>​    使用如下命令查看 istioctl  profile：</p><blockquote><p>istioctl profile list</p></blockquote><p>​    执行结果如下图所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584368172412822.png" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 service mesh - istio profile 详述_istio profile_04"></p><h3 id="3-1-demo"><a href="#3-1-demo" class="headerlink" title="3.1 demo"></a>3.1 demo</h3><p>​    demo profile 仅供学习使用，并不合适作为生产环境。该 profile 会安装  ingressgateway、egressgateway、istio-pilot 等 istio 组件，同时会安装  grafana、istio-tracing、kiali、prometheus 等外部插件。使用如下命令查看 demo profile 的  istio 安装配置清单：</p><blockquote><p>istioctl profile dump demo</p></blockquote><p>​    从 dump 出的 profile 来看，最重要的是两块配置：插件和组件。插件是指外部第三方依赖，比如  grafana、kiali、prometheus、tracing；组件是指 istio 自身的组件，比如  citadel、egressgateway、ingressgateway、pilot、policy、sidecarInjector、telemetry 等。如下截图所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584368188341223.png" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 service mesh - istio profile 详述_istio profile_05"><img src="https://blog.51cto.com/static/js/ueditor1.4.3/themes/default/images/spacer.gif" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 service mesh - istio profile 详述_istio profile_06"></p><p>​    部分组件信息如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584368199256308.png" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 service mesh - istio profile 详述_istio 安装_07"></p><p>​    总结 demo profile 的组件、插件的开关情况信息如下截图所示，其中 X 代表开启组件或插件：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584368214844438.png" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 service mesh - istio profile 详述_istio profile_08"></p><h3 id="3-2-minimal"><a href="#3-2-minimal" class="headerlink" title="3.2 minimal"></a>3.2 minimal</h3><p>​    minimal profile 仅仅开启了 pilot 组件，其他的组件或者插件都是关闭的状态，可以通过如下命令查看明细：</p><blockquote><p>istioctl profile dump minimal &gt; minimal.yaml</p></blockquote><p>​    如下图所示，minimal 插件都是关闭的：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584368226455115.png" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 service mesh - istio profile 详述_istio 视频_09"></p><p>​    仅有 pilot 组件是开启状态：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584368242534892.png" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 service mesh - istio profile 详述_istio 安装_10"></p><p>​    符合官方描述，如下图所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584368252181812.png" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 service mesh - istio profile 详述_istio profile_11"></p><h3 id="3-3-default"><a href="#3-3-default" class="headerlink" title="3.3 default"></a>3.3 default</h3><p>​    default 是官方推荐的 istio 安装 profile。它在组件和插件的选择上做到了最合适，比如组件中它只开启了 ingressgateway、pilot，插件中只开启了 prometheus。如下图所示：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584368262600119.png" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 service mesh - istio profile 详述_istio profile_12"></p><h3 id="3-4-empty"><a href="#3-4-empty" class="headerlink" title="3.4 empty"></a>3.4 empty</h3><p>​    empty profile 不会开启任何组件或者插件。该 profile 的作用是提供一个干净的模板供有经验的 istio 使用者自定义配置。</p><h3 id="3-5-remote"><a href="#3-5-remote" class="headerlink" title="3.5 remote"></a>3.5 remote</h3><p>​    remote profile 在实际使用中情况并不多见。该 profile 提供共享控制面去操作多集群服务网格。remote profile 官方提供的组件、插件描述如下图所示，但是根据本人实际观察，发现并不准确，特别标注在下图中：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584368292162685.png" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 service mesh - istio profile 详述_istio 服务网格_13"></p><p>​    dump 出的 ingress-gateway 组件应该处于开启状态：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584368303338153.png" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 service mesh - istio profile 详述_istio profile_14"></p><p>​    dump 出来的 pilot 组件应该处于开启状态：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584368314215522.png" srcset="/img/loading.gif" lazyload alt="第十章 九析带你轻松完爆 service mesh - istio profile 详述_istio 教程_15"></p><h3 id="3-6-separate"><a href="#3-6-separate" class="headerlink" title="3.6 separate"></a>3.6 separate</h3><p>​    官方宣称 separate profile 在未来的版本中将要被废弃掉了，所以就直接略过不提了吧。大家都生活得够艰难了，就不要给自己找麻烦了。</p><hr><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>​    本小节介绍了 istioctl 安装 istio 时提供的各个 profile，已经可以覆盖 90%  上的工作场景了。但是有些技术小骚仍然不会满足，那么后续哥将会继续提供自定义配置安装的方法，请继续跟随九析的脚步，我们一同轻松完爆 istio。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - istio upgrade 升级</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-upgrade-%E5%8D%87%E7%BA%A7/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-upgrade-%E5%8D%87%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 升级前的准备</p><p>3 升级步骤</p><p>  3.1 下载新版本的 istio</p><p>  3.2 解压缩 istio</p><p>  3.3 设置 istioctl 环境变量</p><p>  3.4 设置 istio 自动补全功能</p><p>  3.5 验证新版本 istio 是否兼容老版本</p><p>  3.6 创建升级配置文件</p><p>  3.7 升级 istio</p><p>​    3.7.1 资源等待错误</p><p>​    3.7.2 资源冲突错误</p><p>​    3.8 重设数据平面</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173739515.png" srcset="/img/loading.gif" lazyload alt="image-20210911173739515"></p><p>​    今天杭州阴天，哥的心情不怎么嗨！因为哥前期都在使用 1.4.5 版本，但是这周 istio 官方没经我允许就擅自升级到了 1.5 版本，打了我一个措手不及。但是互联网这十几年没少教育我，于是痛定思痛决定拥抱变化。</p><hr><h2 id="2-升级前的准备"><a href="#2-升级前的准备" class="headerlink" title="2 升级前的准备"></a>2 升级前的准备</h2><p>​    就像你撸管前要先把纸准备好一样，在升级 istio 前，要先做一些前期准备工作。</p><blockquote><p>1 检查 istio 版本是不是 1.4.4 或更高版本</p><p>2 确定 istio 安装采用的是 istioctl 安装</p></blockquote><p>​    使用如下命令查看当前 istio 安装版本：</p><blockquote><p>istioctl version</p></blockquote><p>​    命令截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173755955.png" srcset="/img/loading.gif" lazyload alt="image-20210911173755955"></p><p>​    由此可知，istio 当前的客户端、控制平面、数据平面的版本都是 1.4.5 版本。</p><p>​    通过查看 istio pod 的镜像也可以确认当前 istio 各组件的相关版本，如下图：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173809501.png" srcset="/img/loading.gif" lazyload alt="image-20210911173809501"></p><hr><h2 id="3-升级步骤"><a href="#3-升级步骤" class="headerlink" title="3 升级步骤"></a>3 升级步骤</h2><h3 id="3-1-下载新版本的-istio"><a href="#3-1-下载新版本的-istio" class="headerlink" title="3.1 下载新版本的 istio"></a>3.1 下载新版本的 istio</h3><p>​    执行如下命令下载最新版的 istio：</p><blockquote><p>curl -L <a href="https://istio.io/downloadIstio">https://istio.io/downloadIstio</a> | sh -</p></blockquote><p>​    也可以直接下载指定版本的 istio：</p><blockquote><p>curl -L <a href="https://istio.io/downloadIstio">https://istio.io/downloadIstio</a> | ISTIO_VERSION=1.5.0 sh -</p></blockquote><p>​    当然很多情况下，你都会遭遇网络情况，如下所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173821564.png" srcset="/img/loading.gif" lazyload alt="image-20210911173821564"></p><p>​    你能怎么办？你什么感觉？是不是就像大便找不到厕所？或者找到厕所却发现没坑？</p><p>​    实在下不到，你也不要悲愤，可以告诉哥，哥直接发给你，不用谢！</p><p>​    如下截图有没有看到，哥可以下，但是你们却下不到，你说气人不？</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173831924.png" srcset="/img/loading.gif" lazyload alt="image-20210911173831924"></p><h3 id="3-2-解压缩-istio"><a href="#3-2-解压缩-istio" class="headerlink" title="3.2 解压缩 istio"></a>3.2 解压缩 istio</h3><p>​    安装 istio 前，首先解压缩：</p><blockquote><p>tar -zxvf istio-1.5.0-linux.tar.gz</p></blockquote><p>​    解压缩后的目录结构截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173847127.png" srcset="/img/loading.gif" lazyload alt="image-20210911173847127"></p><p>​    关键目录、文件说明如下：</p><blockquote><p>1 bin/istioctl    # 客户端工具</p><p>2 install    # 底层支持平台的资源文件，istio 可支持 consul、gcp、k8s 平台</p><p>3 samples    # 学习样例</p></blockquote><h3 id="3-3-设置-istioctl-环境变量"><a href="#3-3-设置-istioctl-环境变量" class="headerlink" title="3.3 设置 istioctl 环境变量"></a>3.3 设置 istioctl 环境变量</h3><p>​    因为我曾经设置过老版本 istioctl 环境变量，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173859461.png" srcset="/img/loading.gif" lazyload alt="image-20210911173859461"></p><p>​    所以首先需要通过如下命令进行删除：</p><blockquote><p>export PATH=<code>echo $PATH | sed -e &#39;s/:\/root\/istio\/istio-1.4.5\/bin//g&#39;</code></p></blockquote><p>​    删除后截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173926207.png" srcset="/img/loading.gif" lazyload alt="image-20210911173926207"></p><p>​    将新版本 istioctl 路径添加到系统环境路径中：</p><blockquote><p>cd istio-1.5.0</p><p>export PATH=$PATH:$PWD/bin</p><p>istioctl version</p></blockquote><p>​    执行成功后，验证版本如下图所示，发现当前 istioctl 客户端版本已经更新为 1.5.0，但是控制面和数据面仍然是 1.4.5，这说明当前我们只是完成了 istio 客户端的改造，而控制面和数据面版本要升级完才会更改：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173939403.png" srcset="/img/loading.gif" lazyload alt="image-20210911173939403"></p><h3 id="3-4-设置-istio-自动补全功能"><a href="#3-4-设置-istio-自动补全功能" class="headerlink" title="3.4 设置 istio 自动补全功能"></a>3.4 设置 istio 自动补全功能</h3><p>​    将 istio 安装包 tools 目录下的 istioctl.bash 拷贝到用户根目录下：</p><blockquote><p>cp istio-1.5.0/tools/istioctl.bash ~</p></blockquote><p>​    编辑 ~/.bash_profile 文件，在文件末尾添加如下内容：</p><blockquote><p>PATH=$PATH:$HOME/bin</p><p>PATH=$PATH:/root/istio/istio-1.5.0/bin</p><p>export PATH</p><p>source /root/.istioctl.bash</p></blockquote><p>​    添加完毕后，加载配置使之生效：</p><blockquote><p>source ~/.bash_profile</p></blockquote><p>​    然后输入 istioctl 然后按两次 tab 键，发现自动补全功能已经生效：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173949422.png" srcset="/img/loading.gif" lazyload alt="image-20210911173949422"></p><h3 id="3-5-验证新版本-istio-是否兼容老版本"><a href="#3-5-验证新版本-istio-是否兼容老版本" class="headerlink" title="3.5 验证新版本 istio 是否兼容老版本"></a>3.5 验证新版本 istio 是否兼容老版本</h3><p>​    执行如下命令查看新版本 istio 可兼容的版本范围：</p><blockquote><p>istioctl manifest versions</p></blockquote><p>​    如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173959253.png" srcset="/img/loading.gif" lazyload alt="image-20210911173959253"></p><p>​    明确新版本 istio 可升级，则继续往下操作。</p><h3 id="3-6-创建升级配置文件"><a href="#3-6-创建升级配置文件" class="headerlink" title="3.6 创建升级配置文件"></a>3.6 创建升级配置文件</h3><p>​    我以前安装 istio 采用的 profile 是 demo：</p><blockquote><p>istioctl manifest apply –set profile=demo</p></blockquote><p>​    怎么理解 profile，你可以跟下图做类比：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911174010406.png" srcset="/img/loading.gif" lazyload alt="image-20210911174010406"></p><p>​    也就是同样型号比如 G 级别车，一共有三个版本，每个版本就是一个 profile，每个 profile 的参数或者配置都有区别。</p><p>​    你也可以通过如下命令查看你的 istio 1.5.0 版本共有几个 profile：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911174020192.png" srcset="/img/loading.gif" lazyload alt="image-20210911174020192"></p><p>​    但是可惜地是，istio 安装时支持 set 参数，比如你可以使用如下命令安装：</p><blockquote><p>istioctl manifest apply –set profile=demo</p></blockquote><p>​    但是 istioctl upgrade 命令不支持 –set 选项，因此，如果前期在安装的时候使用了 –set 选项，那么在升级时需要创建一个等效的配置选项文件。</p><p>​    使用如下命令创建 profile 为 demo 的等效配置文件：</p><blockquote><p>istioctl profile dump demo &gt; demo.yaml</p></blockquote><h3 id="3-7-升级-istio"><a href="#3-7-升级-istio" class="headerlink" title="3.7 升级 istio"></a>3.7 升级 istio</h3><p>​    执行如下命令来升级 istio：</p><blockquote><p>istioctl upgrade -f demo.yaml</p></blockquote><p>​    升级过程截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911174030581.png" srcset="/img/loading.gif" lazyload alt="image-20210911174030581"></p><p>​    如果升级过程很顺畅，就可以跳过此小节继续下面的内容；如果升级过程并不顺利，可以根据下面的介绍进行修改。</p><h4 id="3-7-1-资源等待错误"><a href="#3-7-1-资源等待错误" class="headerlink" title="3.7.1 资源等待错误"></a>3.7.1 资源等待错误</h4><p>​    如果在升级过程中遭遇如下日志信息：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911174040082.png" srcset="/img/loading.gif" lazyload alt="image-20210911174040082"></p><blockquote><p>error    installer    Failed to wait for resource: resources not ready after 10m0s: timed out waiting for the condition</p><p>Deployment/istio-system/istiod</p></blockquote><p>​    多半是因为镜像下载问题，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911174050011.png" srcset="/img/loading.gif" lazyload alt="image-20210911174050011"></p><p>​    可以指定 aliyun 作为镜像源：</p><blockquote><p>touch /etc/docker/daemon.json</p><p>vim /etc/docker/daemon.json</p></blockquote><p>​    添加如下内容：</p><blockquote><p>{</p><p>“registry-mirrors”: [“<a href="https://9cpn8tt6.mirror.aliyuncs.com&quot;]">https://9cpn8tt6.mirror.aliyuncs.com&quot;]</a></p><p>}</p></blockquote><p>​    添加完成后执行如下操作：</p><blockquote><p>systemctl daemon-reload</p><p>systemctl restart docker</p></blockquote><h4 id="3-7-2-资源冲突错误"><a href="#3-7-2-资源冲突错误" class="headerlink" title="3.7.2 资源冲突错误"></a>3.7.2 资源冲突错误</h4><p>​    如果在安装过程中出现如下错误：</p><blockquote><p>Error: failed to read the current Istio version, error: different versions of Istio components found</p></blockquote><p>​    错误截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911174102383.png" srcset="/img/loading.gif" lazyload alt="image-20210911174102383"></p><p>​    多半是因为镜像版本冲突，可以执行如下命令查看：</p><blockquote><p>istioctl version</p></blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911174112229.png" srcset="/img/loading.gif" lazyload alt="image-20210911174112229"></p><p>​    改正办法是删除错误版本的 deployment 后再升级（istioctl upgrade）：</p><blockquote><p>kubectl delete deployments.apps -n istio-system istio-egressgateway</p></blockquote><p>​    升级成功后的截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911174121033.png" srcset="/img/loading.gif" lazyload alt="image-20210911174121033"></p><p>​    再次执行 istioctl version，可以发现 istioctl 的客户端、数据面、控制面都从 1.4.5 变成了 1.5.0。如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911174133509.png" srcset="/img/loading.gif" lazyload alt="image-20210911174133509"></p><h3 id="3-8-重设数据平面"><a href="#3-8-重设数据平面" class="headerlink" title="3.8 重设数据平面"></a>3.8 重设数据平面</h3><p>​    从上面的截图中，其实可以发现一个端倪，就是 data plane version 有一个 proxy 仍是 1.4.5。产生这样的原因是我在升级 istio 版本前就已经手工注入了一个  deployment，现在需要重置原有数据平面。执行如下命令重置原有被注入的 nginx deployment：</p><blockquote><p>istioctl kube-inject -f nginx-deploy.yaml | kubectl apply -f -</p></blockquote><p>​    再次执行 istioctl version 命令发现客户端、数据面、控制面的版本都更新到了最新的状态，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911174144682.png" srcset="/img/loading.gif" lazyload alt="image-20210911174144682"></p><p>​    自此，九析带你轻松完爆 istio 的升级。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - istio 注入后网络流量流向</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-%E6%B3%A8%E5%85%A5%E5%90%8E%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%B5%81%E5%90%91/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-%E6%B3%A8%E5%85%A5%E5%90%8E%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E6%B5%81%E5%90%91/</url>
    
    <content type="html"><![CDATA[<p>目录</p><p>1 前言</p><p>2 查看 iptables 规则</p><p>  2.1 确定 pod 所在主机</p><p>  2.2 定位 istio-proxy 容器</p><p>  2.3 登录 istio-proxy 容器</p><p>  2.4 查看 iptables 规则</p><p>3 网络宏观流量流向介绍</p><p>4 网络微观流量流向介绍</p><p>5 istio 入口流量分析</p><p>6 istio 出口流量分析</p><p>7 小节</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911172944559.png" srcset="/img/loading.gif" lazyload alt="image-20210911172944559"></p><p>​    上节中我们举例介绍了执行 istio 注入操作后，对 nginx pod 所产生的影响，即在 pod 中会多创建两个容器：istio-init、istio-proxy，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911172956747.png" srcset="/img/loading.gif" lazyload alt="image-20210911172956747"></p><p>​    如果从进程角度来看 pod，则是下面这个样子：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173007202.png" srcset="/img/loading.gif" lazyload alt="image-20210911173007202"></p><p>​    从上图可知，nginx pod 内的三个容器共享同一个网络命名空间，该网络命名空间内的流量流向规则在初始化容器 istio-init 启动时完成的，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173017468.png" srcset="/img/loading.gif" lazyload alt="image-20210911173017468"></p><hr><h2 id="2-查看-iptables-规则"><a href="#2-查看-iptables-规则" class="headerlink" title="2 查看 iptables 规则"></a>2 查看 iptables 规则</h2><p>​    一般情况下，我们可以通过 kubectl exec 命令跟 pod 进行交互并获取到 pod 内信息，但这里我们不能此法获取到 pod 内的 iptables 信息。如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173028740.png" srcset="/img/loading.gif" lazyload alt="image-20210911173028740"></p><p>​    如果想获取到 iptables 信息，必须通过宿主机的 docker 才能获取到。</p><h3 id="2-1-确定-pod-所在主机"><a href="#2-1-确定-pod-所在主机" class="headerlink" title="2.1 确定 pod 所在主机"></a>2.1 确定 pod 所在主机</h3><p>​    使用如下命令获取运行 nginx pod 的宿主机地址：</p><blockquote><p>kubectl get pods -n jiuxi -o wide</p></blockquote><p>​    命令执行结果如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173039235.png" srcset="/img/loading.gif" lazyload alt="image-20210911173039235"></p><h3 id="2-2-定位-istio-proxy-容器"><a href="#2-2-定位-istio-proxy-容器" class="headerlink" title="2.2 定位 istio-proxy 容器"></a>2.2 定位 istio-proxy 容器</h3><p>​    ssh 命令登录到 10.244.10.80 宿主机，并执行如下命令定位 istio-proxy 容器：</p><blockquote><p>docker ps | grep -i istio-proxy</p></blockquote><p>​    执行结果如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173049597.png" srcset="/img/loading.gif" lazyload alt="image-20210911173049597"></p><h3 id="2-3-登录-istio-proxy-容器"><a href="#2-3-登录-istio-proxy-容器" class="headerlink" title="2.3 登录 istio-proxy 容器"></a>2.3 登录 istio-proxy 容器</h3><blockquote><p>docker exec -it –privileged $(docker ps | grep -i istio-proxy | awk ‘{print $(1)}’) bash</p></blockquote><h3 id="2-4-查看-iptables-规则"><a href="#2-4-查看-iptables-规则" class="headerlink" title="2.4 查看 iptables 规则"></a>2.4 查看 iptables 规则</h3><p>​    执行如下命令查看 iptables 规则：</p><blockquote><p>iptables -nvL -t nat</p></blockquote><p>​    执行结果会报如下错误：</p><blockquote><p>can’t initialize iptables table `nat’: Permission denied (you must be root)</p></blockquote><p>​    执行如下命令切换成 root 用户轻松完爆：</p><blockquote><p>sudo su root</p></blockquote><p>​    再次执行 iptables 即可，操作成功如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173100959.png" srcset="/img/loading.gif" lazyload alt="image-20210911173100959"></p><hr><h2 id="3-网络宏观流量流向介绍"><a href="#3-网络宏观流量流向介绍" class="headerlink" title="3 网络宏观流量流向介绍"></a>3 网络宏观流量流向介绍</h2><p>​    下面宏观介绍一下基本的网络流量流向知识，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173113518.png" srcset="/img/loading.gif" lazyload alt="image-20210911173113518"></p><p>​    用户从客户端发起一个 http  请求，该请求会通过互联网到达公司网络的外部边界（路由器），路由器会将网络流量送到交换机，因为反向代理服务器跟交换机联通，因此流量到达反向代理服务器（nginx），nginx 再将网络请求按照预先制定的分发策略转给后面真正处理请求的 web 服务器。</p><p>​    你可以通过 traceroute 命令定位一下外部网络流向。比如访问 <a href="http://www.baidu.com：">www.baidu.com：</a></p><blockquote><p>traceroute -I <a href="http://www.baidu.com/"> www.baidu.com</a></p></blockquote><p>​    访问截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173124326.png" srcset="/img/loading.gif" lazyload alt="image-20210911173124326"></p><p>​    通过上面的截图可知，本人访问 baidu.com 共经过了 13 个路由器。</p><p>​    当然也可以通过 traceroute 定位 k8s 中 pod 的网络流向，如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173134127.png" srcset="/img/loading.gif" lazyload alt="image-20210911173134127"></p><p>​    由上图可知：</p><blockquote><p>1 首先定位 nginx pod 的 ip 为 10.244.10.80</p><p>2 其次开始 traceroute 进行追踪，发现流量先经过 10.244.10.0，然后访问到 10.244.10.80</p><p>3 接着查看本地路由表得知访问 10.244.10.0 的流量是从网络设备 flannel.1 发出去的</p><p>4 最后查看了一下网络设备 flannel.1 的详细信息</p></blockquote><hr><h2 id="4-网络微观流量流向介绍"><a href="#4-网络微观流量流向介绍" class="headerlink" title="4 网络微观流量流向介绍"></a>4 网络微观流量流向介绍</h2><p>​    微观是指流量进入宿主机的情况分析，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173145054.png" srcset="/img/loading.gif" lazyload alt="image-20210911173145054"></p><p>​    由上图可知：</p><blockquote><p>1 入口流量经过服务器网卡进入服务器的网络协议栈</p><p>2 服务器网络协议栈会根据预先定制的网络规则(iptables/netfilter)对报文进行检查</p><p>3 协议栈规则检查后，符合要求的流量会从内核态进入到用户态，并进入指定监听端口的进程</p><p>4 处于用户态的用户进程接收到网络流量报文进行处理后，将处理后的结果再通过用户态返回给内核态的网络协议栈</p><p>5 网络协议栈检查报文，并将结果报文根据指定的网络策略通过网卡输送出去</p></blockquote><hr><h2 id="5-istio-入口流量分析"><a href="#5-istio-入口流量分析" class="headerlink" title="5 istio 入口流量分析"></a>5 istio 入口流量分析</h2><p>​    有了宏观和微观的网络流量流向分析之后，下一步就可以分析一下 istio 的入口流量了。因为涉及到 iptables 相关的知识，这里我仅仅把结论呈现给大家，具体 iptables 的使用如果大家有兴趣可以参考本人其他的博客轻松完爆。</p><p>​    在上面我们已经展示了 istio-init 容器在启动时就完成了网络空间协议栈规则的初始化，如下图：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173156740.png" srcset="/img/loading.gif" lazyload alt="image-20210911173156740"></p><p>​    现在可以通过 curl 访问 nginx pod。</p><blockquote><p>curl 10.244.10.80</p></blockquote><p>​    curl 后的入口流量进入 nginx pod 后的流转路径如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173207619.png" srcset="/img/loading.gif" lazyload alt="image-20210911173207619"></p><p>​    由上图可知，整个网络流向如下：</p><blockquote><p>1 因为匹配 iptables nat 表的 prerouting 链的第一条规则，因此网络流量被路由到 ISTIO_INBOUND 链</p><p>2 在 ISTIO_INBOUND 链一共有三条规则，因为访问的端口是 nginx 80，所以会匹配该链的第三条规则而将流量路由到 ISTIO_IN_REDIRECT 链</p><p>3 路由到 ISTIO_IN_REDIRECT 链的流量最终会从内核态打入到用户态监听端口为 15006 的进程</p></blockquote><p>​    端口 15006 的进程是什么呢？通过 netstat -ntlp 命令可知是 envoy 进程，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173220599.png" srcset="/img/loading.gif" lazyload alt="image-20210911173220599"></p><p>​    由此可知，当我们 curl nginx pod 时，虽然指定的目标访问端口为 80，但是网络协议栈规则仍然会将整个流量劫持送到 envoy 进程，由于  envoy 进程可以获取到入口流量，所以可以在此制定一系列的操作起到流控的目的。envoy 处理完后，流量会继续移动，流向路径如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173229115.png" srcset="/img/loading.gif" lazyload alt="image-20210911173229115"></p><p>​    由上图可知，整个网络流向如下：</p><blockquote><p>1 端口 15006 的进程处理完流量后，会将流量从用户态的进程传回内核态的网络协议栈，根据预先定义好的协议栈规则，流量会流经 output 链，output 链又会根据规则再把流量路由给 ISTIO_OUTPUT 链</p><p>2 因为 envoy 处理完流量最终要重新路由给 80 端口的 nginx 进程，因此处于 ISTIO_OUTPUT 链的第一条规则被匹配（因为  envoy 跟 nginx 在同一个网络命名空间，因此环回地址 lo 被匹配），此时流量会重新从内核态返回到用户态，并进入监听端口为 80 的  nginx 进程</p><p>3 nginx 处理完后，将结果通过 socket 连接返回给 envoy 进程（用户态）</p><p>4 envoy 再将流量通过 postrouting 链、网卡再将响应流量返回给用户</p></blockquote><hr><h2 id="6-istio-出口流量分析"><a href="#6-istio-出口流量分析" class="headerlink" title="6 istio 出口流量分析"></a>6 istio 出口流量分析</h2><p>​    上面介绍了 istio 入口请求流量流向分析，下面介绍一下 istio 出口流量流向分析，首先在 docker 容器内执行 curl 命令：</p><blockquote><p>curl <a href="http://www.baidu.com/">www.baidu.com</a></p></blockquote><p>​    下面截图展示出口流量的流向：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173241410.png" srcset="/img/loading.gif" lazyload alt="image-20210911173241410"></p><p>​    从图可知：</p><blockquote><p>1 出口流量首先会通过 iptables nat 表的 output 链进入到 istio_output 链</p><p>2 因为目的是 baidu，因此最终会匹配到 istio_redirect 链</p><p>3 istio_redirect 会将流量路由给端口 15001 的进程</p></blockquote><p>​    端口 15001 进程依旧是 envoy 进程，该端口处理的是 outbound 流量。如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173252400.png" srcset="/img/loading.gif" lazyload alt="image-20210911173252400"></p><p>​    由此可知，访问 baidu 前，流量依旧会被 envoy 劫持。处理完毕后，envoy 流量处理结果如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911173302757.png" srcset="/img/loading.gif" lazyload alt="image-20210911173302757"></p><blockquote><p>1 envoy 将处理后的网络流量重新通过用户态进入到内核态的网络协议栈，流量会首先经过 OUTPUT 链</p><p>2 流经 OUTPUT 链的流量会进入 ISTIO_OUTPUT 链</p><p>3 流入到 ISTIO_OUTPUT 链的流量会匹配 owner UID match 1337 规则</p><p>4 流量最终会通过 POSTROUTING 链进入到网卡</p><p>5 从网卡随风而出</p></blockquote><hr><h2 id="7-小节"><a href="#7-小节" class="headerlink" title="7 小节"></a>7 小节</h2><p>​    本小节九析带你轻松完爆了 istio 注入 pod 后所导致的网络流量流向的改变。大家可以自己操作进行验证。这里告诉大家一个小窍门，如果想定位网络流量流向匹配  iptables 的哪条规则，可以通过观察 iptables 规则的 pkts、bytes 变化来确定。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - istio 注入</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-%E6%B3%A8%E5%85%A5/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 istio 注入与平台生态影响</p><p>  2.1 环境准备</p><p>  2.2 istio 注入操作</p><p>  2.3 istio 注入本质</p><p>  2.4 istio 注入 pod 后各容器作用以及关系</p><p>  2.5 istio-proxy 和 envoy 关系</p><p>  2.6 istio-proxy 和 kube-proxy 关系</p><p>  2.7 envoy 进程服务端口</p><p>3 小节</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911171710644.png" srcset="/img/loading.gif" lazyload alt="image-20210911171710644"></p><hr><h2 id="2-istio-注入与平台生态影响"><a href="#2-istio-注入与平台生态影响" class="headerlink" title="2 istio 注入与平台生态影响"></a>2 istio 注入与平台生态影响</h2><p>​    虽然 istio 是平台间独立的，不仅支持 K8s、Consul，也同样支持虚拟机，但是本文部署平台环境还是聚焦在 k8s。</p><h3 id="2-1-环境准备"><a href="#2-1-环境准备" class="headerlink" title="2.1 环境准备"></a>2.1 环境准备</h3><p>​    在本系列文章的第二篇中提到过资源的 istio 注入，这里再做一个回顾。</p><p>​    新建 jiuxi 命名空间：</p><blockquote><p>kubectl create ns jiuxi</p></blockquote><p>​    编写 nginx deployment 资源文件 nginx-deploy.yaml：</p><blockquote><p>apiVersion: apps/v1</p><p>kind: Deployment</p><p>metadata:</p><p>  name: nginx</p><p>  namespace: jiuxi</p><p>  labels:</p><p>  app: nginx</p><p>spec:</p><p>  replicas: 1</p><p>  selector:</p><p>​    matchLabels:</p><p>​      app: nginx</p><p>  template:</p><p>​    metadata:</p><p>​      labels:</p><p>​        app: nginx</p><p>​    spec:</p><p>​      containers:</p><p>​      -  name: nginx</p><p>​        image: nginx:1.14-alpine</p><p>​        ports:</p><p>​        - containerPort: 80</p></blockquote><p>​    新建 nginx deployment 资源：</p><blockquote><p>kubectl apply -f nginx-deploy.yaml</p></blockquote><p>​    创建成功后的截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911171726710.png" srcset="/img/loading.gif" lazyload alt="image-20210911171726710"></p><h3 id="2-2-istio-注入操作"><a href="#2-2-istio-注入操作" class="headerlink" title="2.2 istio 注入操作"></a>2.2 istio 注入操作</h3><p>​    执行 istio 注入操作之前，须确保 istio 和 istioctl 都正确安装，安装操作请参阅《<a href="https://blog.51cto.com/14625168/2474224"> 第一章</a>》。</p><p>​    手动执行 istio 注入操作：</p><blockquote><p>istioctl kube-inject -f nginx-deploy.yaml | kubectl apply -f -</p></blockquote><p>​    执行成功之后截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911171737004.png" srcset="/img/loading.gif" lazyload alt="image-20210911171737004"></p><p>​    此时 nginx pod 内部容器从原来的 1 个变成了 2 个（严格意义上应该是 3 个，因为有个启动容器执行完就结束了，因此这里看不到，后面会细说）。</p><h3 id="2-3-istio-注入本质"><a href="#2-3-istio-注入本质" class="headerlink" title="2.3 istio 注入本质"></a>2.3 istio 注入本质</h3><p>​    我们再审视一下 istio 注入过程：</p><blockquote><p>istioctl kube-inject -f nginx-deploy.yaml | kubectl apply -f -</p></blockquote><p>​    该命令通过管道符 “|” 将两步操作合为一步，”|” 前在 nginx-deploy.yaml 资源文件注入 istio 内容，”|” 后部署经过 istio 注入的新的 nginx-deploy.yaml 文件。</p><p>​    那么 istio 到底注入了哪些内容呢？执行如下命令查看：</p><blockquote><p>kubectl edit deployment -n jiuxi nginx</p></blockquote><p>​    发现在原来基础上增加了一个初始化容器（initContainers）：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911171748249.png" srcset="/img/loading.gif" lazyload alt="image-20210911171748249"></p><p>​    <img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911171800364.png" srcset="/img/loading.gif" lazyload></p><p>又增加了一个 istio-proxy 容器：</p><p>还有一些环境变量信息，如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911171857892.png" srcset="/img/loading.gif" lazyload alt="image-20210911171857892"></p><p>​    由此可知，istio 注入本质就是在宿主资源中添加 istio 特性，从而起到提高整个平台的能力。类似克拉克加了披风变成超人，布洛克吸附外星物质变成毒液一样的道理。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911171911243.png" srcset="/img/loading.gif" lazyload alt="image-20210911171911243"></p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911171923945.png" srcset="/img/loading.gif" lazyload alt="image-20210911171923945"></p><p>​    下图展示了 istio 在 nginx pod 中注入新容器 istio-init、istio-proxy：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911171936581.png" srcset="/img/loading.gif" lazyload alt="image-20210911171936581"></p><h3 id="2-4-istio-注入-pod-后各容器作用以及关系"><a href="#2-4-istio-注入-pod-后各容器作用以及关系" class="headerlink" title="2.4 istio 注入 pod 后各容器作用以及关系"></a>2.4 istio 注入 pod 后各容器作用以及关系</h3><p>​    上图演示了 pod 在 istio 注入后产生了 2 个新的容器，这样原来单容器的 pod 现在变成了 3 个容器共存同一个 pod 中，而且宿主容器（nginx）跟 istio-proxy 容器还处于同一网络空间。</p><blockquote><p>istio-init: 初始化容器。作用是初始化 pod 网络空间，创建 iptables 规则。</p><p>istio-proxy: sidecar 容器。作用是启动 pilot-agent 和 envoy 进程。</p></blockquote><p>​    可以通过 kubectl exec -it 命令进入 nginx pod 的 nginx 和 istio-proxy 容器，发现两个容器共享同一网络空间。如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911171953779.png" srcset="/img/loading.gif" lazyload alt="image-20210911171953779"></p><h3 id="2-5-istio-proxy-和-envoy-关系"><a href="#2-5-istio-proxy-和-envoy-关系" class="headerlink" title="2.5 istio-proxy 和 envoy 关系"></a>2.5 istio-proxy 和 envoy 关系</h3><p>​    envoy 其实本质与 nginx 和 haproxy 一样，都属于网络代理服务器，运行时则是一个进程。envoy 在架构设计上也采用了类似 nginx 的设计模式（多线程、非阻塞、异步IO），后面的课程我会详细讲解。</p><p>​    istio-proxy 是运行在 pod 中的一个容器。该容器运行时会启动两个关键的进程 pilot-agent 和 envoy。pilot-agent 进程会定时跟 istio 的 pilot 组件进行通信，envoy 进程会接收入口和出口网络流量。istio-proxy 容器内的进程如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911172004111.png" srcset="/img/loading.gif" lazyload alt="image-20210911172004111"></p><h3 id="2-6-istio-proxy-和-kube-proxy-关系"><a href="#2-6-istio-proxy-和-kube-proxy-关系" class="headerlink" title="2.6 istio-proxy 和 kube-proxy 关系"></a>2.6 istio-proxy 和 kube-proxy 关系</h3><p>​    从表现形式上说，istio-proxy 是容器(运行在 pod 内)，kube-proxy 是 pod (资源类型是 daemonset)。</p><p>​    从处理网络流量角度来说，istio-proxy 和 kube-proxy 本质上都是通过 iptables/netfilter 来处理网络流量。只不过 istio-proxy 和  kube-proxy 活动在不同的网络空间。istio-proxy 位于 pod 网络空间，处理的是 pod 内的网络流量，而  kube-proxy 位于宿主机网络空间，处理的是宿主机内网络流量（因为 kube-proxy 是 daemonset，因此它位于 k8s  集群的每个 node 节点上）。</p><h3 id="2-7-envoy-进程服务端口"><a href="#2-7-envoy-进程服务端口" class="headerlink" title="2.7 envoy 进程服务端口"></a>2.7 envoy 进程服务端口</h3><p>​    上面我们介绍了 envoy 是运行在 istio-proxy 容器内的一个进程，改进程的作用是管理网络流量（类比 nginx），下图展示 envoy  进程开启的网络端口，网络流量可以通过端口进入到 envoy 进程内部。网络流量、网络端口和 envoy  进程的关系就像风、窗户和房屋的关系一样，风（网络流量）通过窗口（网络端口）进入到房屋（envoy），一个房屋（envoy）可以不止一个窗户（网络端口）。</p><p>​    下图展示 envoy 进程监听的端口号：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911172014710.png" srcset="/img/loading.gif" lazyload alt="image-20210911172014710"></p><p>​    服务端口作用截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911172033996.png" srcset="/img/loading.gif" lazyload alt="image-20210911172033996"></p><hr><h2 id="3-小节"><a href="#3-小节" class="headerlink" title="3 小节"></a>3 小节</h2><p>​    自此，九析带你轻松完爆了 istio 的注入以及对平台生态的影响。下章节将继续介绍 istio 注入后对网络流量的流向的改变。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - istio 今生篇</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-%E4%BB%8A%E7%94%9F%E7%AF%87/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-%E4%BB%8A%E7%94%9F%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 何为服务网格（service mesh）</p><p>3 何为 istio</p><p>4 为什么使用 istio</p><p>5 istio 核心特征</p><p>  5.1 traffic management</p><p>  5.2 secure</p><p>  5.3 policies</p><p>  5.4 observability</p><p>6 多平台支持</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911171103398.png" srcset="/img/loading.gif" lazyload alt="image-20210911171103398"></p><p>​    上章介绍了 istio 前世，讲述了微服务架构模型的演变史，也讲了微服务今天所遭遇的问题和面临的尴尬窘境，这里我们再复习一下。</p><p>   目前微服务治理遭遇的问题：</p><blockquote><p><strong>服务治理方式不统一</strong>：不同服务治理的方式会引入不同的中间件，而这些中间件的技术标准和维护标准都不同。因此运维人员或者架构人员必须掌握每种中间件的使用方法，很多时候这对一个人力资源有限的科技公司并不现实。</p><p><strong>重复造轮子</strong>：微服务架构是允许多语言栈、多技术栈的，但不同的技术栈针对通信、支撑服务、服务安全、服务监控、熔断/降级/限流等通用技术问题却需要各自的解决方案，实在是成本的浪费。</p><p><strong>服务治理缺乏标准化</strong>：由于服务治理缺乏标准化，因此微服务治理的好坏全依靠技术人员个人的能力、经验和水平，这就有点像手工作坊时代，器物优质全靠工匠。但是无标准化显然不符合科技发展的轨迹。</p></blockquote><p>​    为了解决上面微服务治理中的痛点，大家普遍的诉求在于能不能有这么一个平台，既可以无侵入、透明、用户无感知的插入到现有的分布式微服务架构中，同时又可以解决一些通信所必须考虑的普遍问题（服务发现、负载均衡、超时重试、熔断/限流、监控、访问控制、认证授权等），将这些问题的解决方案统一下沉到平台层，而不再依靠引入第三方中间件（zookeeper、nginx、sentinal、hystrix、pinpoint/zipkin、spring security），并且所有的维护方式统一且标准化。</p><p>​    于是服务网格出现了，istio 也出现了，而且一切出现得都是这么自然。</p><blockquote><p>《圣经》旧约-创世纪篇：</p><p>原始太初，上帝创造了天地。地面一片空虚混沌，渊面黑暗，只有上帝的灵运行在水面上。上帝说：“要有光！”于是，就有了光。上帝把光和暗分开，把光称为白昼，把暗称为黑夜。夜晚过去后,清晨接着来临，这是第一天。</p><p>上帝说：“诸水之间要有穹苍，将水分为上下。”于是创造了穹苍，把水上下分开。他称穹苍为“天空”。夜晚过去，清晨接着来临，这是第二天。</p><p>……</p></blockquote><p>​    那么服务网格是什么？istio 又是什么呢？</p><hr><h2 id="2-何为服务网格（service-mesh）"><a href="#2-何为服务网格（service-mesh）" class="headerlink" title="2 何为服务网格（service mesh）"></a>2 何为服务网格（service mesh）</h2><p>​    下面看看 istio 是怎么描述服务网格的：</p><blockquote><p>The term service mesh is used to describe the network of microservices that make up such applications and the interactions between them. As a  service mesh grows in size and complexity, it can become harder to  understand and manage. Its requirements can include discovery, load  balancing, failure recovery, metrics, and monitoring. A service mesh  also often has more complex operational requirements, like A/B testing,  canary rollouts, rate limiting, access control, and end-to-end  authentication.</p></blockquote><p>​    个人翻译如下：</p><blockquote><p>服务网格是对微服务组成的一个可以互相通信的网络进行治理的规范。随着微服务的增长，服务网格也会变得越来越复杂和难以理解。服务网格治理的内容除了服务发现、负载均衡、失败恢复、指标收集、监控之外，还应该具有更复杂的运维要求，比如 A/B 测试、金丝雀发布、流量限制、访问控制和端到端认证。</p></blockquote><h2 id="3-何为-istio"><a href="#3-何为-istio" class="headerlink" title="3 何为 istio"></a>3 何为 istio</h2><p>​    上面介绍了服务网格，下面再来介绍一下 istio，仍然引用 istio 官网的定义：</p><blockquote><p>Cloud platforms provide a wealth of benefits for the organizations that use  them. However, there’s no denying that adopting the cloud can put  strains on DevOps teams. Developers must use microservices to architect  for portability, meanwhile operators are managing extremely large hybrid and multi-cloud deployments. Istio lets you connect, secure, control,  and observe services.</p><p>At a high level, Istio helps  reduce the complexity of these deployments, and eases the strain on your development teams. It is a completely open source service mesh that  layers transparently onto existing distributed applications. It is also a platform, including APIs that let it integrate into any logging  platform, or telemetry or policy system. Istio’s diverse feature set  lets you successfully, and efficiently, run a distributed microservice  architecture, and provides a uniform way to secure, connect, and monitor microservices.</p></blockquote><p>​    个人感觉介绍很啰嗦，建议你也别看了，我给你简单列举一下重点即可：</p><blockquote><p>istio 是 service mesh 的具体解决方案。她就像一个尤物，不仅能满足服务网格规定的一切苛刻要求之外，还贴心地为你准备了一整套标准化、规格化的豪华级国际服务，等待着你的抽插。更难能可贵地是，拥有这么多优秀品质的她，竟然还是免费的！爽不爽！</p></blockquote><h2 id="4-为什么使用-istio"><a href="#4-为什么使用-istio" class="headerlink" title="4 为什么使用 istio"></a>4 为什么使用 istio</h2><p>​    下面是你选择 istio 的一些理由：</p><blockquote><p>1 对 HTTP、gRPC、WebSocket 和 TCP 网络流量的自动负载均衡</p><p>2 通过丰富多样的路由规则、重试、故障转移和故障注入机制实现对流量行为进行细粒度控制</p><p>3 通过可插拔的策略层（联想成过滤器）和 API 实现对访问的控制、流量以及资源配额的限制</p><p>4 集群入口、集群内部、集群出口所有网络流量的全方位跟踪、记录和度量</p><p>5 保证服务之间通信的安全性</p></blockquote><h2 id="5-istio-核心特征"><a href="#5-istio-核心特征" class="headerlink" title="5 istio 核心特征"></a>5 istio 核心特征</h2><p>​    istio 官方宣扬的特性是 traffic management（流控）、secure（安全）、polices（策略）、observability（可观察）。个人感觉这样的叙述太佶屈聱牙，一点都不口语化。</p><h3 id="5-1-traffic-management"><a href="#5-1-traffic-management" class="headerlink" title="5.1 traffic management"></a>5.1 traffic management</h3><p>​    这个好理解，本质就是网络流量的管理。就像早晚高峰车辆限行，以及交警在发生交通事故疏导新路，这些都是在做流量的控制和路由。</p><p>​    其实流量管理并不是服务网格化才出现的，早期的微服务时代就已经有流量控制了，比如负载均衡、熔断、限流、降级等，只不过早期这些功能的实现依赖中间件（比如 nginx、hystrix），如今服务网格时代，这些功能统一下沉到基础平台 istio 去实现了。</p><p>​    istio 的流控主要是通过 Envoy 组件实现。有关技术细节，哥以后会专门告诉你。</p><h3 id="5-2-secure"><a href="#5-2-secure" class="headerlink" title="5.2 secure"></a>5.2 secure</h3><p>​    说到 istio 的 secure 其实是有个范围的。这里的 secure 并不是没有边界，它主要是指微服务之间通信的 secure，即 pod 对 pod、service 对 service 层面通信的 secure。众所周知，istio 是 google、ibm 以及 lyft 公司  3p 后的产物。而 istio 的 secure 正是脱胎于 google 的 ALTS（应用层传输安全）这项技术，该项技术用于验证  google 服务之间的通信，保证传输中数据的安全，即应用层服务到服务通信的防护方式。这些功能早先在微服务时代对标就是 jwt、oauth2  等技术规范。</p><p>​    istio secure 主要的功能有 ACLS（访问控制）、authentication（认证，即证明你是谁）、authorization（授权，即允许你干啥）。</p><p>​    istio secure 功能通过 Citadel 这个组件实现。有关技术细节，哥以后会专门告诉你。</p><h3 id="5-3-policies"><a href="#5-3-policies" class="headerlink" title="5.3 policies"></a>5.3 policies</h3><p>​    istio policies 职责如下：</p><blockquote><p>1 动态限制服务通信的网络速率</p><p>2 限制访问服务、设置黑、白名单</p><p>3 网络包头信息的重写或者重定向</p></blockquote><p>​    不仅如此，istio 也允许添加自定义策略，通过 istio 提供的 policy adapter 跟 istio 集成在一起。</p><p>​    注意不要将 policies 跟 secure 进行混淆，policies 更多是人为进行干预控制，而 secure 重点在于安全。</p><p>​    istio policies 功能实现是通过 mixer 组件实现的。有关技术细节，哥以后会专门告诉你。</p><h3 id="5-4-observability"><a href="#5-4-observability" class="headerlink" title="5.4 observability"></a>5.4 observability</h3><p>​    observability 特性是指提供给你多种工具实现全方位、立体式对集群入口、集群内部、集群出口的流量进行监控、跟踪和度量。微服务早期时代监控方式是 agent 或者中间件，比如：zabbix、pinpoint、zipkin 等。</p><p>​    istio observability 功能实现是通过 mixer 组件实现的。还是老样子，有关技术细节，哥以后会专门告诉你。</p><h2 id="6-多平台支持"><a href="#6-多平台支持" class="headerlink" title="6 多平台支持"></a>6 多平台支持</h2><p>​    istio 可以支持多平台，比如 k8s、Consul、Mesos 以及独立虚拟机。</p><p>​    以后哥都会实际为你展示，你唯一做的就是耐心等待和持续尖叫。</p><p>​    自此，九析带你轻松完爆 istio 的介绍。更多精彩，敬请期待。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - istio 前世</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-%E5%89%8D%E4%B8%96/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-%E5%89%8D%E4%B8%96/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 架构演变史</p><p>  2.1 单体架构</p><p>  2.2 垂直架构</p><p>  2.3 微服务架构</p><p>3 微服务架构模型演进史</p><p>  3.1 框架与通信</p><p>  3.2 运行时的支撑服务</p><p>  3.3 服务安全</p><p>  3.4 服务监控和告警</p><p>  3.5 服务部署</p><p>  3.6 底层服务</p><p>  3.7 服务防护</p><p>  3.8 全链路压测</p><p>4 微服务架构模型全景图</p><p>5 带来的问题</p><p>  5.1 服务治理方式不统一</p><p>  5.2 重复造轮子</p><p>  5.3 服务治理缺乏标准化</p><p>6 总结</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    介绍 istio 之前，要先讲微服务，因为 istio 是在微服务技术体系上发展起来的。当你对微服务的技术体系有了一定把握之后，回过头再来理解 istio，你就会感觉技术果然是一路传承向前发展的。</p><blockquote><p>历史总会反复，但科技永远向前。</p></blockquote><p>​    本文很多内容来自我在多个公司的技术分享后的 ppt 截图，如果你对此 ppt 感兴趣，可以向我索要。</p><hr><h2 id="2-架构演变史"><a href="#2-架构演变史" class="headerlink" title="2 架构演变史"></a>2 架构演变史</h2><h3 id="2-1-单体架构"><a href="#2-1-单体架构" class="headerlink" title="2.1 单体架构"></a>2.1 单体架构</h3><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911170031961.png" srcset="/img/loading.gif" lazyload alt="image-20210911170031961"></p><blockquote><p>特点：</p><p>1 所有功能集成在一个项目工程中</p><p>2 所有功能打包在一个 web 包部署到服务器</p><p>3 应用跟数据库分开部署</p><p>4 通过部署应用集群和数据库集群来提高系统性能</p><p>优点：</p><p>架构简单，前期开发成本低，周期短。小型项目首选。</p><p>缺点:</p><p>1 全部功能集成在一个工程中，对于大型项目不易开发、扩展和维护</p><p>2 系统性能扩展只能通过扩展集群，成本高</p><p>3 技术栈受限</p></blockquote><h3 id="2-2-垂直架构"><a href="#2-2-垂直架构" class="headerlink" title="2.2 垂直架构"></a>2.2 垂直架构</h3><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911170047249.png" srcset="/img/loading.gif" lazyload alt="image-20210911170047249"></p><blockquote><p>特点：</p><p>当访问量逐渐增大，单一应用增加机器带来的性价比越来越小，将应用拆成互不相关的几个应用，以提升效率。</p><p>优点：</p><p>1 相关架构简单，前期开发成本低，周期短，小型项目的首选</p><p>2 通过垂直拆分，原来的单体不至于无限扩大</p><p>3 不同的项目可采用不同的技术栈</p><p>缺点：</p><p>1 同业务域功能集成在一个工程中，对于大型项目不易开发、扩展和维护成本高</p><p>2 系统性能扩展只能通过扩展集群，成本高，有瓶颈</p><p>3 单体之间的函数调用过度到系统之间的 rpc 或者 http 调用，服务发现需要单独机制保证</p></blockquote><h3 id="2-3-微服务架构"><a href="#2-3-微服务架构" class="headerlink" title="2.3 微服务架构"></a>2.3 微服务架构</h3><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911170101322.png" srcset="/img/loading.gif" lazyload alt="image-20210911170101322"></p><blockquote><p>特点：</p><p>1 将系统服务层完全独立出来，并将服务层抽取为一个个微服务</p><p>2 微服务遵循单一原则</p><p>3 微服务之间采用 RESTful轻量级协议进行传输</p><p>优点：</p><p>1 服务拆分粒度更细，有利于资源重复利用，提高开发效率</p><p>2 可以更加精准指定每个服务的优化方案，提高系统的可维护性</p><p>3 微服务架构采用去中心化思想，服务之间采用 RESTful 等轻量级协议通信，相比 ESB 更轻</p><p>4 适合互联网产品，产品迭代更加快速和便捷</p><p>缺点：</p><p>1 微服务过多，服务治理成本高，不利于系统维护</p><p>2 分布式系统开发的技术成本高（容错、分布式事务等），对团队技术挑战大</p></blockquote><hr><h2 id="3-微服务架构模型演进史"><a href="#3-微服务架构模型演进史" class="headerlink" title="3 微服务架构模型演进史"></a>3 微服务架构模型演进史</h2><p>​    微服务架构的模型也是一个从简单到复杂的演进过程。</p><h3 id="3-1-框架与通信"><a href="#3-1-框架与通信" class="headerlink" title="3.1 框架与通信"></a>3.1 框架与通信</h3><p>​    微服务架构初期，主要的技术诉求是寻找更简单和轻量的开发框架，不同的开发框架意味着采用不同的通信协议。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911170123931.png" srcset="/img/loading.gif" lazyload alt="image-20210911170123931"></p><h3 id="3-2-运行时的支撑服务"><a href="#3-2-运行时的支撑服务" class="headerlink" title="3.2 运行时的支撑服务"></a>3.2 运行时的支撑服务</h3><p>​    当服务的编写和通信解决了之后，接下来就要考虑一些运行时的支撑服务了。这些服务跟业务去耦，属于基础层的支撑服务，比如网关、负载均衡、服务注册与发现、配置中心等。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911170145110.png" srcset="/img/loading.gif" lazyload alt="image-20210911170145110"></p><h3 id="3-3-服务安全"><a href="#3-3-服务安全" class="headerlink" title="3.3 服务安全"></a>3.3 服务安全</h3><p>​    解决了服务的通信以及基础支撑后，大体上业务就可以开展了。但是这样裸奔的服务是有很大安全风险的，很多敏感的信息在不经过认证和授权就可以轻易获取到，因此服务安全就加入到了微服务的模型体系中。服务安全主要有两种，分别是 jwt 和 oauth2。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911170159703.png" srcset="/img/loading.gif" lazyload alt="image-20210911170159704"></p><h3 id="3-4-服务监控和告警"><a href="#3-4-服务监控和告警" class="headerlink" title="3.4 服务监控和告警"></a>3.4 服务监控和告警</h3><p>​    服务在解决了通信、支撑和安全之后，就可以愉快地展开工作了。但就跟判断健康需要做体检一样，判断在线服务是否健康就需要监控和遥测，当工作负载超过了阈值就要告警通知人为介入。服务的监控有很多的维度，常见地有系统指标监控、业务指标监控、服务健康检查、调用链监控、日志监控等。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911170231781.png" srcset="/img/loading.gif" lazyload alt="image-20210911170231781"></p><h3 id="3-5-服务部署"><a href="#3-5-服务部署" class="headerlink" title="3.5 服务部署"></a>3.5 服务部署</h3><p>​    容器化时代带来了新的运维思路，原有基于虚拟机、物理机的重运维开始向基于容器以及容器编排的轻运维转换，这种转换也带来了服务部署方式的改变。更快、更好、更有效的部署成为微服务架构模型新的挑战。</p><p>​    服务部署需要解决的问题有发布机制的引入、镜像治理、容器治理、卷管理、CI/CD 等方面。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911170305561.png" srcset="/img/loading.gif" lazyload alt="image-20210911170305561"></p><h3 id="3-6-底层服务"><a href="#3-6-底层服务" class="headerlink" title="3.6 底层服务"></a>3.6 底层服务</h3><p>​    当业务范围越来越广，再大的公司也不可能解决任何技术问题，这时就需要引入一些业界优秀的第三方服务作为底层服务来解决特定问题。有时这些第三方服务并不可能完全适合自己的架构，因此就需要做适当的剪裁。尽管如此，这些第三方服务也构成了整个微服务架构模型中不可或缺的一部分。常用的第三方底层服务有分布式消息中间件、分布式数据访问、分布式任务调度和分布式缓存等。底层服务跟基础支撑服务的区别在于前者更多在业务问题域，而后者则主要是通用问题域。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911170327813.png" srcset="/img/loading.gif" lazyload alt="image-20210911170327813"></p><h3 id="3-7-服务防护"><a href="#3-7-服务防护" class="headerlink" title="3.7 服务防护"></a>3.7 服务防护</h3><p>​    就像胃口再好的人也不可能一次吃下整头大象一样，编写再好的服务也不可能支持无限的请求。技术人员在处理无限、不可期技术场景的技术方案时，经常的策略是以不变应万变：根据目前的服务负载设置峰值，超过峰值就进行熔断、限流等措施。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911170345259.png" srcset="/img/loading.gif" lazyload alt="image-20210911170345259"></p><p>​    熔断如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911170426093.png" srcset="/img/loading.gif" lazyload alt="image-20210911170426093"></p><p>​    降级如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911170435845.png" srcset="/img/loading.gif" lazyload alt="image-20210911170435845"></p><p>​    限流如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911170444859.png" srcset="/img/loading.gif" lazyload alt="image-20210911170444859"></p><h3 id="3-8-全链路压测"><a href="#3-8-全链路压测" class="headerlink" title="3.8 全链路压测"></a>3.8 全链路压测</h3><p>​    在上面的介绍中，我们介绍了微服务架构模型的各个维度。本来可以在这里结束，但是想想实在不妥，因为我们缺少了很关键的一环，那便是测试。</p><p>​    全链路压测是稍具规模的科技公司都必须要做的工作之一。它的重要性不言而喻，当业务发展超出预期，系统要具有先知先觉的能力以抵御洪灾。毕竟未雨绸缪总好过亡羊补牢。全链路压测是一个大的话题，因为这里介绍的是 istio，故这里一笔带过，有关 ppt 详情我也照顾篇幅不再赘述，如果有朋友对此感兴趣，可以向我索要。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911170456807.png" srcset="/img/loading.gif" lazyload alt="image-20210911170456807"></p><hr><h2 id="4-微服务架构模型全景图"><a href="#4-微服务架构模型全景图" class="headerlink" title="4 微服务架构模型全景图"></a>4 微服务架构模型全景图</h2><p>​    下图展示了整个微服务架构模型：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911170507833.png" srcset="/img/loading.gif" lazyload alt="image-20210911170507833"></p><hr><h2 id="5-带来的问题"><a href="#5-带来的问题" class="headerlink" title="5 带来的问题"></a>5 带来的问题</h2><p>​    微服务架构的引入带来了很多好处，但同时也带来了服务治理诸多的问题。核心问题如下：</p><h3 id="5-1-服务治理方式不统一"><a href="#5-1-服务治理方式不统一" class="headerlink" title="5.1 服务治理方式不统一"></a>5.1 服务治理方式不统一</h3><p>​    不同服务治理的方式会引入不同的中间件，而这些中间件的技术标准和维护标准都不同。因此运维人员或者架构人员必须掌握每种中间件的使用方法，很多时候这对一个人力资源有限的科技公司并不现实。</p><h3 id="5-2-重复造轮子"><a href="#5-2-重复造轮子" class="headerlink" title="5.2 重复造轮子"></a>5.2 重复造轮子</h3><p>​    微服务架构是允许多语言栈、多技术栈的，但不同的技术栈针对通信、支撑服务、服务安全、服务监控、熔断/降级/限流等通用技术问题却需要各自的解决方案，实在是成本的浪费。</p><h3 id="5-3-服务治理缺乏标准化"><a href="#5-3-服务治理缺乏标准化" class="headerlink" title="5.3 服务治理缺乏标准化"></a>5.3 服务治理缺乏标准化</h3><p>​    由于服务治理缺乏标准化，因此微服务治理的好坏全依靠技术人员个人的能力、经验和水平，这就有点像手工作坊时代，器物优质全靠工匠。但是无标准化显然不符合科技发展的轨迹。</p><hr><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h2><p>​    微服务发展目前已经趋于稳定，并成为了技术主流，但与此同时它的处境却越来越尴尬，暴露的问题也越来越尖锐。幸运的是，服务网格时代到来了，服务网格的领军 istio 正稳步进入历史舞台，并变得越来越炙手可热。下文九析将继续带你轻松完爆 istio。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆 service mesh - istio Gateway 设置路由</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-Gateway-%E8%AE%BE%E7%BD%AE%E8%B7%AF%E7%94%B1/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86-service-mesh-istio-Gateway-%E8%AE%BE%E7%BD%AE%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<p>1 流量管理</p><p>2 创建命名空间</p><p>3 资源文件准备</p><p>  3.1 创建网关文件</p><p>  3.2 创建虚拟服务文件</p><p>  3.3 创建 k8s service 文件</p><p>  3.4 创建 k8s deployment 文件：</p><p>  3.5 修改 istio-ingressgateway deployment</p><p>4 尝试网关路由功能</p><p>  4.1 确定 INGRESS_HOST</p><p>  4.2 编辑浏览器所在主机 hosts 文件</p><p>  4.3 访问 tomcat</p><p>5 小节</p><hr><h2 id="1-流量管理（traffic-management）"><a href="#1-流量管理（traffic-management）" class="headerlink" title="1 流量管理（traffic management）"></a>1 流量管理（traffic management）</h2><p>​    如果你对博客有任何疑问，请告诉我。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911165314268.png" srcset="/img/loading.gif" lazyload alt="image-20210911165314268"></p><p>​    istio 四大特性是流量管理（traffic management）、安全（security）、策略（policies）和遥测（observability）。</p><p>​    本节重点介绍 istio 流量管理。流量管理的本质是对网络流量的路由和控制。生活中经常有这样的例子，比如下雨塌方，交警会疏导新的交通路线，这便是路由；比如景区周末实行单双号限行，这便是流量控制。</p><p>​    在介绍流量管理之前，首先介绍一下网络流向，介绍一个 http 请求在安装了 istio 的 k8s 中都经过哪些点，有了这个介绍之后，再谈流量管理将是水到渠成的事情。</p><p>​    下图便是网络流向图：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911165357073.png" srcset="/img/loading.gif" lazyload alt="image-20210911165357073"></p><p>​    当用户使用浏览器发起一个请求( <a href="http://jiuxi.com/xxx">http://jiuxi.com/xxx</a> )进入 k8s 中的 istio-ingressgateway，因为在  istio-ingressgateway 上设置了 istio 的 gateway，而且此 gateway 又绑定了 virtual  service，在 virtual service 设置了 2 条路由规则，分别指向 tomcat 和 nginx 这 2 个 k8s  service，而每个 service 又关联到各自的 pod，于是此请求最终可根据 url 触达到 pod 内的容器。</p><p>​    了解了请求流向的整个流程，下面介绍如何操作。前提是你已经安装好了 k8s 和 istio。关于如何安装和配置 istio，可以查看本人的系列文章第一章。</p><hr><h2 id="2-创建命名空间"><a href="#2-创建命名空间" class="headerlink" title="2 创建命名空间"></a>2 创建命名空间</h2><blockquote><p>kubectl create ns jiuxi</p></blockquote><p>​    istio 默认安装在 jiuxi 这个命名空间下，并且设置在 jiuxi 命名空间自动注入 sidecar。相关操作请参考本人系列文章的第一章。</p><hr><h2 id="3-资源文件准备"><a href="#3-资源文件准备" class="headerlink" title="3 资源文件准备"></a>3 资源文件准备</h2><p>​    从上图可知，共需要 4 个资源文件（yaml）：</p><blockquote><p>1 jiuxi-gateway.yaml</p><p>2 jiuxi-virtual-svc.yaml</p><p>3 jiuxi-svc.yaml( tomcat 和 nginx 的 service 写在一个文件）</p><p>4 jiuxi-deploy.yaml（tomcat 和 nginx 的 deployment 写在一个文件）</p></blockquote><h3 id="3-1-创建网关文件"><a href="#3-1-创建网关文件" class="headerlink" title="3.1 创建网关文件"></a>3.1 创建网关文件</h3><p>​    网关文件 jiuxi-gateway.yaml 文件内容如下：</p><blockquote><p>apiVersion: networking.istio.io/v1alpha3</p><p>kind: Gateway</p><p>metadata:</p><p>  name: jiuxi-gateway</p><p>  namespace: jiuxi</p><p>spec:</p><p>  selector:</p><p>​    istio: ingressgateway</p><p>servers:</p><p>- hosts:</p><p>  - jiuxi.com</p><p>  port:</p><p>​    number: 80</p><p>​    name: http</p><p>​    protocol: HTTP</p></blockquote><p>​    创建资源：</p><blockquote><p>kubectl apply -f jiuxi-gateway.yaml</p></blockquote><h3 id="3-2-创建虚拟服务文件"><a href="#3-2-创建虚拟服务文件" class="headerlink" title="3.2 创建虚拟服务文件"></a>3.2 创建虚拟服务文件</h3><p>​    虚拟服务文件 jiuxi-virtual-svc.yaml 文件内容如下：</p><blockquote><p>apiVersion: networking.istio.io/v1alpha3</p><p>kind: VirtualService</p><p>metadata:</p><p>  name: jiuxi-virtual-svc</p><p>  namespace: jiuxi</p><p>spec:</p><p>  gateways:</p><p>  - jiuxi-gateway</p><p>  hosts:</p><p>  - jiuxi.com</p><p>  http:</p><p>  - route:</p><p>​    - destination:</p><p>​       host: tomcat-svc</p><p>​       port:</p><p>​         number: 8080</p><p>​    weight: 50</p><p>​    - destination:</p><p>​       host: nginx-svc</p><p>​       port:</p><p>​         number: 80</p><p>​    weight: 50</p></blockquote><p>​    创建资源：</p><blockquote><p>kubectl apply -f jiuxi-virtual-svc.yaml</p></blockquote><h3 id="3-3-创建-k8s-service-文件"><a href="#3-3-创建-k8s-service-文件" class="headerlink" title="3.3 创建 k8s service 文件"></a>3.3 创建 k8s service 文件</h3><p>​    服务文件 jiuxi-svc.yaml 文件内容如下：</p><blockquote><p>apiVersion: v1</p><p>kind: Service</p><p>metadata:</p><p>  name: nginx-svc</p><p>  namespace: jiuxi</p><p>spec:</p><p>  ports:</p><p>  - name: port</p><p>​    port: 80</p><p>​    protocol: TCP</p><p>​    targetPort: 80</p><p>   selector:</p><p>​    app: nginx-pod</p><p>-–</p><p>apiVersion: v1</p><p>kind: Service</p><p>metadata:</p><p>  name: tomcat-svc</p><p>  namespace: jiuxi</p><p>spec:</p><p>  ports:</p><p>  - name: port</p><p>​    port: 8080</p><p>​    protocol: TCP</p><p>​    targetPort: 8080</p><p>  selector:</p><p>  app: tomcat-pod</p></blockquote><p>​    创建资源：</p><blockquote><p>kubectl apply -f jiuxi-svc.yaml</p></blockquote><h3 id="3-4-创建-k8s-deployment-文件"><a href="#3-4-创建-k8s-deployment-文件" class="headerlink" title="3.4 创建 k8s deployment 文件"></a>3.4 创建 k8s deployment 文件</h3><p>​    jiuxi-deploy 文件内容如下：</p><blockquote><p>apiVersion: apps/v1 </p><p>kind: Deployment </p><p>metadata: </p><p>  labels: </p><p>  app: nginx-deploy </p><p>  name: nginx-deploy </p><p>  namespace: jiuxi </p><p>spec: </p><p>  replicas: 1 </p><p>  selector: </p><p>​    matchLabels: </p><p>​      app: nginx-pod  </p><p>  template: </p><p>​    metadata: </p><p>​      labels: </p><p>​        app: nginx-pod  </p><p>​    spec: </p><p>​      containers:     </p><p>​      - image: nginx:1.14-alpine </p><p>​        imagePullPolicy: Always </p><p>​        name: nginx </p><p>​        ports: </p><p>​        - containerPort: 80 </p><p>​          name: port </p><p>​          protocol: TCP</p><p> —</p><p> apiVersion: apps/v1 </p><p>kind: Deployment</p><p>metadata: </p><p>  labels: </p><p>​    app: tomcat-deploy </p><p>  name: tomcat-deploy </p><p>  namespace: jiuxi </p><p>spec: </p><p>  replicas: 1 </p><p>  selector: </p><p>​    matchLabels: </p><p>​      app: tomcat-pod  </p><p>  template: </p><p>​    metadata: </p><p>​      labels: </p><p>​        app: tomcat-pod  </p><p>​    spec:</p><p>​      containers:</p><p>​      - image: docker.io/kubeguide/tomcat-app:v1</p><p>​        imagePullPolicy: Always</p><p>​        name: tomcat</p><p>​        ports:</p><p>​          - containerPort: 8080</p><p>​          name: port</p><p>​          protocol: TCP</p></blockquote><p>​    创建资源：</p><blockquote><p>kubectl apply -f jiuxi-deploy.yaml</p></blockquote><h3 id="3-5-修改-istio-ingressgateway-deployment"><a href="#3-5-修改-istio-ingressgateway-deployment" class="headerlink" title="3.5 修改 istio-ingressgateway deployment"></a>3.5 修改 istio-ingressgateway deployment</h3><p>​    这一步非常重要，因为默认情况下 istio-ingressgateway 对应的容器并没有暴露在服务网格之外，所以我们需要将其暴露出来。编辑 istio-system  命名空间下的 istio-ingressgateway deployment:</p><blockquote><p>kubectl edit deployment -n istio-system istio-ingressgateway</p></blockquote><p>​    修改内容如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911165456105.png" srcset="/img/loading.gif" lazyload alt="image-20210911165456105"></p><hr><h2 id="4-尝试网关路由功能"><a href="#4-尝试网关路由功能" class="headerlink" title="4 尝试网关路由功能"></a>4 尝试网关路由功能</h2><h3 id="4-1-确定-INGRESS-HOST"><a href="#4-1-确定-INGRESS-HOST" class="headerlink" title="4.1 确定 INGRESS_HOST"></a>4.1 确定 INGRESS_HOST</h3><blockquote><p>kubectl get pod -n istio-system -o wide</p></blockquote><p>​    执行结果如下图所示，本人的 INGRESS_HOST 就是 10.110.101.205。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911165522752.png" srcset="/img/loading.gif" lazyload alt="image-20210911165522752"></p><h3 id="4-2-编辑浏览器所在主机-hosts-文件"><a href="#4-2-编辑浏览器所在主机-hosts-文件" class="headerlink" title="4.2 编辑浏览器所在主机 hosts 文件"></a>4.2 编辑浏览器所在主机 hosts 文件</h3><blockquote><p>vim /etc/hosts    # linux</p><p>c:/windows/system32/drivers/etc/hosts    # windows</p></blockquote><p>​    添加 DNS 记录：</p><blockquote><p>10.110.101.205    jiuxi.com        # 根据个人实际情况改写</p></blockquote><h3 id="4-3-访问-tomcat"><a href="#4-3-访问-tomcat" class="headerlink" title="4.3 访问 tomcat"></a>4.3 访问 tomcat</h3><p>​    浏览器输入 <a href="http://jiuxi.com,帮尝试多刷新几次,你就会看到流量分别路由到/">http://jiuxi.com，帮尝试多刷新几次，你就会看到流量分别路由到</a> tomcat 和 nginx 服务去了，并且流量上基本达到了均分，各 50%。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911165604673.png" srcset="/img/loading.gif" lazyload alt="image-20210911165604673"></p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911165626103.png" srcset="/img/loading.gif" lazyload alt="image-20210911165626103"></p><hr><h2 id="5-小节"><a href="#5-小节" class="headerlink" title="5 小节"></a>5 小节</h2><p>​    自此我们使用了 istio 的 gateway 和 virtual service 实现了流量管理的功能。下面我们还会继续庖丁解牛 istio 其他强大的特性。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆服务网格 - istio Bookinfo 应用</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC-istio-Bookinfo-%E5%BA%94%E7%94%A8/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC-istio-Bookinfo-%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 bookinfo 架构介绍</p><p>3 bookinfo 配置与部署</p><p>  3.1 配置 istio 自动注入</p><p>  3.2 部署 bookinfo 应用</p><p>  3.3 验证 bookinfo 部署情况</p><p>4 设置 bookinfo 网关</p><p>  4.1 定义 bookinfo 入口网关</p><p>  4.2 确认网关已创建</p><p>5 访问 bookinfo 应用</p><p>  5.1 获取 INGRESS_HOST</p><p>  5.2 获取 INGRESS_PORT</p><p>  5.3 通过浏览器访问 bookinfo 应用</p><p>6 卸载 bookinfo 应用</p><p>  6.1 验证卸载</p><p>7 总结</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    如果你对博客有任何疑问或者想更深入学习 istio，请加微信群，我们一起进步：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164235979.png" srcset="/img/loading.gif" lazyload alt="image-20210911164235979"></p><hr><h2 id="2-bookinfo-架构介绍"><a href="#2-bookinfo-架构介绍" class="headerlink" title="2 bookinfo 架构介绍"></a>2 bookinfo 架构介绍</h2><p>​    bookinfo 是 istio 的学习样例，通过 bookinfo 你可以对 istio 提供的路由、遥测等功能有更加深入的理解。</p><p>​    下图是 bookinfo 在没有嵌入 istio 前的物理架构图：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164302523.png" srcset="/img/loading.gif" lazyload alt="image-20210911164302523"></p><p>​    bookinfo 是一个在线书店应用，该应用由 4 个微服务组成，分别为 Product page、Reviews、Details 和 Ratings。为了表现 istio 的无侵入性，这 4 个微服务分别由 python、java、ruby 和 node 开发。下面分别说明如下：</p><blockquote><p>Product page：聚合服务，内容由 Reviews 和 Details 内容聚合而成</p><p>Details：图书详情服务</p><p>Reviews：图书评价服务（多版本）。它也是一个聚合服务，聚合了 Ratings</p><p>Ratings：图书预订排名服务</p></blockquote><p>​    下图是 bookinfo 嵌入 istio 后的物理架构图：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164323375.png" srcset="/img/loading.gif" lazyload alt="image-20210911164323375"></p><p>​    该架构图演示了嵌入 istio 后 bookinfo 的每个微服务都会新增一个 Envoy，这个 Envoy 就是所谓的  sidecar，它会接管跟它配对的微服务的所有网络进、出口流量。其实  Envoy（sidecar）的作用就像你的手机，它正在逐渐把你变成哑巴、聋子和植物人，它承接了你所有的信息入口和出口，某些别有用心的人和组织通过对手机进行监控、遥测、路由等控制，起到控制你的思维、舆论导向、审美爱好等目的。</p><hr><h2 id="3-bookinfo-配置与部署"><a href="#3-bookinfo-配置与部署" class="headerlink" title="3 bookinfo 配置与部署"></a>3 bookinfo 配置与部署</h2><h3 id="3-1-配置-istio-自动注入"><a href="#3-1-配置-istio-自动注入" class="headerlink" title="3.1 配置 istio 自动注入"></a>3.1 配置 istio 自动注入</h3><p>​    因为 bookinfo 会启动多个 pod，每次手动注入 sidecar 会特别繁琐，因此我们使用批注入的方式。如果你对 sidecar 注入不了解，请参考本人的<a href="https://blog.51cto.com/14625168/2474271"> 上篇</a>博客。</p><blockquote><p>kubectl create ns jiuxi    # 创建 jiuxi 命名空间</p><p>kubectl label ns jiuxi istio-injection=enabled</p><p>kubectl get ns jiuxi –show-labels</p></blockquote><p>​    命令操作成功后截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164338022.png" srcset="/img/loading.gif" lazyload alt="image-20210911164338022"></p><h3 id="3-2-部署-bookinfo-应用"><a href="#3-2-部署-bookinfo-应用" class="headerlink" title="3.2 部署 bookinfo 应用"></a>3.2 部署 bookinfo 应用</h3><p>​    在命名空间 jiuxi 中部署了 bookinfo 应用：</p><blockquote><p>kubectl apply -f bookinfo/platform/kube/bookinfo.yaml -n jiuxi</p></blockquote><p>​    部署过程截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164350324.png" srcset="/img/loading.gif" lazyload alt="image-20210911164350324"></p><p>​    执行如下命令查看 bookinfo 的 service 列表：</p><blockquote><p>kubectl get svc -n jiuxi</p></blockquote><p>​    服务列表截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164402895.png" srcset="/img/loading.gif" lazyload alt="image-20210911164402895"></p><p>​    执行如下命令查看 bookinfo 的 pod 列表：</p><blockquote><p>kubectl get pod -n jiuxi</p></blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164416004.png" srcset="/img/loading.gif" lazyload alt="image-20210911164416004"></p><h3 id="3-3-验证-bookinfo-部署情况"><a href="#3-3-验证-bookinfo-部署情况" class="headerlink" title="3.3 验证 bookinfo 部署情况"></a>3.3 验证 bookinfo 部署情况</h3><p>​    在服务列表中寻找 productpage 服务，然后使用 curl 命令验证服务是否发布成功。</p><blockquote><p>kubectl get svc -n jiuxi</p><p>curl <a href="http://svc_cluster_ip:9080/">http://SVC_CLUSTER_IP:9080</a> | grep -o “<title>.*</title>“</p></blockquote><p>​    执行成功的结果如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164429965.png" srcset="/img/loading.gif" lazyload alt="image-20210911164429965"></p><p>​    自此，整个 bookinfo 应用就已经成功部署了。</p><hr><h2 id="4-设置-bookinfo-网关"><a href="#4-设置-bookinfo-网关" class="headerlink" title="4 设置 bookinfo 网关"></a>4 设置 bookinfo 网关</h2><p>​    上面的步骤已经可以让你访问到 bookinfo 应用了。但是我知道有些同学依旧觉得寒碜，因为很多人还是通过浏览器来看世界的。</p><p>​    网关就相当于你房子的大门，每当你饥肠辘辘回到家，你可以通过全开、半开、开一条缝等动作控制隔壁大妈家饭菜的饭菜香味。后续课程会专门介绍网关更深层次的原理和运用。这里你先有个粗浅的理解就可以了。</p><h3 id="4-1-定义-bookinfo-入口网关"><a href="#4-1-定义-bookinfo-入口网关" class="headerlink" title="4.1 定义 bookinfo 入口网关"></a>4.1 定义 bookinfo 入口网关</h3><blockquote><p>kubectl apply -f istio-1.4.5/samples/bookinfo/networking/bookinfo-gateway.yaml -n jiuxi</p></blockquote><h3 id="4-2-确认网关已创建"><a href="#4-2-确认网关已创建" class="headerlink" title="4.2 确认网关已创建"></a>4.2 确认网关已创建</h3><blockquote><p>kubectl get gateways.networking.istio.io -n jiuxi</p></blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164445960.png" srcset="/img/loading.gif" lazyload alt="image-20210911164445960"></p><hr><h2 id="5-访问-bookinfo-应用"><a href="#5-访问-bookinfo-应用" class="headerlink" title="5 访问 bookinfo 应用"></a>5 访问 bookinfo 应用</h2><h3 id="5-1-获取-INGRESS-HOST"><a href="#5-1-获取-INGRESS-HOST" class="headerlink" title="5.1 获取 INGRESS_HOST"></a>5.1 获取 INGRESS_HOST</h3><blockquote><p>kubectl get po -l istio=ingressgateway -n istio-system -o jsonpath=’{.items[0].status.hostIP}’</p></blockquote><h3 id="5-2-获取-INGRESS-PORT"><a href="#5-2-获取-INGRESS-PORT" class="headerlink" title="5.2 获取 INGRESS_PORT"></a>5.2 获取 INGRESS_PORT</h3><blockquote><p>kubectl -n istio-system get service istio-ingressgateway -o jsonpath=’{.spec.ports[?(@.name==”http2”)].nodePort}’</p></blockquote><h3 id="5-3-通过浏览器访问-bookinfo-应用"><a href="#5-3-通过浏览器访问-bookinfo-应用" class="headerlink" title="5.3 通过浏览器访问 bookinfo 应用"></a>5.3 通过浏览器访问 bookinfo 应用</h3><p>​    根据 5.1 和 5.2 获取到 host 和 port 信息，如下截图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164506614.png" srcset="/img/loading.gif" lazyload alt="image-20210911164506614"></p><p>​    根据此 host 和 port，打开浏览器进行访问：</p><p>​    多刷新几次页面，你会发现 bookinfo 应用使用到的多个 reviews 版本，如下所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164538736.png" srcset="/img/loading.gif" lazyload alt="image-20210911164538736"></p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164551497.png" srcset="/img/loading.gif" lazyload alt="image-20210911164551497"></p><p>​    正好可以对应到 pod 信息：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164605008.png" srcset="/img/loading.gif" lazyload alt="image-20210911164605009"></p><hr><h2 id="6-卸载-bookinfo-应用"><a href="#6-卸载-bookinfo-应用" class="headerlink" title="6 卸载 bookinfo 应用"></a>6 卸载 bookinfo 应用</h2><p>​    你已经创建了 bookinfo，有了创建的快感。也许你有点怅然若失，因为你觉得你的技术人生不够圆满，你想亲身完爆你创建的一切，那么还等什么，执行下面的语句吧：</p><blockquote><p>./istio-1.4.5/samples/bookinfo/platform/kube/cleanup.sh</p></blockquote><p>​    命令执行成功后，会显示如下截图：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911164619983.png" srcset="/img/loading.gif" lazyload alt="image-20210911164619983"></p><h3 id="6-1-验证卸载"><a href="#6-1-验证卸载" class="headerlink" title="6.1 验证卸载"></a>6.1 验证卸载</h3><p>​    执行如下命令验证你是否成功卸载：</p><blockquote><p>kubectl get virtualservices.networking.istio.io -n jiuxi</p><p>kubectl get destinationrules.networking.istio.io -n jiuxi</p><p>kubectl get gateways.networking.istio.io -n jiuxi</p><p>kubectl get pod -n jiuxi</p></blockquote><p>​    但是假如你觉得破坏的感觉很爽，就像嚼了炫迈一下停不下来，你可以执行如下作死命令：</p><blockquote><p>rm -rf /   # 你要是真敢这么做，我就崇拜你</p></blockquote><hr><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h2><p>​    自此，九析已经带你轻松完爆了 Bookinfo 应用。相信在操作的过程中，你还有很多不理解的地方，但是没关系，后续九析会为你庖丁解牛的。你需要做的，就是跟着九析操作一遍，熟悉一下整个流程，后续某天你一定会在某个瞬间大声尖叫：“我得到了”。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆服务网格 - istio 初探</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC-istio-%E5%88%9D%E6%8E%A2/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC-istio-%E5%88%9D%E6%8E%A2/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 istio 初探</p><p>  2.1 手动注入 sidecar</p><p>  2.2 自动注入 sidecar</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    如果你对博客有任何疑问，请加微信沟通：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584496625204864.png" srcset="/img/loading.gif" lazyload alt="第二章 九析带你轻松完爆服务网格 - istio 初探_服务网格"></p><p>​    你可以从下面截图中获取免费的、更生动的视频资料，在 b 站搜索“九析”：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584496646484217.png" srcset="/img/loading.gif" lazyload alt="第二章 九析带你轻松完爆服务网格 - istio 初探_服务网格_02"></p><hr><h2 id="2-istio-初探"><a href="#2-istio-初探" class="headerlink" title="2 istio 初探"></a>2 istio 初探</h2><p>​    上节九析带你轻松完爆了 istio 的安装。但是我相信安装成功的小伙伴依然云里雾里，因为看着一大坨 pod 在那里 running  着，似乎并没有产生任何作用。这节，九析就带你“莫畏浮云遮望眼，守得云开见月明”。为了预期效果，我们不妨先建立一个  deployment，内容如下：</p><blockquote><p>apiVersion: apps/v1</p><p>kind: Deployment</p><p>metadata:</p><p>  name: nginx</p><p>  labels:</p><p>​    app: nginx</p><p>spec:</p><p>  replicas: 1</p><p>  selector:</p><p>​    matchLabels:</p><p>​      app: nginx</p><p>  template:</p><p>​    metadata:</p><p>​      labels:</p><p>​        app: nginx</p><p>​    spec:</p><p>​      containers:</p><p>​      - name: nginx</p><p>​        image: nginx:1.14-alpine</p><p>​        ports:</p><p>​        - containerPort: 80</p></blockquote><p>​    创建 deployment，当然为了让你能更深刻地记住哥，把哥印在灵魂深处，你需要首先创建一个命名空间：</p><blockquote><p>kubectl create ns jiuxi</p><p>kubectl apply -f nginx-deployment.yaml -n jiuxi</p></blockquote><p>​    命令执行成功后，查询 nginx pod 状态：</p><blockquote><p>kubectl get pods -n jiuxi</p></blockquote><p>​    截图如下：需要注意 ready 这一列，内容为 1/1，表示的含义是 pod 内有一个容器，且该容器运行成功并处于就绪状态。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911163851179.png" srcset="/img/loading.gif" lazyload alt="image-20210911163851179"></p><p>​    下面到了激动人心的时刻了，因为 istio 即将闪亮登场。</p><h3 id="2-1-手动注入-sidecar"><a href="#2-1-手动注入-sidecar" class="headerlink" title="2.1 手动注入 sidecar"></a>2.1 手动注入 sidecar</h3><p>​    执行如下语句：</p><blockquote><p>kube-inject -f nginx-deployment.yaml | kubectl apply  -n jiuxi -f -</p></blockquote><p>​    命令执行结果如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911163908323.png" srcset="/img/loading.gif" lazyload alt="image-20210911163908323"></p><p>​    此时你会发现一个奇怪的现象，nginx-deployment.yaml 并没修改，但是 ready 状态却变成了 2/2。根据上面的解释可知，现在 pod 内有两个容器，且这两个容器都运行成功并处于就绪状态。为什么多了一个容器呢？</p><p>​    查看 pod 的详细信息：</p><blockquote><p>kubectl get pod -n jiuxi nginx-xxxx -o yaml # xxxx 根据自己实际情况填写</p></blockquote><p>​    如果你有类似 rancher 这样的 web 控制台，可以看得更仔细些，如下图所示。如果你还没有安装和配置 rancher，你可以参考哥的轻松完爆 rancher 系列进行安装，放心，容易到爆，容易到你尖叫。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911163928463.png" srcset="/img/loading.gif" lazyload alt="image-20210911163928463"></p><p>​    从上图可知。此时 nginx pod 内部一共有 3 个容器，一个初始化容器 istio-init 已经运行成功并结束了，一个就是 nginx  本尊，另外一个就是本文的主角 istio-proxy 了，它就是 sidecar，作用跟鸡你太美的经纪人的作用差不多，负责跟外部打交道用的。</p><p>​    此时此刻，你已经为 pod 手工织入了 istio。但是这样似乎有点不够爽。因为每建立一个 pod 都撸这么一管，感觉有点累，有没有批量或者更自然的方式呢？</p><h3 id="2-2-命名空间注入-sidecar"><a href="#2-2-命名空间注入-sidecar" class="headerlink" title="2.2 命名空间注入 sidecar"></a>2.2 命名空间注入 sidecar</h3><p>​    现在我们删除掉刚才创建的 nginx：</p><blockquote><p>kubectl delete deployments.apps nginx -n jiuxi</p></blockquote><p>​    执行如下命令在命名空间内实现自动注入 sidecar：</p><blockquote><p>kubectl label namespaces jiuxi istio-injection=enabled</p><p>kubectl get ns jiuxi –show-labels # 查看 label 是否成功创建</p></blockquote><p>​    再次根据 nginx-deployment.yaml 文件创建 nginx deployment：</p><blockquote><p>kubectl apply -f nginx-deployment.yaml -n jiuxi</p></blockquote><p>​    创建成功后查看 pod 信息，发现已经自动织入了 sidecar。</p><p>​    自此，本节九析带你轻松完爆了 istio 的手动和自动织入功能。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九析带你轻松完爆服务网格 - istio 安装</title>
    <link href="/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC-istio-%E5%AE%89%E8%A3%85/"/>
    <url>/2021/09/11/%E4%B9%9D%E6%9E%90%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AE%8C%E7%88%86%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC-istio-%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p>1 前言</p><p>2 微服务的历史</p><p>3 istio</p><p>4 istio 使用</p><p>  4.1 下载 istio</p><p>  4.2 安装 istio</p><p>  4.3 配置 istioctl 工具路径</p><p>  4.4 实现 istioctl 自动补全功能</p><p>  4.5 安装学习版 istio</p><p>  4.6 卸载 istio</p><p>5 总结</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    如果你对博客有任何疑问，请加微信沟通：<img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584453790467569.jpg" srcset="/img/loading.gif" lazyload alt="第一章 九析带你轻松完爆服务网格 - istio 安装_k8s istio"></p><p>​    你可以从下面截图中获取免费的、更生动的视频资料，在 b 站搜索“九析”：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/1584453854320948.png" srcset="/img/loading.gif" lazyload alt="第一章 九析带你轻松完爆服务网格 - istio 安装_service mesh_02"></p><hr><h2 id="2-微服务的历史"><a href="#2-微服务的历史" class="headerlink" title="2 微服务的历史"></a>2 微服务的历史</h2><p>​    微服务从马丁提出到今天为止，大体上经过了四代。</p><p>​    第一代（1.0  时代）：服务发现阶段。单体服务发展到微服务后，原先的通信方式从进程内函数调用发展到了不同服务器上的不同服务之间的进程调用，这样的架构变化，首先要解决的关键问题就是服务的注册与发现。代表技术便是 dubbo 和 grpc、brpc 框架之争。</p><p>​    第二代（2.0 时代）：当服务发现问题解决了之后，紧接着带来的挑战便是服务治理。何为服务治理，就是除了服务之间通讯之外，还需要更深层次考虑到服务之间调用的失败重试、容错、降级、监控、安全、灰度、流控能问题。</p><p>​    第三代（3.0 时代）：微服务 2.0  时代带来了解决方案的百花齐放，各方你方唱罢，我方登场，相同问题的不同解决方案纷纷亮相，一时间风云际会，好不热闹。比如网关解决方案就有  zuul、gateway；全链路监控就有 pinpoint、zipkin、jaeger  等。各种服务治理的解决方案层出不穷带来了很多的积极作用，但负面影响也随之而来，那便是标准的不统一、维护方式各异。服务治理变成了各种中间件的相互嫁接，服务治理的好坏全靠工程师的技术水平高低。基于此，服务治理的标准化、一致化需求越来越强烈，于是服务网格便应运而生。服务网格的思想便是将服务治理标准化，并统一下沉到基础设施层。就像 50、60  年代的美国，当时帮派林立，不同地盘治理的好坏主要依靠各个帮派屌不屌，但是到了后来政府能力逐渐强大和稳定，很多地下秩序不再依靠黑帮，而统一让政府规则化一样的道理。</p><p>​    第四代（4.0 时代）：无服务时代，即 serveless 时代，说的时髦点就是去中心化时代。这个目前还并不成熟，本文先略去不谈。</p><hr><h2 id="3-istio"><a href="#3-istio" class="headerlink" title="3 istio"></a>3 istio</h2><p>​    istio 就是微服务 3.0 时代的产物，是 service mesh 的代表性产品。由谷歌和 IBM 联手打造。借助谷歌的拳头产品  k8s，顷刻完爆众神。istio 跟 k8s 之间到底什么关系？你可以这么来理解，k8s 相当于王健林，istio  相当于王思聪。怎么说呢？k8s 负责打地基，打造基础设施，istio  负责在地基之上整合各种服务模式。大家都知道有个女的去万达影院看电影抱怨爆米花少，结果王思聪承诺给她终生免费提供爆米花的事吧。这就相当于请求失败并重试成功的典型服务治理案例。</p><p>​    istio 包括如下特性：</p><blockquote><p>1 http, gRPC, WebSocket 和 TCP 通信的自动负载均衡</p><p>2 通过丰富的路有规则、重试、故障转移和故障注入对流量行为进行细粒度控制</p><p>3 可插拔的策略层和配置 API，支持访问控制，速率限制和配额</p><p>4 集群内所有流量的自动度量，日志和跟踪，包括集群的入口和出口</p><p>5 通过强大的基于身份和身份验证和授权，在集群中实现安全的服务间通信</p></blockquote><p>​    简单总结便是：istio 负责网络数据包的流量管理（traffic management）、服务的安全保护（secure）、策略（policy，比如黑白名单制定）和可观察（observability，比如监控）。</p><hr><h2 id="4-istio-使用"><a href="#4-istio-使用" class="headerlink" title="4 istio 使用"></a>4 istio 使用</h2><p>​    逼逼完了理论后（其实我最不喜欢就是扯理论），开始进入完爆 istio 环节。</p><h3 id="4-1-下载-istio"><a href="#4-1-下载-istio" class="headerlink" title="4.1 下载 istio"></a>4.1 下载 istio</h3><p>​    在玩 istio 之前，必须要有前置条件，那就是你要先把 k8s 完爆了，你需要首先搭建 k8s 环境。怎么搭建 k8s，你可以参考本人的《<a href="https://blog.51cto.com/14625168/2453827"> 一分钟搭建 k8s 教程</a>》，不用谢。</p><p>​    使用如下语句下载 istio，下载速度会有点慢。至于有多慢？谁试谁知道。而且时不时会断，所以你要时刻关注，如果失败了，需要重新执行。这种感觉就好像你在小便，后面总是有人推你，让你整个过程非常不顺畅，非常不爽。</p><blockquote><p>curl -L <a href="https://istio.io/downloadIstio">https://istio.io/downloadIstio</a> | sh -</p></blockquote><p>​    在下载过程中，如果你遭遇如下错误：</p><blockquote><p>Unable to get latest Istio version. Set ISTIO_VERSION env var and re-run. For example: export ISTIO_VERSION=1.0.4</p></blockquote><p>​    你需要设置一下你要下载的 istio 版本，语句如下：</p><blockquote><p>export ISTIO_VERSION=1.4.5</p></blockquote><p>​    下载成功后的截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911163236926.png" srcset="/img/loading.gif" lazyload alt="image-20210911163236926"></p><h3 id="4-2-安装-istio"><a href="#4-2-安装-istio" class="headerlink" title="4.2 安装 istio"></a>4.2 安装 istio</h3><p>​    安装 istio 前，首先解压缩：</p><blockquote><p>tar -zxvf istio-1.4.5-linux.tar.gz</p></blockquote><p>​    解压缩后的目录结构截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911163255978.png" srcset="/img/loading.gif" lazyload alt="image-20210911163255978"></p><p>​    关键目录说明如下：</p><blockquote><p>install/kubernetes    # istio 资源文件</p><p>samples            # istio 样例</p><p>bin/istioctl        # istio 客户端工具，用来手动注入 envoy</p></blockquote><h3 id="4-3-配置-istioctl-工具路径"><a href="#4-3-配置-istioctl-工具路径" class="headerlink" title="4.3 配置 istioctl 工具路径"></a>4.3 配置 istioctl 工具路径</h3><p>​    istioctl 是 istio 的客户端工具，其作用是手动注入 envoy 作为容器的 sidecar（边车）。什么是 sidecar？你就把它当成鸡你太美的经纪人，懂了没？就是负责跟外界打交道的。配置方式如下：</p><blockquote><p>cd istio-1.4.5</p><p>export PATH=$PATH:$PWD/bin</p></blockquote><p>​    配置完，在 bash 中就可以通过 Tab 键自动补全 istioctl 命令了。但是这样够吗？完美吗？当然不。我们还有更高的要求。</p><p>​    因为 istioctl 有很多配置项，仅仅使用 tab 键只能自动补全 istioctl，但是无法自动补全 istioctl manifest 类似这样的子命令。因此我们需要设置增强自动补全功能。</p><h3 id="4-4-实现-istioctl-自动补全功能"><a href="#4-4-实现-istioctl-自动补全功能" class="headerlink" title="4.4 实现 istioctl 自动补全功能"></a>4.4 实现 istioctl 自动补全功能</h3><p>​    将 istio 安装包内 tools 目录下的 istioctl.bash 文件拷贝到用户根目录下：</p><blockquote><p>cp istio/istio-1.4.5/tools/istioctl.bash ~</p></blockquote><p>​    编辑 ~/.bash_profile 文件，在文件末尾添加如下内容：</p><blockquote><p>source ~/istioctl.bash</p></blockquote><p>​    添加完毕后，加载配置使配置生效：</p><blockquote><p>source ~/.bash_profile</p></blockquote><p>​    然后输入 istioctl 然后按两次 tab 键，发现增强自动补全功能已经生效：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911163319451.png" srcset="/img/loading.gif" lazyload alt="image-20210911163319451"></p><h3 id="4-5-安装学习版-istio"><a href="#4-5-安装学习版-istio" class="headerlink" title="4.5 安装学习版 istio"></a>4.5 安装学习版 istio</h3><p>​    为了降低学习成本，我们选择安装学习版本的 istio。如果你想直接在生产环境安装 istio，可以参考我后续的章节。</p><p>​    执行如下语句安装 istio 学习版：</p><blockquote><p>istioctl manifest apply –set profile=demo</p></blockquote><p>​    安装后的截图如下：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911163332691.png" srcset="/img/loading.gif" lazyload alt="image-20210911163332691"></p><p>​    不要一看到 Installation complete 就高兴到尖叫！因为安装完毕不报错并不意味着你就成功了，就像你看到一个美丽、性感、火辣、清纯、高贵、华丽集一身的女人向你走过来时就以为人家觉得你长得帅想泡你一样的道理。</p><p>​    使用如下命令查看一下 istio 的服务状态：</p><blockquote><p>kubectl get svc -n istio-system</p></blockquote><p>​    执行结果如下图所示：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911163351397.png" srcset="/img/loading.gif" lazyload alt="image-20210911163351397"></p><p>​    服务使用 LoadBalancer 类型一般是在第三方云厂商支持下才有用。如果你是在自己搭建的 k8s 集群环境下一般使用 NodePort 类型。执行如下语句完爆：</p><blockquote><p>kubectl patch svc -n istio-system istio-ingressgateway -p ‘{“spec”: {“type”: “NodePort”}}’</p></blockquote><p>​    执行完毕后，再次查看 svc，发现原来的 LoadBalancer 类型已经被修改为 NodePort 类型，此外 external-ip 也从 pending 状态变成了 <none>(即：不需要)状态。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911163422494.png" srcset="/img/loading.gif" lazyload alt="image-20210911163422494"></p><p>​    查看 istio 的 pod 运行状态：</p><blockquote><p>kubectl get pod -n istio-system</p></blockquote><p>​    运行状态截图如下，所有 pod 状态都是 running 状态：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911163442809.png" srcset="/img/loading.gif" lazyload alt="image-20210911163442809"></p><p>​    自此，整个 istio 环境就被你轻松完爆了。现在你可以停下来，上厕所，喝水和尖叫了。</p><h3 id="4-6-卸载-istio"><a href="#4-6-卸载-istio" class="headerlink" title="4.6 卸载 istio"></a>4.6 卸载 istio</h3><p>​    但是假如你觉得不够爽，光有建立的快感，没有破坏的快感总是觉得技术人生不够圆满的话，你可以执行如下语句轻松完爆 istio。</p><blockquote><p>istioctl manifest generate –set profile=demo | kubectl delete -f -</p></blockquote><hr><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>​    好了，一切都回到了原点。这种感觉像极了你拥有了一个女人，然后蹂躏了一番后，又抛弃她的感觉。但是望着消失了一切后的黑乎乎的屏幕后，你或许点燃了一颗烟，问问自己，抛弃的感觉是否真的快乐？如果没有，你就把文章拉倒起点，再来一遍吧。也许当你操作完后，你会重新追回你深爱的她。</p>]]></content>
    
    
    <categories>
      
      <category>istio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux 系列之一《升级内核》</title>
    <link href="/2021/09/11/linux%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E3%80%8A%E5%86%85%E6%A0%B8%E5%8D%87%E7%BA%A7%E3%80%8B/"/>
    <url>/2021/09/11/linux%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E3%80%8A%E5%86%85%E6%A0%B8%E5%8D%87%E7%BA%A7%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-操作系统的内核与发行版"><a href="#1-操作系统的内核与发行版" class="headerlink" title="1 操作系统的内核与发行版"></a>1 操作系统的内核与发行版</h1><p>&emsp;&emsp;首先简单解释一下什么是操作系统的内核和发行版。</p><p>&emsp;&emsp;内核是管理 CPU、内存、磁盘、进程、调度、中断、文件系统以及网络协议栈的程序。</p><p>&emsp;&emsp;用户对内核感知度不高，因为用户只需要应用程序。比如有些人迷恋日本电影，ta 并不在乎内核，ta 需要的只是一个播放器，这怎么办呢？于是就有好事者在内核之外预安装了一个播放器给 ta 使用，随着类似的需求不断增多，预安装的程序也越来越多，逐渐就发展成为了内核和应用程序集的”结合体”，这个”结合体”我们就称之为操作系统的发行版。</p><hr><h1 id="2-内核版本查看"><a href="#2-内核版本查看" class="headerlink" title="2 内核版本查看"></a>2 内核版本查看</h1><blockquote><p>uname -r</p></blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911153702098.png" srcset="/img/loading.gif" lazyload alt="image-20210911153702098"></p><hr><h1 id="3-自动升级"><a href="#3-自动升级" class="headerlink" title="3 自动升级"></a>3 自动升级</h1><blockquote><p>yum install -y kernel</p></blockquote><p>&emsp;&emsp;使用 yum 升级内核是相对而言最安全的升级方式了，因为是经过发行版厂商验证过的版本。一般情况下，它并不是最新的，但却是最稳定的。</p><hr><h1 id="4-手动升级"><a href="#4-手动升级" class="headerlink" title="4 手动升级"></a>4 手动升级</h1><p>&emsp;&emsp;手动升级是一件比较刺激的事情。首先到 linux 内核网站膜拜一下上帝。点击<a href="https://www.kernel.org/"> 网址</a>查看：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/spacer.gif" srcset="/img/loading.gif" lazyload alt="第一章 九析带你轻松升级 linux kernel_运维_02"><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911153728956.png" srcset="/img/loading.gif" lazyload alt="image-20210911153728956"></p><p>&emsp;&emsp;看到没，多质朴，绝对不会亲近你，要多土就多土。我就喜欢这样的土。那个时代就是这样。想当年为了上个网，晚上趁着爹妈都睡着了偷偷摸摸爬起来把猫连上电话线，听到类似摩尔密码的滴滴声响起，心里那个激动啊，就跟当今小骚妹看到李佳琦一样一样的。</p><h2 id="4-1-下载安装包"><a href="#4-1-下载安装包" class="headerlink" title="4.1 下载安装包"></a>4.1 下载安装包</h2><p>&emsp;&emsp;下载网址：<a href="https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/"> https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/</a>。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911153808360.png" srcset="/img/loading.gif" lazyload alt="image-20210911153808360"></p><h2 id="4-2-解压缩安装包"><a href="#4-2-解压缩安装包" class="headerlink" title="4.2 解压缩安装包"></a>4.2 解压缩安装包</h2><blockquote><p>tar -zxvf linux-4.14.tar.gz</p></blockquote><h2 id="4-3-编译安装"><a href="#4-3-编译安装" class="headerlink" title="4.3 编译安装"></a>4.3 编译安装</h2><blockquote><p>yum install -y gcc bc openssl-devel perl </p><p>make mrproper         # 删除编译生成的文件，包括内核配置文件和各种配置文件，一般只有在第一次执行内核编译前才使用这条命令</p><p>make oldconfig         # 使用原有的内核配置。执行过程中需要交互，一路回车即可</p><p>make             # 编译源码。所有执行操作中最耗时的部分。你可以睡个午觉</p><p>make modules_install    # 将编译出的内核模块复制到 /lib/modules</p><p>make install        # make是编译；make install 安装到指定位置(/boot)</p></blockquote><h2 id="4-4-重启"><a href="#4-4-重启" class="headerlink" title="4.4 重启"></a>4.4 重启</h2><p>&emsp;&emsp;重启后在 grub 中选择 4.14 版本。</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911153835264.png" srcset="/img/loading.gif" lazyload alt="image-20210911153835264"></p><p>&emsp;&emsp;启动成功后，再次查看内核版本，发现已经轻松完爆：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911153852122.png" srcset="/img/loading.gif" lazyload alt="image-20210911153852122"></p><hr><h1 id="5-后记"><a href="#5-后记" class="headerlink" title="5 后记"></a>5 后记</h1><p>&emsp;&emsp;当然为了偷懒可以采用在线升级的方式。升级步骤如下：</p><h2 id="5-1-安装-elrepo-yum-源"><a href="#5-1-安装-elrepo-yum-源" class="headerlink" title="5.1 安装 elrepo yum 源"></a>5.1 安装 elrepo yum 源</h2><p>&emsp;&emsp;elrepo 是 CentOS 稳定的软件源，通过它，可以很容易将内核升级到指定版本。 elrepo 项目网址请<a href="https://elrepo.org/tiki/tiki-index.php"> 点击</a>：</p><blockquote><p>yum install -y <a href="https://www.elrepo.org/elrepo-release-7.0-4.el7.elrepo.noarch.rpm"> https://www.elrepo.org/elrepo-release-7.0-4.el7.elrepo.noarch.rpm</a></p></blockquote><h2 id="5-2-查看内核包"><a href="#5-2-查看内核包" class="headerlink" title="5.2 查看内核包"></a>5.2 查看内核包</h2><blockquote><p>yum –disablerepo=”*” –enablerepo=”elrepo-kernel” list available</p></blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911153911399.png" srcset="/img/loading.gif" lazyload alt="image-20210911153911399"></p><h2 id="5-3-升级内核"><a href="#5-3-升级内核" class="headerlink" title="5.3 升级内核"></a>5.3 升级内核</h2><p>&emsp;&emsp;在 elrepo 源中有 ml 和 lt 两种内核。ml（mainline）为最新版本的内核，lt 为长期支持的内核。这里选择 ml 内核。</p><blockquote><p>yum –enablerepo=elrepo-kernel -y install kernel-ml</p></blockquote><h2 id="5-4-修改内核启动顺序"><a href="#5-4-修改内核启动顺序" class="headerlink" title="5.4 修改内核启动顺序"></a>5.4 修改内核启动顺序</h2><p>&emsp;&emsp;修改 /etc/default/grub 文件，将 GRUB_DEFAULT 改为 0：</p><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911153928164.png" srcset="/img/loading.gif" lazyload alt="image-20210911153928164"></p><p>&emsp;&emsp;编辑完后，执行如下命令让配置生效：</p><blockquote><p>grub2-mkconfig -o /boot/grub2/grub.cfg</p></blockquote><p><img src="https://gitee.com/jianshen-bao/blog-img/raw/master/img/image-20210911153942984.png" srcset="/img/loading.gif" lazyload alt="image-20210911153942984"></p><h2 id="5-5-重启系统"><a href="#5-5-重启系统" class="headerlink" title="5.5 重启系统"></a>5.5 重启系统</h2><blockquote><p>reboot</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>client-go 系列之三《go k8s 访问》</title>
    <link href="/2021/09/06/k8s%E5%BC%80%E5%8F%91%E4%B9%8Bclient-go%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%89%E3%80%8AGO-K8S-%E8%AE%BF%E9%97%AE%E3%80%8B/"/>
    <url>/2021/09/06/k8s%E5%BC%80%E5%8F%91%E4%B9%8Bclient-go%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%89%E3%80%8AGO-K8S-%E8%AE%BF%E9%97%AE%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>&emsp;&emsp;上节介绍了 GO 项目开发的配置，本小节会利用 client-go 库实际编写一个访问 K8S 的样例。</p><h1 id="2-运行环境"><a href="#2-运行环境" class="headerlink" title="2 运行环境"></a>2 运行环境</h1><p>&emsp;&emsp;本系列文章使用的环境配置如下（不要求读者完全匹配，可根据自己实际情况酌情处理）：</p><ul><li>K8s        版本 :  <strong>1.19.0</strong></li><li>Docker  版本：<strong>20.10.8</strong></li><li>CentOS 版本：<strong>7.7.1908</strong></li><li>Go SDK 版本：<strong>go1.16.6 linux/amd64</strong></li></ul><h1 id="3-项目代码"><a href="#3-项目代码" class="headerlink" title="3 项目代码"></a>3 项目代码</h1><p>&emsp;&emsp;进入 GO 项目的根目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">cd</span> <span class="hljs-variable">$GOPATH</span>/src</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;新建 k8s-visitor 项目目录，并在该目录下创建 main.go 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> mkdir k8s-visitor</span><br><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">cd</span> k8s-visitor</span><br><span class="hljs-meta">#</span><span class="bash"> touch main.go</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;编辑 main.go 文件，添加如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;io/ioutil&quot;</span><br><br>    core_v1 <span class="hljs-string">&quot;k8s.io/api/core/v1&quot;</span><br>    meta_v1 <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/client-go/kubernetes&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/client-go/rest&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/client-go/tools/clientcmd&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> (<br>        err          error<br>        kubeconfig   []<span class="hljs-keyword">byte</span><br>        clientconfig *rest.Config<br>        clientset    *kubernetes.Clientset<br>        pods       *core_v1.PodList<br>    )   <br><br>    <span class="hljs-keyword">if</span> kubeconfig, err = ioutil.ReadFile(<span class="hljs-string">&quot;/root/.kube/config&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;   <br><br>    <span class="hljs-keyword">if</span> clientconfig, err = clientcmd.RESTConfigFromKubeConfig(kubeconfig); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;   <br><br>    <span class="hljs-keyword">if</span> clientset, err = kubernetes.NewForConfig(clientconfig); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;   <br><br>    <span class="hljs-keyword">if</span> pods, err = clientset.CoreV1().Pods(<span class="hljs-string">&quot;default&quot;</span>).List(context.TODO(), meta_v1.ListOptions&#123;&#125;); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br><br>    fmt.Println(pods)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-运行项目"><a href="#4-运行项目" class="headerlink" title="4 运行项目"></a>4 运行项目</h1><p>&emsp;&emsp;如果想运行成功上面的代码样例，需执行如下两个步骤：</p><ul><li>创建 go.mod</li><li>运行 main.go</li></ul><h2 id="4-1-创建-go-mod"><a href="#4-1-创建-go-mod" class="headerlink" title="4.1 创建 go.mod"></a>4.1 创建 go.mod</h2><p>&emsp;&emsp;go mod 在 GO v1.11 版本引入，在 v1.12 版本基本稳定，到 v1.13 版本的时候默认是打开的，可以使用如下命令查看：        </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@k8s-master-1 k8s-visitor]# go env | grep -i GO111MODULE<br>GO111MODULE=&quot;on&quot;<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;执行下列命令创建 go.mod 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@k8s-master-1 k8s-visitor]# go mod init<br>go: creating new go.mod: module k8s-visitor<br>go: to add module requirements and sums:<br>go mod tidy<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;如果执行结果如上所示，继续执行下面指令（备注，如果指令执行失败，很大概率是依赖包下不到，可参考本系列第一篇文章配置好下载包代理）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@k8s-master-1 k8s-visitor]# go mod tidy<br>go: finding module for package k8s.io/client-go/tools/clientcmd<br>go: finding module for package k8s.io/client-go/kubernetes<br>go: finding module for package k8s.io/client-go/rest<br>go: finding module for package k8s.io/api/core/v1<br>go: finding module for package k8s.io/apimachinery/pkg/apis/meta/v1<br>go: found k8s.io/api/core/v1 in k8s.io/api v0.22.1<br>go: found k8s.io/apimachinery/pkg/apis/meta/v1 in k8s.io/apimachinery v0.22.1<br>go: found k8s.io/client-go/kubernetes in k8s.io/client-go v0.22.1<br>go: found k8s.io/client-go/rest in k8s.io/client-go v0.22.1<br>go: found k8s.io/client-go/tools/clientcmd in k8s.io/client-go v0.22.1<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;执行完毕后， $GOPATH/src/k8s-visitor 目录结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@k8s-master-1 k8s-visitor]# tree<br>.<br>├── go.mod<br>├── go.sum<br>└── main.go<br><br>0 directories, 3 files<br></code></pre></td></tr></table></figure><h2 id="4-2-运行-main-go"><a href="#4-2-运行-main-go" class="headerlink" title="4.2 运行 main.go"></a>4.2 运行 main.go</h2><p>&emsp;&emsp;运行 main.go：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">[root@k8s-master<span class="hljs-number">-1</span> k8s-visitor]# <span class="hljs-keyword">go</span> run main.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;如果读者输出的结果是 k8s default 命名空间下的 pod 列表信息则表示程序执行成功。下图是笔者的运行结果，仅供参考：</p><p><img src="/img/20210907213207.jpg" srcset="/img/loading.gif" lazyload alt="K8S POD 列表明细"></p><p>&emsp;&emsp;自此，第一个 client-go 程序编写完毕并运行成功。</p><h2 id="4-3-源码解释"><a href="#4-3-源码解释" class="headerlink" title="4.3 源码解释"></a>4.3 源码解释</h2><p>&emsp;&emsp;下面简单介绍程序代码逻辑。</p><h3 id="4-3-1-读取-K8S-配置"><a href="#4-3-1-读取-K8S-配置" class="headerlink" title="4.3.1 读取 K8S 配置"></a>4.3.1 读取 K8S 配置</h3><p>&emsp;&emsp;client-go 需要连接配置才可以访问到 K8S，比如 IP、Port、CA 或 token 等。K8S 默认将连接配置存放在 master 节点的 ~/.kube/config 文件中，比如笔者配置如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell">apiVersion: v1<br>clusters:<br>- cluster:<br>    certificate-authority: /etc/kubernetes/pki/ca.crt<br>    server: https://10.110.101.109:6443<br>  name: default<br>- cluster:<br>    certificate-authority: /etc/kubernetes/pki/ca.crt<br>    server: https://10.110.101.109:6443<br>  name: k8s-cluster<br>contexts:<br>- context:<br>    cluster: default<br>    user: admin<br>  name: default<br>- context:<br>    cluster: k8s-cluster<br>    namespace: jiuxi<br>    user: admin<br>  name: k8s-context<br>current-context: default<br>kind: Config<br>preferences: &#123;&#125;<br>users:<br>- name: admin<br>  user:<br>    client-certificate: /etc/kubernetes/pki/client.crt<br>    client-key: /etc/kubernetes/pki/client.key<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;下列代码读取上面 config 配置文件，保存在 kubeconfig 切片中，如果读者 K8S 默认配置文件地址（/root/.kube/config）与笔者不同，请根据实际情况进行修改。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> kubeconfig, err = ioutil.ReadFile(<span class="hljs-string">&quot;/root/.kube/config&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-built_in">panic</span>(err)<br>&#125;  <br></code></pre></td></tr></table></figure><h2 id="4-3-2-创建客户端配置对象"><a href="#4-3-2-创建客户端配置对象" class="headerlink" title="4.3.2 创建客户端配置对象"></a>4.3.2 创建客户端配置对象</h2><p>&emsp;&emsp;下列代码将上面创建的 kubeconfig 切片转化为客户端配置对象，读者如果觉得费解，可以简单理解为单纯的数据类型转换，即：从切片转化为对象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> clientconfig, err = clientcmd.RESTConfigFromKubeConfig(kubeconfig); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-built_in">panic</span>(err)<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="4-3-3-创建客户端访问对象"><a href="#4-3-3-创建客户端访问对象" class="headerlink" title="4.3.3 创建客户端访问对象"></a>4.3.3 创建客户端访问对象</h2><p>&emsp;&emsp;下列代码根据上面创建的配置对象（clientconfig）生成客户端访问对象（clientset），clientset 是 client-go 针对 K8S 每种内置资源（比如：Pod，Deployment）封装的客户端访问对象，该对象内部封装资源操作的 API（比如 delete、create、apply），读者可直接拿来使用，不用自己创造轮子。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> clientset, err = kubernetes.NewForConfig(clientconfig); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-built_in">panic</span>(err)<br>&#125;   <br></code></pre></td></tr></table></figure><h2 id="4-3-4-访问-K8S-获取-Pod-列表"><a href="#4-3-4-访问-K8S-获取-Pod-列表" class="headerlink" title="4.3.4 访问 K8S 获取 Pod 列表"></a>4.3.4 访问 K8S 获取 Pod 列表</h2><p>&emsp;&emsp;下列代码利用 clientset API 获取 K8S default 命名空间下的 Pod 列表。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> pods, err = clientset.CoreV1().Pods(<span class="hljs-string">&quot;default&quot;</span>).List(context.TODO(), meta_v1.ListOptions&#123;&#125;); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-built_in">panic</span>(err)<br>&#125; <br></code></pre></td></tr></table></figure><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h1><p>&emsp;&emsp;本节给出了一个实际样例介绍如何使用 client-go 连接 K8S，这是项目开发的基础，后续所有项目将基于此开发，请大家认真体会。</p>]]></content>
    
    
    <categories>
      
      <category>client-go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>client-go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>client-go 系列之二《go 项目设置》</title>
    <link href="/2021/08/28/k8s%E5%BC%80%E5%8F%91%E4%B9%8Bclient-go%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E3%80%8AGO-%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE%E3%80%8B/"/>
    <url>/2021/08/28/k8s%E5%BC%80%E5%8F%91%E4%B9%8Bclient-go%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E3%80%8AGO-%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>&emsp;&emsp;上节介绍了 client-go 和 GO SDK 安装，本小节将介绍 GO 项目配置，并给出一个 GO 项目实例。</p><h1 id="2-运行环境"><a href="#2-运行环境" class="headerlink" title="2 运行环境"></a>2 运行环境</h1><p>&emsp;&emsp;本系列文章使用的环境配置如下（不要求读者完全匹配，可根据自己实际情况酌情处理）：</p><ul><li>K8s        版本 :  <strong>1.19.0</strong></li><li>Docker  版本：<strong>20.10.8</strong></li><li>CentOS 版本：<strong>7.7.1908</strong></li><li>Go SDK 版本：<strong>go1.16.6 linux/amd64</strong></li></ul><h1 id="3-项目设置"><a href="#3-项目设置" class="headerlink" title="3 项目设置"></a>3 项目设置</h1><p>&emsp;&emsp;进行 GO 项目开发一般需要两个步骤：</p><ul><li><p>创建项目根目录</p></li><li><p>设置 GOPATH</p></li></ul><h2 id="3-1-创建项目根目录"><a href="#3-1-创建项目根目录" class="headerlink" title="3.1 创建项目根目录"></a>3.1 创建项目根目录</h2><p>&emsp;&emsp;好的目录结构往往是项目成功的开始，执行下列命令创建项目根目录，以后所有 GO 项目开发都统一在此根目录之下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> /root/go 是项目的根目录</span><br>[root@jiuxi ~]# mkdir -p /root/go<br>[root@jiuxi ~]# mkdir -p /root/go/bin /root/go/src /root/go/pkg<br>[root@jiuxi ~]# tree /root/go<br>/root/go<br>├── bin<br>├── pkg<br>└── src<br><br>3 directories, 0 files<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;目录结构说明如下：</p><blockquote><p>bin: go 二进制可执行程序的存放路径，比如通过 go install 生成的代码</p><p>pkg: 项目开发过程中，三方依赖库的存放路径</p><p>src: 项目源码存放路径，一般我们编写的项目代码都放在此处</p></blockquote><h2 id="3-2-设置-GOPATH"><a href="#3-2-设置-GOPATH" class="headerlink" title="3.2 设置 GOPATH"></a>3.2 设置 GOPATH</h2><p>&emsp;&emsp;GO SDK 需要设置 GOROOT 环境变量，用来存储 GO SDK 的安装路径。</p><p>&emsp;&emsp;GO 项目开发需要设置 GOPATH 环境变量，用来存储 GO 项目的根目录。</p><p>&emsp;&emsp;编辑 /etc/profile 文件，在文件末尾添加如下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export GOPATH=/root/go<br>export PATH=$PATH:$GOPATH/bin<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;保存文件，然后在命令行执行如下命令使配置生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@jiuxi go]# source /etc/profile<br>[root@jiuxi go]# echo $GOPATH<br>/root/go<br></code></pre></td></tr></table></figure><p>如果执行结果如上所示，说明 GOPATH 设置成功。</p><h1 id="4-项目样例"><a href="#4-项目样例" class="headerlink" title="4 项目样例"></a>4 项目样例</h1><p>&emsp;&emsp;一切都准备就绪，可以写个小项目练练手了。</p><h2 id="4-1-创建项目"><a href="#4-1-创建项目" class="headerlink" title="4.1 创建项目"></a>4.1 创建项目</h2><p>&emsp;&emsp;执行如下命令创建 client-go-quick-start  项目，注意一定要在 $GOPATH/src 路径下创建。        </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@jiuxi go]# cd $GOPATH/src<br>[root@jiuxi src]# mkdir client-go-quick-start<br>[root@jiuxi src]# tree $GOPATH/src<br>/root/go/src<br>└── client-go-quick-start<br><br>1 directory, 0 files<br></code></pre></td></tr></table></figure><h2 id="4-2-编写代码"><a href="#4-2-编写代码" class="headerlink" title="4.2 编写代码"></a>4.2 编写代码</h2><p>&emsp;&emsp;在 client-go-quick-start 目录下创建 main.go 文件，内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println( <span class="hljs-string">&quot;client-go quick start tutorial&quot;</span> )<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-3-运行代码"><a href="#4-3-运行代码" class="headerlink" title="4.3 运行代码"></a>4.3 运行代码</h2><p>&emsp;&emsp;执行下面命令运行 main.go 程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@jiuxi client-go-quick-start]# go run main.go <br>client-go quick start tutorial<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;如果执行结果如上所示，说明程序运行正常，此时读者可以暂时放松一下，泡杯咖啡犒劳一下自己，因为从下节开始我们将正式开启 client-go 操作 K8S 旅程，请调整一下坐姿，我们发车了。</p>]]></content>
    
    
    <categories>
      
      <category>client-go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>client-go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>client-go 系列之一《go sdk 配置》</title>
    <link href="/2021/08/24/k8s%E5%BC%80%E5%8F%91%E4%B9%8Bclient-go%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E3%80%8AGO-SDK-%E8%AE%BE%E7%BD%AE%E3%80%8B/"/>
    <url>/2021/08/24/k8s%E5%BC%80%E5%8F%91%E4%B9%8Bclient-go%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E3%80%8AGO-SDK-%E8%AE%BE%E7%BD%AE%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>&emsp;&emsp;client-go 是官方提供的 go 语言客户端库，可以跟 K8S API Server 进行交互。如果开发者想对 K8S 进行二次开发，可直接拿来使用，不必重复造轮子。</p><p>&emsp;&emsp;client-go 已集成进 K8S 源码，所以 K8S 组件之间也采用 client-go 进行通信（例如 kubectl 操作 API Server）。client-go 在 K8S 源码中存放的路径是 vendor/k8s.io/client-go，如下图所示：</p><p><img src="/img/20210824190058.jpg" srcset="/img/loading.gif" lazyload alt="client-go 在 K8S 源码中的存放路径"></p><p>&emsp;&emsp;本系列文章会全方面介绍 client-go，包括快速上手、架构设计和源码剖析，在源码剖析章节会重点介绍 Informer 机制（此机制是 K8S 组件之间相互通信的基石）。</p><p>&emsp;&emsp;如果想真正学好 K8S，仅仅会操作是远远不够地，只有真实地触摸到代码底层，并实际了解其内部数据结构和运行机制，才能有“不畏浮云遮望眼，自缘身在最高层”的体悟。</p><h1 id="2-前提"><a href="#2-前提" class="headerlink" title="2 前提"></a>2 前提</h1><p>&emsp;&emsp;本系列文章并不要求读者一定具备 go 语言背景，考虑到大多数人的认知习惯，所以笔者采用了一种先易后难、循序渐进、层层铺垫的编写方式，当然如果碰上喜欢挑战、勤于练胆、不撞南墙就浑身不舒坦的读者，本教程依旧适合，您只需要从后往前读即可。</p><p>&emsp;&emsp;尽管本系列文章对读者的水平做到了最大程度的宽容，但如果想真切感受到程序运行带来的快感，建议还是配置 go sdk、go 项目开发环境和 K8S 运行环境。正所谓“<em>九层之台，起于累土；千里之行，始于足下</em>”，个人认为老子的话还是要听一听的。</p><p><img src="/img/20210824.jpg" srcset="/img/loading.gif" lazyload alt="老子与道"></p><h1 id="3-运行环境"><a href="#3-运行环境" class="headerlink" title="3 运行环境"></a>3 运行环境</h1><p>&emsp;&emsp;本系列所采用的环境信息如下（不要求读者完全匹配，可根据实际情况酌情处理，但建议 go sdk 版本不要过低）：</p><ul><li>K8S        版本 :  <strong>1.19.0</strong></li><li>Docker  版本：<strong>20.10.8</strong></li><li>CentOS 版本：<strong>7.7.1908</strong></li><li>GO SDK 版本：<strong>go1.16.6 linux/amd64</strong></li></ul><h1 id="4-GO-SDK-安装"><a href="#4-GO-SDK-安装" class="headerlink" title="4 GO SDK 安装"></a>4 GO SDK 安装</h1><p>&emsp;&emsp;安装步骤如下，如果读者已经安装过，可直接跳到下一章节继续阅读：</p><ul><li><p>下载和解压缩</p></li><li><p>设置环境变量</p></li><li><p>验证是否安装成功</p></li><li><p>配置包下载代理（可选但推荐）</p></li></ul><h2 id="4-1-下载和解压缩"><a href="#4-1-下载和解压缩" class="headerlink" title="4.1 下载和解压缩"></a>4.1 下载和解压缩</h2><p>&emsp;&emsp;在命令行执行如下指令下载和解压缩 GO SDK：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">cd</span> /opt</span> <br><span class="hljs-meta">#</span><span class="bash"> yum install -y wget</span><br><span class="hljs-meta">#</span><span class="bash"> wget https://golang.google.cn/dl/go1.16.6.linux-amd64.tar.gz</span><br><span class="hljs-meta">#</span><span class="bash"> tar -zxvf go1.16.6.linux-amd64.tar.gz -C /usr/<span class="hljs-built_in">local</span></span><br></code></pre></td></tr></table></figure><h2 id="4-2-设置环境变量"><a href="#4-2-设置环境变量" class="headerlink" title="4.2 设置环境变量"></a>4.2 设置环境变量</h2><p>&emsp;&emsp;编辑 /etc/profile 文件，在文件末尾添加下面内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">export GO111MODULE=on<br>export GOROOT=/usr/local/go<br>export PATH=$PATH:$GOROOT/bin<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;编辑保存后，在命令行执行如下语句使上面的配置生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">source</span> /etc/profile</span><br></code></pre></td></tr></table></figure><h2 id="4-3-验证是否安装成功"><a href="#4-3-验证是否安装成功" class="headerlink" title="4.3 验证是否安装成功"></a>4.3 验证是否安装成功</h2><p>&emsp;&emsp;安装完毕并设置好环境变量后，在命令行执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> go version</span><br>go version go1.16.6 linux/amd64<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;如果能正确显示 GO SDK 的版本（如上所示），则说明 SDK 安装成功。</p><h2 id="4-4-配置下载代理（可选但推荐）"><a href="#4-4-配置下载代理（可选但推荐）" class="headerlink" title="4.4 配置下载代理（可选但推荐）"></a>4.4 配置下载代理（可选但推荐）</h2><p>&emsp;&emsp;首先声明该步骤是可选的，但笔者强烈建议执行此步骤，因为在后面开发中会下载很多依赖包，如果采用默认代理，要么可能下载不到（具体原因，你懂的），要么下载速度巨慢，所以建议在命令行执行下面命令修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># GOPROXY=&quot;https://proxy.golang.org,direct&quot;</span></span><br><span class="hljs-meta">#</span><span class="bash"> go env GOPROXY</span><br><span class="hljs-meta">#</span><span class="bash"> go env -w GOPROXY=<span class="hljs-string">&quot;https://goproxy.io,direct&quot;</span></span><br><span class="hljs-meta">#</span><span class="bash"> go env GOPROXY</span><br>https://goproxy.io,direct<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;如果命令执行结果如上所示，表示修改成功，新代理路径已经改成 <a href="https://goproxy.io./">https://goproxy.io。</a></p><p>&emsp;&emsp;自此，整个 GO SDK 设置结束，读者可以进入到后续 GO 开发了。</p><h1 id="5-参考文献"><a href="#5-参考文献" class="headerlink" title="5 参考文献"></a>5 参考文献</h1><p>1 <a href="https://github.com/kubernetes/client-go">client-go 仓库</a> <a href="https://github.com/kubernetes/client-go">https://github.com/kubernetes/client-go</a></p>]]></content>
    
    
    <categories>
      
      <category>client-go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>client-go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式事务系列之二《事务》</title>
    <link href="/2021/08/14/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E3%80%8A%E4%BA%8B%E5%8A%A1%E3%80%8B/"/>
    <url>/2021/08/14/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E3%80%8A%E4%BA%8B%E5%8A%A1%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;上节介绍了单体架构，单体架构是整个漫长软件架构演进过程中使用人数最多、应用范围最广、也相对最稳定的一种架构。但随着业务多变、逻辑复杂性增加、交付时间越来越短，单体架构逐渐显出疲态，慢慢被分布式微服务架构所代替。</p><p>&emsp;&emsp;早期单体架构解决的核心问题是信息化，信息化处理的对象是数据，数据的质量直接影响到信息化的好坏。数据质量的判断有很多维度，其中最重要维度之一便是数据一致性。</p><h1 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h1><p>&emsp;&emsp;单纯的说教容易让人云里雾里，不妨举一个生活的例子。</p><p>&emsp;&emsp;我成长的年代还比较单纯，父母起名一般不会想太多。我至今记得一对男女同桌，女的叫做张开凤，男的叫做王里岛。下面就是他们的故事：</p><blockquote><p><strong>张开凤银行账户有 1000 块， 王里岛银行账户也有 1000 块</strong></p><p><strong>张开凤和王里岛相约进行爱的鼓掌，完事后，王里岛付给张开凤 200 块</strong></p><p><strong>张开凤现在账户里有 1200 块，而王里岛账户有 800 块</strong></p></blockquote><p>&emsp;&emsp;银行交易系统会执行如下语句：</p><blockquote><p><em><strong>update table account set savings = savings - 200 where name = “王里岛”</strong></em></p><p><em><strong>update table account set savings = savings + 200 where name = “张开凤”</strong></em></p></blockquote><p>&emsp;&emsp;如果交易系统执行第一条语句成功了，但在执行第二条语句的时候却失败了，那么张开凤就被白嫖了（但是王里岛是不会承认的，你仔细品一下）。</p><p>&emsp;&emsp;这真是一个悲伤的故事，悲剧的核心就在于数据不一致，碰到这样的事，作为一个有责任心的工程师是绝对不能坐视不理的。经过思考，我们发现该技术场景的痛点在于，如何保证一个事件序列的执行是原子的，即：要么全部执行成功，要么全部失败。</p><p><img src="/img/2021081402.png" srcset="/img/loading.gif" lazyload alt="02"></p><h1 id="事务定义"><a href="#事务定义" class="headerlink" title="事务定义"></a>事务定义</h1><p>&emsp;&emsp;事务想解决的本质问题就是数据状态的一致，有关事务的非官方定义如下：</p><ul><li><p>事务是操作数据源的程序（比如：一个事务可以是一条 SQL 语句，一组 SQL 语句或高级语言写的程序）</p></li><li><p>事务是一个不可分割的工作单元，单元内的操作要么全部执行成功，要么全部执行失败</p></li><li><p>事务是恢复和并发控制的基本单元</p></li></ul><h1 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h1><p>&emsp;&emsp;事务具有四个特征，这是小白面试时常被考的问题，教科书教导的顺序是 ACID（acid 中文翻译：酸）。笔者是个极其蠢笨的人，总是记不住，于是改良成 ICDA（中文翻译：爱操洞啊），就再没忘记过，这里冒死提供给读者，你们不用谢我。</p><blockquote><ul><li>I : isolation      （隔离性）。指一个事务内的事件序列执行时，不能被另外的事务所干扰</li><li>C: consistency（一致性）。指数据状态转换过程中必须是一致性</li><li>D: durability   （持久性）。指一旦事务提交之后，对数据库的改变就是永久的</li><li>A: atomic        （原子性）。指事务内的事件序列执行时是不可分割的，要么全部执行，要么都不执行</li></ul></blockquote><p>&emsp;&emsp;如果上面的学术解释让你昏昏欲睡，你可以换下面一种记法，结合“爱操洞啊”来理解，还是那句话，不用谢。</p><blockquote><ul><li>I : isolation      （隔离性）。I  就是“我”，世界上只有一个我，独一无二。所以本身具备隔离性、排他性</li><li>C: consistency（一致性）。C 就是“操”，操的对象必须一致，否则容易得病（你懂的）</li><li>D: durability   （持久性）。D 就是“洞”，面对洞一定要持久，这样她才会永远记得你（即使分手）</li><li>A: atomic        （原子性）。A  就是”啊“，高潮后发出的满足声音。要做就一定要高潮，否则就别做</li></ul></blockquote><p><img src="/img/2021081403.png" srcset="/img/loading.gif" lazyload alt="03"></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/9744607?fr=aladdin">事务百科</a> <a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/9744607?fr=aladdin">https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/9744607?fr=aladdin</a></li><li><a href="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fhbimg.b0.upaiyun.com%2F5ee7d275ed5f6adea8af216f4ae194ad0da7aa2d1a520-6askWI_fw658&refer=http%3A%2F%2Fhbimg.b0.upaiyun.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1631530265&t=40527bb540fa342f3c6211e57782423c">杜蕾斯图片</a> <a href="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fhbimg.b0.upaiyun.com%2F5ee7d275ed5f6adea8af216f4ae194ad0da7aa2d1a520-6askWI_fw658&amp;refer=http%3A%2F%2Fhbimg.b0.upaiyun.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1631530265&amp;t=40527bb540fa342f3c6211e57782423c">https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fhbimg.b0.upaiyun.com%2F5ee7d275ed5f6adea8af216f4ae194ad0da7aa2d1a520-6askWI_fw658&amp;refer=http%3A%2F%2Fhbimg.b0.upaiyun.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1631530265&amp;t=40527bb540fa342f3c6211e57782423c</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式事务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式事务系列之一《单体架构》</title>
    <link href="/2021/08/14/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E3%80%8A%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E3%80%8B/"/>
    <url>/2021/08/14/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E3%80%8A%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;分布式事务目标是解决数据一致性问题。在整个波澜壮阔的计算机科技发展史上，分布式事务并非一开始就存在，它只是历史发展的产物，随着软、硬件架构的不断更迭和演进才逐步发展起来的。</p><p>&emsp;&emsp;我还记得那是一个夏天，窗外鸟语花香，空气中满是新鲜和幸福的味道。那时路上还没有那么多车，苏堤远没有现在人流如织。在那个还流淌着小资的年代，软件从业者是小众的文艺小清新，也就在那时，我怀揣着改造世界的憧憬，莽撞地踏进了计算机的世界。</p><p>&emsp;&emsp;那时，世界远没有现在复杂，人心还没有那么险恶。我们没有微信、没有抖音、没有996、更没有内卷。我们悠闲地带耳机听着音乐、喝着咖啡。我们充满希望，用代码编织着内心的向往和美丽的梦。</p><p>&emsp;&emsp;那时，我们没有微服务，没有分布式，更没有分布式事务。我们只写单体……</p><p><img src="/img/2021081401.png" srcset="/img/loading.gif" lazyload alt="致敬那消失不再有的文艺时代"></p><h1 id="单体架构定义"><a href="#单体架构定义" class="headerlink" title="单体架构定义"></a>单体架构定义</h1><p>&emsp;&emsp;在网上找了很多的资料，不知道是不是因为单体架构简单到让人忽略的缘故，竟然很难找到官方定义或词条解释。但或许人类的认知都是从定义事物开始，所以我们不得不把搜寻的目光从官方转回到民间找寻答案，于是便有了下面的蹩脚英文定义：</p><blockquote><p><strong>What is a Monolith i.e. a monolithic architecture ?</strong></p><p><em>A monolithic application</em>, let’s call it a <em>Monolith</em>, is an application delivered via a single deployment unit. Examples could be an application delivered as single WAR or a Node application with a single entrypoint.</p></blockquote><p>&emsp;&emsp;翻译过来就是：</p><blockquote><p><strong>什么是单体应用/架构 ？</strong></p><p><em>单体应用（俗称巨石系统），是整体交付、统一部署的一类应用。比如通过 War 或者 node 部署的具有单一访问入口的应用</em></p></blockquote><p>&emsp;&emsp;分析上面非官方的定义，我们可以得出单体架构的特点：原子性。基于单体架构的应用都是原子而不可再分的，无论是交付还是部署，都必须作为一个统一的整体。</p><h1 id="单体架构分层"><a href="#单体架构分层" class="headerlink" title="单体架构分层"></a>单体架构分层</h1><p>&emsp;&emsp;上面我们定义了单体架构，但是通过定义，很容易会让我们产生认知错误，即：单体架构应用是简单的、缺乏层次的、由数据结构和算法堆积起来的、架构不友好的应用。</p><p>&emsp;&emsp;我承认，单体架构早期阶段确实是用血泪书写的。那时项目缺乏规范，从业者缺少指导，开发者又生猛异常。技术处理，多的是血性，少的是敬畏。在那个没有 bug，只有事故的年代，只要你敢乱来，就没有攻不破的系统。在笔者的亲身经历中就有幸经历过几个“生死”瞬间，为了不招惹是非，特隐去公司名。</p><blockquote><p>事故一：因为不合理的修改导致股票系统出问题，结果开发被能征惯战的东北股民问候了家长</p><p>事故二：因为电信出账单计算错误，贵州某地电信用户直接在营业厅上演平民版导火线</p><p>事故三：国内某电商支付公司早期秒杀业务，因为并发控制没控制好，导致手机被疯抢</p></blockquote><p>&emsp;&emsp;即使不出事故和故障，单体架构系统体量也足可以庞大到惊人，从编译到运行往往持续几十分钟，加一个 print 调试逻辑，一根烟都抽完了，结果却跑不出来。写到这里，笔者不禁停下来莞尔，过往经历犹如走马灯般在回忆中被解放。真怀念那个没有流程图、没有章法、信马由缰、涂鸦般的编码年代，一切都是那么“云原生”。每当黑黢黢的控制台颤悠悠显示出 XXX successful 字样时，那种赌徒般、大难不死的幸福感油然而生。</p><p>&emsp;&emsp;历史总是反复，而科技永远向前。技术最不愿放过的就是“痛点”，伴随着解决一个痛点，又生出一堆新的痛点 :-)。</p><p>&emsp;&emsp;工程师们被随心所欲的开发模式搞得苦不堪言，软件大师也被腐败不堪的技术负债搞得斯文扫地。于是大家围炉而坐，痛定思痛反省解决方案。终于，一切尘埃落定，“分层”腾空出世。从业务或职能（视图、控制、模型）等维度对单体应用进行分层，分层后的系统焕然一新，可维护性大幅提高。</p><p>&emsp;&emsp;分层架构模式如下图所示：</p><p><img src="/img/20210823174649.jpg" srcset="/img/loading.gif" lazyload alt="分层架构"></p><p>&emsp;&emsp;这样的分层架构模式一直延续至今，大名鼎鼎的 MVC 架构模式就脱胎于此，即便已经步入微服务时代，它依旧经典，依旧璀璨。</p><h1 id="单体架构部署"><a href="#单体架构部署" class="headerlink" title="单体架构部署"></a>单体架构部署</h1><p>&emsp;&emsp;单体架构应用因为原子性，不得不在单一进程空间，所有模块以及方法调用都不用考虑远程调用和网络。这样的部署、运行和访问方式简单、高效，出错的几率小，但同时也带来了隔离难、内存泄漏以及升级/扩展困难等不足。</p><p>&emsp;&emsp;下图是经典单体架构应用部署图：</p><p><img src="/img/20210823174716.jpg" srcset="/img/loading.gif" lazyload alt="单体架构"></p><h1 id="单体架构优点"><a href="#单体架构优点" class="headerlink" title="单体架构优点"></a>单体架构优点</h1><p>&emsp;&emsp;单体架构应用有很多优点：</p><ul><li>易于开发和调试：IDE（无论是本地还是云端）都天然支持单体架构应用的开发和调试</li><li>易于部署和运行：只需要在支持的运行时（Runtime）上部署交付组件即可（比如 war 包）</li><li>易于横向扩缩容：只需要通过在负载均衡器（比如 Nginx）后增加单体架构应用的多个副本即可</li></ul><h1 id="单体架构不足"><a href="#单体架构不足" class="headerlink" title="单体架构不足"></a>单体架构不足</h1><p>&emsp;&emsp;单体架构应用也有很多不足：</p><ul><li>复杂性高：所有代码在同一代码空间，即使分层，随着时间推移也会变得越来越庞大和复杂</li><li>全量部署：每次功能迭代或缺陷修复都需要部署整个应用。全量部署耗时长、影响范围广、风险高</li><li>隔离性差：整个单体架构应用依赖于相同运行环境。一旦某个模块出错，可能导致整个系统崩溃</li><li>垂直扩缩容成本高：遵从木桶理论。即使只有一个模块性能出现短板，也要求全量扩容</li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://programmerfriend.com/monolith-vs-microservices/">单体和微服务</a> <a href="https://programmerfriend.com/monolith-vs-microservices/">https://programmerfriend.com/monolith-vs-microservices/</a></li><li><a href="http://icyfenix.cn/architecture/architect-history/monolithic.html">凤凰架构</a> <a href="http://icyfenix.cn/architecture/architect-history/monolithic.html">http://icyfenix.cn/architecture/architect-history/monolithic.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式事务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
